---
title: Max Points on a Line
category: Math And Geometry
difficulty: Hard
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/max-points-on-a-line)

</Callout>

## Description

Given an array of <code>points</code> where <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> represents a point on the X-Y plane, return _the maximum number of points that lie on the same straight line_.

Example 1:

<Image
	alt=""
	src="https://assets.leetcode.com/uploads/2021/02/25/plane1.jpg"
	width={300}
	height={294}
/>
<br />
<pre className="overflow-x-auto">
	Input: points = [[1,1],[2,2],[3,3]] Output: 3
</pre>

Example 2:

<Image
	alt=""
	src="https://assets.leetcode.com/uploads/2021/02/25/plane2.jpg"
	width={300}
	height={294}
/>
<br />
<pre className="overflow-x-auto">
	Input: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]] Output: 4
</pre>

Constraints:

    - <code>1 &lt;= points.length &lt;= 300</code>
    - <code>points[i].length == 2</code>
    - <code>-10<sup>4</sup> &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>4</sup></code>
    - All the <code>points</code> are unique.

## Solution

### Javascript

```javascript
/**
 * @param {number[][]} points
 * @return {number}
 */
var maxPoints = function (points) {
	let res = 1

	for (let i = 0; i < points.length; i++) {
		const count = new Map()
		const point1 = points[i]
		for (let j = i + 1; j < points.length; j++) {
			const point2 = points[j]
			let slope
			if (point2[0] === point1[0]) {
				slope = Number.MAX_SAFE_INTEGER
			} else {
				slope = (point2[1] - point1[1]) / (point2[0] - point1[0])
			}
			!count.has(slope)
				? count.set(slope, 2)
				: count.set(slope, count.get(slope) + 1)

			res = Math.max(res, count.get(slope))
		}
	}
	return res
}
```

### Python

```python
class Solution:
    def maxPoints(self, points: List[List[int]]) -> int:
        # 1. For each pt determine if it lies on the longest line
        # 2. Count all pts with same slope
        # 3. Update result with max

        res = 1
        for i in range(len(points)):
            p1 = points[i]
            count = collections.defaultdict(int)
            for j in range(i + 1, len(points)):
                p2 = points[j]
                if p2[0] == p1[0]:
                    slope = float("inf")
                else:
                    slope = (p2[1] - p1[1]) / (p2[0] - p1[0])
                count[slope] += 1
                res = max(res, count[slope] + 1)
        return res

```

### C++

```cpp
class Solution {
public:
    int maxPoints(vector<vector<int>>& points) {
        int res = 1;
        for (int i=0; i<points.size(); ++i) {
            unordered_map<float, int> count;
            for (int j=i+1; j<points.size(); ++j) {
                float s = slope(points[i], points[j]);
                count[s] ++;
                res = max(res, count[s] + 1);
            }
        }
        return res;
    }
private:
    float slope(vector<int>& p1, vector<int>& p2) {
        if ((p2[0] - p1[0]) == 0)
            return INT_MAX; // aka edge case to handle a slope of infinity
        return (float) (p2[1] - p1[1]) / (float) (p2[0] - p1[0]);
    }
};
```

### Java

```java
Solution will be updated soon
```
