---
title: Happy Number
category: Math And Geometry
difficulty: Easy
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/happy-number)

</Callout>

## Description
Write an algorithm to determine if a number <code>n</code> is happy.

A happy number is a number defined by the following process:


	- Starting with any positive integer, replace the number by the sum of the squares of its digits.
	- Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.
	- Those numbers for which this process ends in 1 are happy.


Return <code>true</code> *if* <code>n</code> *is a happy number, and* <code>false</code> *if not*.

 
Example 1:

<br /><pre className="overflow-x-auto">
Input: n = 19
Output: true
Explanation:
1<sup>2</sup> + 9<sup>2</sup> = 82
8<sup>2</sup> + 2<sup>2</sup> = 68
6<sup>2</sup> + 8<sup>2</sup> = 100
1<sup>2</sup> + 0<sup>2</sup> + 0<sup>2</sup> = 1
</pre>

Example 2:

<br /><pre className="overflow-x-auto">
Input: n = 2
Output: false
</pre>

 
Constraints:


	- <code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code>



## Solution

### Javascript
```javascript
/**
 * Hash Set - seen dynamic
 * Time O(log(N)) | Space O(log(N))
 * https://leetcode.com/problems/happy-number/
 * @param {number} n
 * @return {boolean}
 */
 var isHappy = (n, seen = new Set()) => {
    const hasCycle = () => ((n === 1) || (seen.has(n)));
    while (!hasCycle()) {/* Time O(log(N)) */
        seen.add(n);         /* Space O(log(N)) */
        n = getNext(n);  /* Time O(log(N)) */
    }

    return (n === 1);
};

var getNext = (n, sum = 0) => {
    while (0 < n) {/* Time O(log(N)) */
        const remainder = (n % 10);

        n = Math.floor((n / 10));
        sum += (remainder * remainder);
    }

    return sum;
}

/**
 * Hash Set - seen static
 * Time O(log(N)) | Space O(1)
 * https://leetcode.com/problems/happy-number/
 * @param {number} n
 * @return {boolean}
 */
var isHappy = (n) => {
    const cycles = [ 4, 16, 37, 58, 89, 145, 42, 20 ];
    const seen = new Set(cycles);/* Time O(1)      | Space O(1) */

    const hasCycle = () => ((n === 1) || (seen.has(n)));
    while (!hasCycle()) {        /* Time O(log(N)) | Space O(1) */
        n = getNext(n);
    }

    return n === 1;
}

var getNext = (n, sum = 0) => {
    while (0 < n) {/* Time O(log(N)) */
        const remainder = (n % 10);

        n = Math.floor((n / 10));
        sum += (remainder * remainder);
    }

    return sum;
}

/**
 * Pointer - n === 1 || n === 4
 * Time O(log(N)) | Space O(1)
 * https://leetcode.com/problems/happy-number/
 * @param {number} n
 * @return {boolean}
 */
var isHappy = (n) => {
    const hasCycle = () => ((n === 1) || (n === 4));
    while (!hasCycle()) {/* Time O(log(N)) */
        n = getNext(n);  /* Time O(log(N)) */
    }

    return n === 1;
}

var getNext = (n, sum = 0) => {
    while (0 < n) {/* Time O(log(N)) */
        const remainder = (n % 10);
        
        n = Math.floor((n / 10));
        sum += (remainder * remainder);
    }

    return sum;
}

/**
 * Slow Fast
 * Time O(log(N)) | Space O(1)
 * https://leetcode.com/problems/happy-number/
 * @param {number} n
 * @return {boolean}
 */
var isHappy = (n) => {
    let [ slow, fast ] = [ n, getNext(n) ];
    
    const hasCyle = () => ((fast === 1) || (slow === fast));
    while (!hasCyle()) {              /* Time O(log(N)) */
        slow = getNext(slow);         /* Time O(log(N)) */
        fast = getNext(getNext(fast));/* Time O(log(N)) */
    }

    return (fast === 1);
}

var getNext = (n, sum = 0) => {
    while (0 < n) {/* Time O(log(N)) */
        const remainder = (n % 10);

        n = Math.floor((n / 10));
        sum += (remainder * remainder);
    }

    return sum;
}
```
### Python
```python
class Solution:
    def isHappy(self, n: int) -> bool:
        slow, fast = n, self.sumSquareDigits(n)

        while slow != fast:
            fast = self.sumSquareDigits(fast)
            fast = self.sumSquareDigits(fast)
            slow = self.sumSquareDigits(slow)

        return True if fast == 1 else False

    def sumSquareDigits(self, n):
        output = 0
        while n:
            output += (n % 10) ** 2
            n = n // 10
        return output

```
### C++
```cpp
/*
    Given num, replace by sum of squares of its digits
    Repeat until 1 or endless loop, determine if ends in 1
    Ex. n = 19 -> true, 1^2 + 9^2 = 82, 8^2 + 2^2 = 68 ... 1

    Detect cycle w/ slow/fast pointer technique
    If happy will eventually be 1, else pointers will meet

    Time: O(log n)
    Space: O(1)
*/

class Solution {
public:
    bool isHappy(int n) {
        int slow = n;
        int fast = getNext(n);
        
        while (slow != fast && fast != 1) {
            slow = getNext(slow);
            fast = getNext(getNext(fast));
        }
        
        if (fast == 1) {
            return true;
        }
        return false;
    }
private:
    int getNext(int n) {
        int sum = 0;
        while (n > 0) {
            int digit = n % 10;
            n /= 10;
            sum += pow(digit, 2);
        }
        return sum;
    }
};

```
### Java
```java
class Solution {

    public boolean isHappy(int n) {
        if (n == 1 || n == -1) {
            return true;
        }

        Set<Integer> visit = new HashSet<Integer>();

        // compute square until getting duplicate value
        while (!visit.contains(n)) {
            visit.add(n);
            // using helper function to compute the sum of squares
            n = sumOfSquare(n);

            if (n == 1) return true;
        }

        return false;
    }

    public int sumOfSquare(int n) {
        int output = 0;

        while (n != 0) {
            int digit = n % 10;
            digit = digit * digit;
            output += digit;
            n = n / 10;
        }

        return output;
    }
}

```


