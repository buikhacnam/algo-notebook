---
title: Zigzag Conversion
category: Math And Geometry
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/zigzag-conversion)

</Callout>

## Description
The string <code>&quot;PAYPALISHIRING&quot;</code> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)

<br /><pre className="overflow-x-auto">
P   A   H   N
A P L S I I G
Y   I   R
</pre>

And then read line by line: <code>&quot;PAHNAPLSIIGYIR&quot;</code>

Write the code that will take a string and make this conversion given a number of rows:

<br /><pre className="overflow-x-auto">
string convert(string s, int numRows);
</pre>

 
Example 1:

<br /><pre className="overflow-x-auto">
Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3
Output: &quot;PAHNAPLSIIGYIR&quot;
</pre>

Example 2:

<br /><pre className="overflow-x-auto">
Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4
Output: &quot;PINALSIGYAHRPI&quot;
Explanation:
P     I    N
A   L S  I G
Y A   H R
P     I
</pre>

Example 3:

<br /><pre className="overflow-x-auto">
Input: s = &quot;A&quot;, numRows = 1
Output: &quot;A&quot;
</pre>

 
Constraints:


	- <code>1 &lt;= s.length &lt;= 1000</code>
	- <code>s</code> consists of English letters (lower-case and upper-case), <code>&#39;,&#39;</code> and <code>&#39;.&#39;</code>.
	- <code>1 &lt;= numRows &lt;= 1000</code>



## Solution

### Javascript
```javascript
404: Not Found
```
### Python
```python
404: Not Found
```
### C++
```cpp
/*
    For each row the next chracter is at index 2 * (n -1) and 
    For middle rows there will be extra characters
    Time: O(n)
    Space: O(1)
*/
class Solution {
public:
    string convert(string s, int n) {
        // Edge case
        if(n == 1) return s;
        // Other cases
        // Take string to store answer
        string ans = "";
        // We are going to traverse each row
        for(int row = 0; row < n ; row++){
            // for each row the next chracter is at index 2 *  (n -1) 
            int increment = 2 *  (n -1);
            // For first and last rows 
            for(int i = row; i < s.length(); i+= increment){
                ans += s[i];
                // For middle rows there will be extra characters
                if(row > 0 && row < n-1 && i+increment - 2 * row < s.length()){
                    ans += s[i+increment - 2 * row];
                }
            }
        }
        return ans;
    }
};

```
### Java
```java
//We check whether we are at the diagonal or not using a boolean and increment the pointer accordingly.

class Solution {

    public String convert(String s, int row) {
        if (row == 1) return s;
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < row; i++) {
            int j = i;
            if (i == 0 || i == row - 1) {
                while (j < s.length()) {
                    sb.append(s.charAt(j));
                    j += 2 * (row - 1);
                }
            } else {
                boolean diagonal = false;
                while (j < s.length()) {
                    if (!diagonal) {
                        sb.append(s.charAt(j));
                        j += 2 * (row - i - 1);
                        diagonal = true;
                    } else {
                        sb.append(s.charAt(j));
                        j += 2 * i;
                        diagonal = false;
                    }
                }
            }
        }
        return sb.toString();
    }
}

```


