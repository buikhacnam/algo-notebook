---
title: Detect Squares
category: Math And Geometry
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/detect-squares)

</Callout>

## Description
You are given a stream of points on the X-Y plane. Design an algorithm that:


	- Adds new points from the stream into a data structure. Duplicate points are allowed and should be treated as different points.
	- Given a query point, counts the number of ways to choose three points from the data structure such that the three points and the query point form an axis-aligned square with positive area.


An axis-aligned square is a square whose edges are all the same length and are either parallel or perpendicular to the x-axis and y-axis.

Implement the <code>DetectSquares</code> class:


	- <code>DetectSquares()</code> Initializes the object with an empty data structure.
	- <code>void add(int[] point)</code> Adds a new point <code>point = [x, y]</code> to the data structure.
	- <code>int count(int[] point)</code> Counts the number of ways to form axis-aligned squares with point <code>point = [x, y]</code> as described above.


 
Example 1:
<Image alt="" src="https://assets.leetcode.com/uploads/2021/09/01/image.png" width={869} height={504} />
<br /><pre className="overflow-x-auto">
Input
[&quot;DetectSquares&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;count&quot;, &quot;count&quot;, &quot;add&quot;, &quot;count&quot;]
[[], [[3, 10]], [[11, 2]], [[3, 2]], [[11, 10]], [[14, 8]], [[11, 2]], [[11, 10]]]
Output
[null, null, null, null, 1, 0, null, 2]

Explanation
DetectSquares detectSquares = new DetectSquares();
detectSquares.add([3, 10]);
detectSquares.add([11, 2]);
detectSquares.add([3, 2]);
detectSquares.count([11, 10]); // return 1. You can choose:
                               //   - The first, second, and third points
detectSquares.count([14, 8]);  // return 0. The query point cannot form a square with any points in the data structure.
detectSquares.add([11, 2]);    // Adding duplicate points is allowed.
detectSquares.count([11, 10]); // return 2. You can choose:
                               //   - The first, second, and third points
                               //   - The first, third, and fourth points
</pre>

 
Constraints:


	- <code>point.length == 2</code>
	- <code>0 &lt;= x, y &lt;= 1000</code>
	- At most <code>3000</code> calls in total will be made to <code>add</code> and <code>count</code>.



## Solution

### Javascript
```javascript
/*
 * Time O(N) | Space O(N)
 * https://leetcode.com/problems/detect-squares
 */
class DetectSquares {
    constructor () {
        this.map = {};   /* Space O(N) */
        this.points = [];/* Space O(N) */
    }
    
    add (point, { map, points } = this) {
        const [ x, y ] = point;
        const key = this.getKey(x, y);
        const value = ((map[key] || 0) + 1);

        map[key] = value;  /* Space O(N) */
        points.push(point);/* Space O(N) */
    }

    count (point, { points } = this, score = 0) {
        const [ x1, y1 ] = point;

        for (const [ x2, y2 ] of points) {/* Time O(N) */
            const isSame = (Math.abs(x2 - x1) === Math.abs(y2 - y1));
            const isEqual = ((x1 === x2) || (y1 === y2));
            const canSkip = (!isSame || isEqual);
            if (canSkip) continue;

            score += this.getScore(x1, y1, x2, y2);
        }

        return score;
    };

    getKey (x, y) {
        return `${x},${y}`;
    }

    getScore (x1, y1, x2, y2, { map } = this) {
        const [ aKey, bKey ] = [ this.getKey(x1, y2), this.getKey(x2, y1) ];
        const [ aScore, bScore ] = [ (map[aKey] || 0), (map[bKey] || 0) ];
    
        return (aScore * bScore);
    }
};

/** 
 * Your DetectSquares object will be instantiated and called as such:
 * var obj = new DetectSquares()
 * obj.add(point)
 * var param_2 = obj.count(point)
 */
```
### Python
```python
class DetectSquares:
    def __init__(self):
        self.ptsCount = defaultdict(int)
        self.pts = []

    def add(self, point: List[int]) -> None:
        self.ptsCount[tuple(point)] += 1
        self.pts.append(point)

    def count(self, point: List[int]) -> int:
        res = 0
        px, py = point
        for x, y in self.pts:
            if (abs(py - y) != abs(px - x)) or x == px or y == py:
                continue
            res += self.ptsCount[(x, py)] * self.ptsCount[(px, y)]
        return res

```
### C++
```cpp
/*
    Given stream of points, add new points, return count of squares

    Find diagonals, if exists then forms a square, loop thru all points

    Time: O(1) add O(n^2) count -> n = number of points
    Space: O(n)
*/

class DetectSquares {
public:
    DetectSquares() {
        
    }
    
    void add(vector<int> point) {
        points[point[0]][point[1]]++;
    }
    
    int count(vector<int> point) {
        int x1 = point[0];
        int y1 = point[1];
        
        int result = 0;
        
        for (auto x = points.begin(); x != points.end(); x++) {
            unordered_map<int, int> yPoints = x->second;
            for (auto y = yPoints.begin(); y != yPoints.end(); y++) {
                int x3 = x->first;
                int y3 = y->first;
                
                // skip points on same x-axis or y-axis
                if (abs(x3 - x1) == 0 || abs(x3 - x1) != abs(y3 - y1)) {
                    continue;
                }
                
                result += points[x3][y3] * points[x1][y3] * points[x3][y1];
            }
        }
        
        return result;
    }
private:
    // {x -> {y -> count}}
    unordered_map<int, unordered_map<int, int>> points;
};

/**
 * Your DetectSquares object will be instantiated and called as such:
 * DetectSquares* obj = new DetectSquares();
 * obj->add(point);
 * int param_2 = obj->count(point);
 */

```
### Java
```java
// https://leetcode.com/submissions/detail/761120641/
class DetectSquares {

    private Integer[][] matrix;

    public DetectSquares() {
        matrix = new Integer[1001][1001];
    }

    public void add(int[] point) {
        if (matrix[point[0]][point[1]] == null) {
            matrix[point[0]][point[1]] = 1;
        } else {
            matrix[point[0]][point[1]] = matrix[point[0]][point[1]] + 1;
        }
    }

    public int count(int[] point) {
        int currentSquareCount = 0;
        int currentPointCount = 1;
        int startRow = point[0];
        int startCol = point[1];
        int curRow = point[0];
        int curCol = point[1];

        while (curRow != 0 && curCol != 0) {
            curRow--;
            curCol--;
            if (
                matrix[curRow][curCol] != null &&
                matrix[startRow][curCol] != null &&
                matrix[curRow][startCol] != null
            ) {
                currentSquareCount =
                    currentSquareCount +
                    (
                        currentPointCount *
                        matrix[curRow][curCol] *
                        matrix[startRow][curCol] *
                        matrix[curRow][startCol]
                    );
            }
        }

        curRow = point[0];
        curCol = point[1];
        while (curRow != 1000 && curCol != 1000) {
            curRow++;
            curCol++;
            if (
                matrix[curRow][curCol] != null &&
                matrix[startRow][curCol] != null &&
                matrix[curRow][startCol] != null
            ) {
                currentSquareCount =
                    currentSquareCount +
                    (
                        currentPointCount *
                        matrix[curRow][curCol] *
                        matrix[startRow][curCol] *
                        matrix[curRow][startCol]
                    );
            }
        }

        curRow = point[0];
        curCol = point[1];
        while (curRow != 0 && curCol != 1000) {
            curRow--;
            curCol++;
            if (
                matrix[curRow][curCol] != null &&
                matrix[startRow][curCol] != null &&
                matrix[curRow][startCol] != null
            ) {
                currentSquareCount =
                    currentSquareCount +
                    (
                        currentPointCount *
                        matrix[curRow][curCol] *
                        matrix[startRow][curCol] *
                        matrix[curRow][startCol]
                    );
            }
        }

        curRow = point[0];
        curCol = point[1];
        while (curRow != 1000 && curCol != 0) {
            curRow++;
            curCol--;
            if (
                matrix[curRow][curCol] != null &&
                matrix[startRow][curCol] != null &&
                matrix[curRow][startCol] != null
            ) {
                currentSquareCount =
                    currentSquareCount +
                    (
                        currentPointCount *
                        matrix[curRow][curCol] *
                        matrix[startRow][curCol] *
                        matrix[curRow][startCol]
                    );
            }
        }

        return currentSquareCount;
    }
}

```


