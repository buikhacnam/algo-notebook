---
title: Permutations II
category: Backtracking
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/permutations-ii)

</Callout>

## Description

Given a collection of numbers, <code>nums</code>, that might contain duplicates, return _all possible unique permutations in any order._

Example 1:

<br />
<pre className="overflow-x-auto">
	Input: nums = [1,1,2] Output: [[1,1,2], [1,2,1], [2,1,1]]
</pre>

Example 2:

<br />
<pre className="overflow-x-auto">
	Input: nums = [1,2,3] Output:
	[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
</pre>

Constraints:

    - <code>1 &lt;= nums.length &lt;= 8</code>
    - <code>-10 &lt;= nums[i] &lt;= 10</code>

## Solution

### Javascript

```javascript
Solution will be updated soon
```

### Python

```python
import collections


class Solution:

    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        result = []
        counter = collections.Counter(nums)

        def backtrack(perm, counter):
            if len(perm) == len(nums):
                result.append(perm.copy())

            for n in counter:
                if counter[n] == 0:
                    continue
                perm.append(n)
                counter[n] -= 1
                backtrack(perm, counter)
                perm.pop()
                counter[n] += 1

        backtrack([], counter)

        return result

```

### C++

```cpp
Solution will be updated soon
```

### Java

```java
class Solution {
    public List<List<Integer>> permuteUnique(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();

        backtrack(res, nums, new ArrayList<>(), new boolean[nums.length]);
        return res;
    }

    public void backtrack(List<List<Integer>> res,
                          int[] nums,
                          List<Integer> path,
                          boolean[] visited) {
        if (path.size() == nums.length) {
            res.add(new ArrayList<>(path));
            return;
        }

        for (int i = 0; i < nums.length; i++) {
            if (visited[i] ||
                    (i > 0 && nums[i - 1] == nums[i] && visited[i - 1]))
                continue;

            visited[i] = true;
            path.add(nums[i]);

            backtrack(res, nums, path, visited);

            visited[i] = false;
            path.remove(path.size() - 1);
        }
    }
}

```
