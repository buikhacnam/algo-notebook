---
title: Partition to K Equal Sum Subsets
category: Backtracking
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/partition-to-k-equal-sum-subsets)

</Callout>

## Description

Given an integer array <code>nums</code> and an integer <code>k</code>, return <code>true</code> if it is possible to divide this array into <code>k</code> non-empty subsets whose sums are all equal.

Example 1:

<br />
<pre className="overflow-x-auto">
	Input: nums = [4,3,2,3,5,2,1], k = 4 Output: true Explanation: It is possible
	to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.
</pre>

Example 2:

<br />
<pre className="overflow-x-auto">
	Input: nums = [1,2,3,4], k = 3 Output: false
</pre>

Constraints:

    - <code>1 &lt;= k &lt;= nums.length &lt;= 16</code>
    - <code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code>
    - The frequency of each element is in the range <code>[1, 4]</code>.

## Solution

### Javascript

```javascript
Solution will be updated soon
```

### Python

```python
class Solution(object):
    def canPartitionKSubsets(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: bool
        """

        if sum(nums) % k != 0:
            return False

        nums.sort(reverse = True)
        target = sum(nums) / k
        visited= set()

        def backtrack(idx, count, currSum):
            if count == k:
                return True

            if target == currSum:
                return backtrack(0, count + 1, 0)

            for i in range(idx, len(nums)):

                # skip duplicates if last same number was skipped
                if i > 0 and (i - 1) not in visited and nums[i] == nums[i - 1]:
                    continue

                if i in visited or currSum + nums[i] > target:
                    continue

                visited.add(i)

                if backtrack(i + 1, count, currSum + nums[i]):
                    return True

                visited.remove(i)

            return False


        return backtrack(0, 0, 0)
```

### C++

```cpp
Solution will be updated soon
```

### Java

```java
class Solution {
    int target;

    public boolean canPartitionKSubsets(int[] nums, int k) {
        int sum = 0;
        for(int n : nums){
            sum += n;
        }
        if(sum%k != 0)
            return false;

        target = sum / k;
        boolean[] used = new boolean[nums.length];
        return backtrack(nums, 0, k, 0, used);
    }

    private boolean backtrack(int[] nums, int i, int k, int subsetSum, boolean[] used){
        if(k == 0)
            return true;
        if(subsetSum == target)
            return backtrack(nums, 0, k-1, 0, used);

        for(int j = i; j < nums.length; j++){
            if(j > 0 && !used[j-1] && nums[j] == nums[j-1])
                continue;
            if(used[j] || subsetSum + nums[j] > target)
                continue;

            used[j] = true;
            if(backtrack(nums, j+1, k, subsetSum + nums[j], used))
                return true;

            used[j] = false;
        }
        return false;
    }
}

```
