---
title: Combination Sum II
category: Backtracking
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/combination-sum-ii)

</Callout>

## Description
Given a collection of candidate numbers (<code>candidates</code>) and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sum to <code>target</code>.

Each number in <code>candidates</code> may only be used once in the combination.

Note: The solution set must not contain duplicate combinations.

 
Example 1:

<br /><pre className="overflow-x-auto">
Input: candidates = [10,1,2,7,6,1,5], target = 8
Output: 
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
</pre>

Example 2:

<br /><pre className="overflow-x-auto">
Input: candidates = [2,5,2,1,2], target = 5
Output: 
[
[1,2,2],
[5]
]
</pre>

 
Constraints:


	- <code>1 &lt;= candidates.length &lt;= 100</code>
	- <code>1 &lt;= candidates[i] &lt;= 50</code>
	- <code>1 &lt;= target &lt;= 30</code>



## Solution

### Javascript
```javascript
/**
 * https://leetcode.com/problems/combination-sum-ii/
 * Time O(2^N) | Space O(N)
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
 var combinationSum2 = function(candidates, target) {
    candidates.sort((a, b) => a - b)

    return dfs(candidates, target)
};

const dfs = (candidates, target, index = 0, combination = [], combinations = []) => {
    const isBaseCase = target < 0;
    if (isBaseCase) return combinations;

    const isTarget = target === 0;
    if (isTarget) {
        if (combination.length) combinations.push(combination.slice());

        return combinations
    }

    for (let i = index; i < candidates.length; i++) {
        const isDuplicate = (index < i) && (candidates[i - 1] === candidates[i]);
        if (isDuplicate) continue;

        backTrack(candidates, target, i, combination, combinations);
    }

    return combinations;
}

const backTrack = (candidates, target, i, combination, combinations) => {
    combination.push(candidates[i])
        dfs(candidates, (target - candidates[i]), (i + 1), combination, combinations)
    combination.pop()
}

```
### Python
```python
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        candidates.sort()

        res = []

        def backtrack(cur, pos, target):
            if target == 0:
                res.append(cur.copy())
                return
            if target <= 0:
                return

            prev = -1
            for i in range(pos, len(candidates)):
                if candidates[i] == prev:
                    continue
                cur.append(candidates[i])
                backtrack(cur, i + 1, target - candidates[i])
                cur.pop()
                prev = candidates[i]

        backtrack([], 0, target)
        return res

```
### C++
```cpp
/*
    Given array & a target, find all unique combos that sum to target, nums can only be used once
    Ex. candidates = [10,1,2,7,6,1,5], target = 8 -> [[1,1,6],[1,2,5],[1,7],[2,6]]

    Backtracking, generate all combo sums, push/pop + index checking to explore new combos

    Time: O(2^n)
    Space: O(n)
*/

class Solution {
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end());
        
        vector<int> curr;
        vector<vector<int>> result;
        
        dfs(candidates, target, 0, 0, curr, result);
        return result;
    }
private:
    void dfs(vector<int>& candidates, int target, int sum, int start, vector<int>& curr, vector<vector<int>>& result) {
        if (sum > target) {
            return;
        }
        if (sum == target) {
            result.push_back(curr);
            return;
        }
        for (int i = start; i < candidates.size(); i++) {
            if (i > start && candidates[i] == candidates[i - 1]) {
                continue;
            }
            curr.push_back(candidates[i]);
            dfs(candidates, target, sum + candidates[i], i + 1, curr, result);
            curr.pop_back();
        }
    }
};

```
### Java
```java
class Solution {

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        List<Integer> ls = new ArrayList<Integer>();
        comb(candidates, target, ans, ls, 0);
        return ans;
    }

    public void comb(
        int[] candidates,
        int target,
        List<List<Integer>> ans,
        List<Integer> ls,
        int index
    ) {
        if (target == 0) {
            ans.add(new ArrayList(ls));
        } else if (target < 0) return; else {
            for (int i = index; i < candidates.length; i++) {
                if (i > index && candidates[i] == candidates[i - 1]) continue;
                ls.add(candidates[i]);
                comb(candidates, target - candidates[i], ans, ls, i + 1);
                ls.remove(ls.get(ls.size() - 1));
            }
        }
    }
}

```


