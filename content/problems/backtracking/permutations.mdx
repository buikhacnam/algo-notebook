---
title: Permutations
category: Backtracking
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/permutations)

</Callout>

## Description
Given an array <code>nums</code> of distinct integers, return *all the possible permutations*. You can return the answer in any order.

 
Example 1:
<br /><pre className="overflow-x-auto">Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
</pre>Example 2:
<br /><pre className="overflow-x-auto">Input: nums = [0,1]
Output: [[0,1],[1,0]]
</pre>Example 3:
<br /><pre className="overflow-x-auto">Input: nums = [1]
Output: [[1]]
</pre>
 
Constraints:


	- <code>1 &lt;= nums.length &lt;= 6</code>
	- <code>-10 &lt;= nums[i] &lt;= 10</code>
	- All the integers of <code>nums</code> are unique.



## Solution

### Javascript
```javascript
/**
 * https://leetcode.com/problems/permutations/solution/
 * Time O(N!) | Space(N!)
 * @param {number[]} nums
 * @return {number[][]}
 */
 var permute = function(nums) {
    return dfs(nums)
}

var dfs = function(nums, permutation = [], permutations = []) {
    const isBaseCase = nums.length === permutation.length
    if (isBaseCase) return permutations.push(permutation.slice())

    for (let i = 0; i < nums.length; i++) {
        if (permutation.includes(nums[i])) continue;

        backTrack(nums, i, permutation, permutations);
     }

    return permutations;
}

const backTrack = (nums, i, permutation, permutations) => {
    permutation.push(nums[i])
        dfs(nums, permutation, permutations)
    permutation.pop()
}

/**
 * https://leetcode.com/problems/permutations/solution/
 * Time O(N!) | Space(N!)
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
    return bfs(nums)
}

const bfs = (nums, levels = [[]], permutations = []) => {
    for (const num of nums) {
        for (let i = (levels.length - 1); 0 <= i; i--) {
            const previousLevel = levels.shift()

            for (let index = 0; index < (previousLevel.length + 1); index++) {
                const level = reArrangeSet(previousLevel, num, index)

                const isBaseCase = level.length === nums.length;
                if (isBaseCase) {
                    permutations.push(level);
                    continue
                }

                levels.push(level)
            }
        }
    }

    return permutations
}

const reArrangeSet = (previousLevel, num, index) => {
    const [ before, after ] = [ previousLevel.slice(0, index), previousLevel.slice(index) ]

    return [...before, num, ...after]
}

```
### Python
```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []

        # base case
        if len(nums) == 1:
            return [nums[:]]  # nums[:] is a deep copy

        for i in range(len(nums)):
            n = nums.pop(0)
            perms = self.permute(nums)

            for perm in perms:
                perm.append(n)
            res.extend(perms)
            nums.append(n)
        return res

```
### C++
```cpp
/*
    Given array of distinct integers, return all the possible permutations
    Ex. nums = [1,2,3] -> [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

    Permute by swapping i/start, DFS from this point, backtrack to undo swap

    Time: O(n x n!)
    Space: O(n!)
*/

class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> result;
        dfs(nums, 0, result);
        return result;
    }
private:
    void dfs(vector<int>& nums, int start, vector<vector<int>>& result) {
        if (start == nums.size()) {
            result.push_back(nums);
            return;
        }
        for (int i = start; i < nums.size(); i++) {
            swap(nums[i], nums[start]);
            dfs(nums, start + 1, result);
            swap(nums[i], nums[start]);
        }
    }
};

```
### Java
```java
import java.util.ArrayList;
import java.util.Arrays;

class Solution {

    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        function(ans, nums, 0);
        return ans;
    }

    public void function(List<List<Integer>> ans, int[] arr, int start) {
        if (start == arr.length) {
            List<Integer> list = new ArrayList();
            for (int i = 0; i < arr.length; i++) list.add(arr[i]);
            ans.add(list);
            return;
        }

        for (int i = start; i < arr.length; i++) {
            swap(arr, start, i);
            function(ans, arr, start + 1);
            swap(arr, start, i);
        }
    }

    public void swap(int[] arr, int a, int b) {
        int temp = arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }
}

```


