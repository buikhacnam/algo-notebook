---
title: Find Peak Element
category: Binary Search
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/find-peak-element)

</Callout>

## Description
A peak element is an element that is strictly greater than its neighbors.

Given a 0-indexed integer array <code>nums</code>, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.

You may imagine that <code>nums[-1] = nums[n] = -&infin;</code>. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.

You must write an algorithm that runs in <code>O(log n)</code> time.

 
Example 1:

<br /><pre className="overflow-x-auto">
Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.</pre>

Example 2:

<br /><pre className="overflow-x-auto">
Input: nums = [1,2,1,3,5,6,4]
Output: 5
Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.</pre>

 
Constraints:


	- <code>1 &lt;= nums.length &lt;= 1000</code>
	- <code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code>
	- <code>nums[i] != nums[i + 1]</code> for all valid <code>i</code>.



## Solution

### Javascript
```javascript
/**
 * Time O(log(N)) | Space O(1)
 * @param {number[]} nums
 * @return {number}
 */
var findPeakElement = function(nums) {
    let [l, r] = [0, nums.length - 1];
    let mid = null;
    while (l <= r){
        mid = (l + r) >> 1;
        if (mid < nums.length - 1 && nums[mid] < nums[mid+1]){
            l = mid + 1;
        }
        else if (mid > 0 && nums[mid] < nums[mid-1]) {
            r = mid - 1;
        } 
        else {
            break;
        }
    }
    return mid;
};

```
### Python
```python
class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        l, r = 0, len(nums) - 1
        while l <= r:
            mid = (r + l) // 2
            if mid < len(nums) - 1 and nums[mid] < nums[mid+1]:
                l = mid + 1
            elif mid > 0 and nums[mid] < nums[mid-1]:
                r = mid - 1
            else:
                break
        return mid
        

```
### C++
```cpp
// Time: O(logN)
// Space: O(1)

class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int n = nums.size();

        if(n == 1) return 0;

        int left = 0, right = n - 1;
        while(left <= right) {
            int mid = left + (right-left)/2;

            if(mid > 0 && nums[mid] < nums[mid-1]) {
                right = mid - 1;
            }
            else if(mid < n-1 && nums[mid] < nums[mid+1]) {
                left = mid + 1;
            }
            else {
                return mid;
            }
        }
        return -1;
    }
};

```
### Java
```java
404: Not Found
```


