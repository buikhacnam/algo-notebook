---
title: Split Array Largest Sum
category: Binary Search
difficulty: Hard
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/split-array-largest-sum)

</Callout>

## Description
Given an integer array <code>nums</code> and an integer <code>k</code>, split <code>nums</code> into <code>k</code> non-empty subarrays such that the largest sum of any subarray is minimized.

Return *the minimized largest sum of the split*.

A subarray is a contiguous part of the array.

 
Example 1:

<br /><pre className="overflow-x-auto">
Input: nums = [7,2,5,10,8], k = 2
Output: 18
Explanation: There are four ways to split nums into two subarrays.
The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.
</pre>

Example 2:

<br /><pre className="overflow-x-auto">
Input: nums = [1,2,3,4,5], k = 2
Output: 9
Explanation: There are four ways to split nums into two subarrays.
The best way is to split it into [1,2,3] and [4,5], where the largest sum among the two subarrays is only 9.
</pre>

 
Constraints:


	- <code>1 &lt;= nums.length &lt;= 1000</code>
	- <code>0 &lt;= nums[i] &lt;= 10<sup>6</sup></code>
	- <code>1 &lt;= k &lt;= min(50, nums.length)</code>



## Solution

### Javascript
```javascript
/**
 * https://leetcode.com/problems/split-array-largest-sum/
 * 
 * Binary Search
 * Time O(log(s)*n) (s = difference between the least and max possible value) | Space O(1)
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var splitArray = function(nums, k) {
    
    let left = Math.max(...nums);
    let right = nums.reduce((acc, num) => acc + num, 0);
    let result = right;
    while(left <= right) {
        const mid = (left + right) >> 1;
        if(canSplit(mid)) {
            result = mid;
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }

    function canSplit(largest) {
        let splitCount = 0;
        let currSum = 0;

        for(let i = 0; i < nums.length; i++) {
            currSum += nums[i];
            if(currSum > largest) {
                currSum = nums[i];
                splitCount++;
            }
        }

        return splitCount + 1 <= k;
    }

    return result;
};

```
### Python
```python
class Solution:
    def splitArray(self, nums: List[int], m: int) -> int:
        def canSplit(largest):
            subarray = 0
            curSum = 0
            for n in nums:
                curSum += n
                if curSum > largest:
                    subarray += 1
                    curSum = n
            return subarray + 1 <= m

        l, r = max(nums), sum(nums)
        res = r
        while l <= r:
            mid = l + ((r - l) // 2)
            if canSplit(mid):
                res = mid
                r = mid - 1
            else:
                l = mid + 1
        return res

```
### C++
```cpp
404: Not Found
```
### Java
```java
404: Not Found
```


