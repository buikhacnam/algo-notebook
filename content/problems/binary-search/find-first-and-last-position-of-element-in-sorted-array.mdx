---
title: Find First and Last Position of Element in Sorted Array
category: Binary Search
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array)

</Callout>

## Description

Given an array of integers <code>nums</code> sorted in non-decreasing order, find the starting and ending position of a given <code>target</code> value.

If <code>target</code> is not found in the array, return <code>[-1, -1]</code>.

You must write an algorithm with <code>O(log n)</code> runtime complexity.

Example 1:

<br />
<pre className="overflow-x-auto">
	Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4]
</pre>

Example 2:

<br />
<pre className="overflow-x-auto">
	Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1]
</pre>

Example 3:

<br />
<pre className="overflow-x-auto">
	Input: nums = [], target = 0 Output: [-1,-1]
</pre>
Constraints:

    - <code>0 &lt;= nums.length &lt;= 10<sup>5</sup></code>
    - <code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code>
    - <code>nums</code> is a non-decreasing array.
    - <code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code>

## Solution

### Javascript

```javascript
/**
 * Binary Search
 * https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/
 * Time O(log(n)) | Space O(1)
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var searchRange = function (nums, target) {
	const result = []

	result.push(binarySearch(true, nums, target))
	result.push(binarySearch(false, nums, target))

	return result
}

var binarySearch = (isLeftBias, nums, target) => {
	let left = 0
	let right = nums.length - 1
	let index = -1

	while (left <= right) {
		const mid = (left + right) >> 1

		if (target > nums[mid]) {
			left = mid + 1
		}
		if (target < nums[mid]) {
			right = mid - 1
		}

		const isTarget = target === nums[mid]
		if (isTarget) {
			if (isLeftBias) {
				index = mid
				right = mid - 1
			} else {
				index = mid
				left = mid + 1
			}
		}
	}
	return index
}
```

### Python

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        left = self.binSearch(nums, target, True)
        right = self.binSearch(nums, target, False)
        return [left, right]

    # leftBias=[True/False], if false, res is rightBiased
    def binSearch(self, nums, target, leftBias):
        l, r = 0, len(nums) - 1
        i = -1
        while l <= r:
            m = (l + r) // 2
            if target > nums[m]:
                l = m + 1
            elif target < nums[m]:
                r = m - 1
            else:
                i = m
                if leftBias:
                    r = m - 1
                else:
                    l = m + 1
        return i

```

### C++

```cpp
/*
    Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.
    Ex. nums = [5,7,7,8,8,10], target = 8 -> [3, 4] (start position is 3, end position is 4)

    Use binary search, firstly binary search left endpoint, then binary search right endpoint.

    Time: O(log n)
    Space: O(1)
*/

class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        if (nums.empty()) return {-1, -1};
        int l = 0, r = nums.size() - 1;
        while (l < r) {
            int mid = l + r >> 1;
            if (nums[mid] >= target) r = mid;
            else l = mid + 1;
        }
        if (nums[l] != target) return {-1, -1};
        int left = l;

        l = 0, r = nums.size() - 1;
        while (l < r) {
            int mid = l + r + 1ll >> 1;
            if (nums[mid] <= target) l = mid;
            else r = mid - 1;
        }
        return {left, r};
    }
};
```

### Java

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        int[] result = {-1, -1};

        while (left <= right) {
            int mid = left  + ((right - left) / 2);

            if (nums[mid] == target) {
                result = findEdges(mid, nums, target);
                break;
            }

            else if (target < nums[mid]) {
                right = mid - 1;
            }

            else if (target > nums[mid]) {
                left = mid + 1;
            }
        }

        return result;
    }

    public int[] findEdges(int mid, int[] nums, int target) {
        int left = mid;
        int right = mid;
        int[] result = {left, right};

        while (left >= 0 && nums[left] == target) {
            result[0] = left;
            left --;
        }

        while (right <= nums.length - 1 && nums[right] == target) {
            result[1] = right;
            right ++;
        }

        return result;
    }
}
```
