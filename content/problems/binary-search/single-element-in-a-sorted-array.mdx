---
title: Single Element in a Sorted Array
category: Binary Search
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/single-element-in-a-sorted-array)

</Callout>

## Description
You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.

Return *the single element that appears only once*.

Your solution must run in <code>O(log n)</code> time and <code>O(1)</code> space.

 
Example 1:
<br /><pre className="overflow-x-auto">Input: nums = [1,1,2,3,3,4,4,8,8]
Output: 2
</pre>Example 2:
<br /><pre className="overflow-x-auto">Input: nums = [3,3,7,7,10,11,11]
Output: 10
</pre>
 
Constraints:


	- <code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code>
	- <code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code>



## Solution

### Javascript
```javascript
// Time Complexity: O(log n)
// Space Complexity: O(1)

/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNonDuplicate = function (nums) {
    let left = 0,
        right = nums.length - 2;

    while (left <= right) {
        const mid1 = (left + right) >> 1;
        const mid2 = mid1 ^ 1;

        if (nums[mid1] === nums[mid2]) left = mid1 + 1;
        else right = mid1 - 1;
    }

    return nums[left];
};

```
### Python
```python
class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        def is_non_duplicate(i):
            is_left_different = i == 0 or nums[i-1] != nums[i]
            is_right_different = i == len(nums)-1 or nums[i+1] != nums[i]
            return is_left_different and is_right_different

        if len(nums) == 1:
            return nums[0]

        l, r = 0, len(nums) - 1
        while l <= r:
            mid = (l + r) // 2
            if is_non_duplicate(mid):
                return nums[mid]

            if mid % 2 == 0:
                if nums[mid+1] == nums[mid]:
                    l = mid + 1
                else:
                    r = mid - 1
            else:
                if nums[mid+1] == nums[mid]:
                    r = mid - 1
                else:
                    l = mid + 1
  

```
### C++
```cpp
// Time complexity: O(log n)
// Space complexity: O(1)

class Solution
{
public:
    int singleNonDuplicate(vector<int> &nums)
    {
        int left = 0, right = nums.size() - 2;

        while (left <= right)
        {
            int mid1 = (left + right) >> 1;
            int mid2 = mid1 ^ 1;
            if (nums[mid1] == nums[mid2])
            {
                left = mid1 + 1;
            }
            else
            {
                right = mid1 - 1;
            }
        }

        return nums[left];
    }
};
```
### Java
```java
404: Not Found
```


