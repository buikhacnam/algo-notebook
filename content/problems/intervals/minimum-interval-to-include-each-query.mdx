---
title: Minimum Interval to Include Each Query
category: Intervals
difficulty: Hard
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/minimum-interval-to-include-each-query)

</Callout>

## Description
You are given a 2D integer array <code>intervals</code>, where <code>intervals[i] = [left<sub>i</sub>, right<sub>i</sub>]</code> describes the <code>i<sup>th</sup></code> interval starting at <code>left<sub>i</sub></code> and ending at <code>right<sub>i</sub></code> (inclusive). The size of an interval is defined as the number of integers it contains, or more formally <code>right<sub>i</sub> - left<sub>i</sub> + 1</code>.

You are also given an integer array <code>queries</code>. The answer to the <code>j<sup>th</sup></code> query is the size of the smallest interval <code>i</code> such that <code>left<sub>i</sub> &lt;= queries[j] &lt;= right<sub>i</sub></code>. If no such interval exists, the answer is <code>-1</code>.

Return *an array containing the answers to the queries*.

 
Example 1:

<br /><pre className="overflow-x-auto">
Input: intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]
Output: [3,3,1,4]
Explanation: The queries are processed as follows:
- Query = 2: The interval [2,4] is the smallest interval containing 2. The answer is 4 - 2 + 1 = 3.
- Query = 3: The interval [2,4] is the smallest interval containing 3. The answer is 4 - 2 + 1 = 3.
- Query = 4: The interval [4,4] is the smallest interval containing 4. The answer is 4 - 4 + 1 = 1.
- Query = 5: The interval [3,6] is the smallest interval containing 5. The answer is 6 - 3 + 1 = 4.
</pre>

Example 2:

<br /><pre className="overflow-x-auto">
Input: intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22]
Output: [2,-1,4,6]
Explanation: The queries are processed as follows:
- Query = 2: The interval [2,3] is the smallest interval containing 2. The answer is 3 - 2 + 1 = 2.
- Query = 19: None of the intervals contain 19. The answer is -1.
- Query = 5: The interval [2,5] is the smallest interval containing 5. The answer is 5 - 2 + 1 = 4.
- Query = 22: The interval [20,25] is the smallest interval containing 22. The answer is 25 - 20 + 1 = 6.
</pre>

 
Constraints:


	- <code>1 &lt;= intervals.length &lt;= 10<sup>5</sup></code>
	- <code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code>
	- <code>intervals[i].length == 2</code>
	- <code>1 &lt;= left<sub>i</sub> &lt;= right<sub>i</sub> &lt;= 10<sup>7</sup></code>
	- <code>1 &lt;= queries[j] &lt;= 10<sup>7</sup></code>



## Solution

### Javascript
```javascript
/**
 * @param {number[][]} intervals
 * @param {number[]} queries
 * @return {number[]}
 */
var minInterval = function(intervals, queries) {
  intervals.sort((a, b) => a[0] - b[0]);
  const queriesSorted = [ ...queries ].sort((a, b) => a - b);
  const minHeap = new MinPriorityQueue();
  const output = {};
  let i = 0;

  for (const query of queriesSorted) {
    while (i < intervals.length && intervals[i][0] <= query) {
      const [ start, end ] = intervals[i];
      const length = end - start + 1;
      // Use length as the priority in the heap.
      minHeap.enqueue([ length, end ], length);
      i++;
    }

    while (!minHeap.isEmpty() && minHeap.front().element[1] < query) {
      minHeap.dequeue();
    }

    output[query] = (!minHeap.isEmpty()) ? minHeap.front().element[0] : -1;
  }

  return queries.map((query) => output[query]);
};

```
### Python
```python
class Solution:
    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:
        intervals.sort()
        minHeap = []
        res = {}
        i = 0
        for q in sorted(queries):
            while i < len(intervals) and intervals[i][0] <= q:
                l, r = intervals[i]
                heapq.heappush(minHeap, (r - l + 1, r))
                i += 1

            while minHeap and minHeap[0][1] < q:
                heapq.heappop(minHeap)
            res[q] = minHeap[0][0] if minHeap else -1
        return [res[q] for q in queries]

```
### C++
```cpp
/*
    Given intervals array & queries array, ans to a query is min interval containing it
    Ex. intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5] -> [3,3,1,4]

    Min heap & sort by size of intervals, top will be min size, 

    Time: O(n log n + q log q) -> n = number of intervals, q = number of queries
    Space: O(n + q)
*/

class Solution {
public:
    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {
        vector<int> sortedQueries = queries;
        
        // [size of interval, end of interval]
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        // {query -> size of interval}
        unordered_map<int, int> m;
        
        // also need only valid intervals so sort by start time & sort queries
        sort(intervals.begin(), intervals.end());
        sort(sortedQueries.begin(), sortedQueries.end());
        
        vector<int> result;
        
        int i = 0;
        for (int j = 0; j < sortedQueries.size(); j++) {
            int query = sortedQueries[j];
            
            while (i < intervals.size() && intervals[i][0] <= query) {
                int left = intervals[i][0];
                int right = intervals[i][1];
                pq.push({right - left + 1, right});
                i++;
            }
            
            while (!pq.empty() && pq.top().second < query) {
                pq.pop();
            }
            
            if (!pq.empty()) {
                m[query] = pq.top().first;
            } else {
                m[query] = -1;
            }
        }
        
        for (int j = 0; j < queries.size(); j++) {
            result.push_back(m[queries[j]]);
        }
        return result;
    }
};

```
### Java
```java
class Query {

    int index;
    int queryTimeStamp;
    int result;

    public Query(int index, int queryTimeStamp) {
        this.index = index;
        this.queryTimeStamp = queryTimeStamp;
        this.result = -1; // initially store as -1
    }

    @Override
    public String toString() {
        return "[" + index + "," + queryTimeStamp + "," + result + "]";
    }

    public void setResult(int result) {
        this.result = result;
    }
}

class IntervalComparator implements Comparator<int[]> {

    public static int getSize(int[] interval) {
        return (interval[1] - interval[0] + 1);
    }

    @Override
    public int compare(int[] o1, int[] o2) {
        int o1Size = getSize(o1), o2Size = getSize(o2);
        if (o1Size != o2Size) {
            return (o1Size - o2Size);
        }
        return (o1[1] - o2[1]);
    }
}

class Solution {

    public int[] minInterval(int[][] intervals, int[] queries) {
        // book-keeping & sorting
        int numIntervals = intervals.length;
        int numQueries = queries.length;

        // Sort by start times
        Arrays.sort(intervals, (o1, o2) -> (o1[0] - o2[0]));

        Query[] sortedQueries = new Query[numQueries];
        for (int i = 0; i < numQueries; i++) sortedQueries[i] =
            new Query(i, queries[i]);

        Arrays.sort(
            sortedQueries,
            (q1, q2) -> (q1.queryTimeStamp - q2.queryTimeStamp)
        );

        // algorithm

        Comparator<int[]> comparator = new IntervalComparator();
        PriorityQueue<int[]> pq = new PriorityQueue<>(comparator);
        int idx = 0;

        for (Query query : sortedQueries) {
            // 1. Keep taking all those queries which have lower starting time than the query time and add them to priority queue
            while (
                (idx < numIntervals) &&
                (query.queryTimeStamp >= intervals[idx][0])
            ) {
                pq.add(intervals[idx]);
                idx++;
            }

            // 2. Keep removing the inconsistent intervals and get the min size interval from priority queue
            while (!pq.isEmpty() && (pq.peek()[1] < query.queryTimeStamp)) {
                pq.remove();
            }

            // Now, priority queue must have the consistent & smallest interval
            int ans = pq.isEmpty() ? -1 : IntervalComparator.getSize(pq.peek());
            query.setResult(ans);
        }

        // reconversion
        int[] results = new int[numQueries];
        for (Query query : sortedQueries) {
            results[query.index] = query.result;
        }

        return results;
    }
}

```


