---
title: Generate Parentheses
category: Stack
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/generate-parentheses)

</Callout>

## Description

Given <code>n</code> pairs of parentheses, write a function to _generate all combinations of well-formed parentheses_.

Example 1:

<br />
<pre className="overflow-x-auto">
	Input: n = 3 Output: ["((()))","(()())","(())()","()(())","()()()"]
</pre>

Example 2:

<br />
<pre className="overflow-x-auto">Input: n = 1 Output: ["()"]</pre>
Constraints:

    - <code>1 &lt;= n &lt;= 8</code>

## Solution

### Javascript

```javascript
/**
 * DFS
 * Time O(((4^N) / (N * SQRT(N)))) | Space O(((4^N) / (N * SQRT(N))))
 * Time O(2^N) | Space O(2^N)
 * https://leetcode.com/problems/generate-parentheses
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = (n) => dfs(n)

const dfs = (n, combos = [], open = 0, close = 0, path = []) => {
	const isBaseCase = path.length === n * 2
	if (isBaseCase) {
		combos.push(path.join('')) /* Space O(N + N) */

		return combos
	}

	const isOpen = open < n
	if (isOpen)
		backTrackOpen(n, combos, open, close, path) /* Time O(2^N) | Space O(2^N) */

	const isClose = close < open
	if (isClose)
		backTrackClose(
			n,
			combos,
			open,
			close,
			path,
		) /* Time O(2^N) | Space O(2^N) */

	return combos
}

const backTrackOpen = (n, combos, open, close, path) => {
	path.push('(') /* Space O(N) */
	dfs(n, combos, open + 1, close, path) /* Time O(2^N) | Space O(2^N) */
	path.pop()
}

const backTrackClose = (n, combos, open, close, path) => {
	path.push(')') /* Space O(N) */
	dfs(n, combos, open, close + 1, path) /* Time O(2^N) | Space O(2^N) */
	path.pop()
}

/**
 * BFS
 * Time O(((4^N) / (N * SQRT(N)))) | Space O(((4^N) / (N * SQRT(N))))
 * Time O(2^N) | Space O(2^N)
 * https://leetcode.com/problems/generate-parentheses
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = (n) => bfs(n)

const bfs = (n, combos = []) => {
	const queue = new Queue([['', 0, 0]])

	while (!queue.isEmpty()) {
		/* Time O(2^N) */
		const [str, open, close] = queue.dequeue()

		const isBaseCase = open === n && close === n
		if (isBaseCase) {
			combos.push(str) /* Space O(N) */

			continue
		}

		const isOpen = open < n
		if (isOpen) queue.enqueue([`${str}(`, open + 1, close]) /* Space O(2^N) */

		const isClose = close < open
		if (isClose) queue.enqueue([`${str})`, open, close + 1]) /* Space O(2^N) */
	}

	return combos
}

/**
 * DFS
 * Time O(((4^N) / (N * SQRT(N)))) | Space O(((4^N) / (N * SQRT(N))))
 * Time O(2^N) | Space O(2^N)
 * https://leetcode.com/problems/generate-parentheses
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = (n, combos = []) => {
	const isBaseCase = n === 0
	if (isBaseCase) {
		combos.push('')

		return combos
	}

	for (let c = 0; c < n; c++) {
		for (const left of generateParenthesis(c)) {
			for (const right of generateParenthesis(n - 1 - c)) {
				combos.push(`(${left})${right}`)
			}
		}
	}

	return combos
}
```

### Python

```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        stack = []
        res = []

        def backtrack(openN, closedN):
            if openN == closedN == n:
                res.append("".join(stack))
                return

            if openN < n:
                stack.append("(")
                backtrack(openN + 1, closedN)
                stack.pop()
            if closedN < openN:
                stack.append(")")
                backtrack(openN, closedN + 1)
                stack.pop()

        backtrack(0, 0)
        return res

```

### C++

```cpp
/*
    Given n pairs of parentheses, generate all combos of well-formed parentheses
    Ex. n = 3 -> ["((()))","(()())","(())()","()(())","()()()"], n = 1 -> ["()"]

    Backtracking, keep valid, favor trying opens, then try closes if still valid

    Time: O(2^n)
    Space: O(n)
*/

class Solution {
public:
    vector<string> generateParenthesis(int n) {
        vector<string> result;
        generate(n, 0, 0, "", result);
        return result;
    }
private:
    void generate(int n, int open, int close, string str, vector<string>& result) {
        if (open == n && close == n) {
            result.push_back(str);
            return;
        }
        if (open < n) {
            generate(n, open + 1, close, str + '(', result);
        }
        if (open > close) {
            generate(n, open, close + 1, str + ')', result);
        }
    }
};

```

### Java

```java
package arrays;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Stack;

public class Solution {

    public static void main(String[] args) {
        Solution sol = new Solution();
        sol.generateParenthesis(3);
    }

    Stack<Character> stack = new Stack<>();
    List<String> res = new ArrayList<>();

    public List<String> generateParenthesis(int n) {
        backtrack(0, 0, n);
        return res;
    }

    private void backtrack(int openN, int closedN, int n) {
        if (openN == closedN && closedN == n) {
            Iterator vale = stack.iterator();
            String temp = "";
            while (vale.hasNext()) {
                temp = temp + vale.next();
            }
            res.add(temp);
        }
        if (openN < n) {
            stack.push('(');
            backtrack(openN + 1, closedN, n);
            stack.pop();
        }
        if (closedN < openN) {
            stack.push(')');
            backtrack(openN, closedN + 1, n);
            stack.pop();
        }
    }
}

```
