---
title: Evaluate Reverse Polish Notation
category: Stack
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/evaluate-reverse-polish-notation)

</Callout>

## Description

You are given an array of strings <code>tokens</code> that represents an arithmetic expression in a <a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation" target="_blank">Reverse Polish Notation</a>.

Evaluate the expression. Return _an integer that represents the value of the expression_.

Note that:

    - The valid operators are <code>&#39;+&#39;</code>, <code>&#39;-&#39;</code>, <code>&#39;*&#39;</code>, and <code>&#39;/&#39;</code>.
    - Each operand may be an integer or another expression.
    - The division between two integers always truncates toward zero.
    - There will not be any division by zero.
    - The input represents a valid arithmetic expression in a reverse polish notation.
    - The answer and all the intermediate calculations can be represented in a 32-bit integer.

Example 1:

<br />

<pre className="overflow-x-auto">
	Input: tokens =
	[&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]
	Output: 9 Explanation: ((2 + 1) * 3) = 9
</pre>

Example 2:

<br />

<pre className="overflow-x-auto">
	Input: tokens =
	[&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]
	Output: 6 Explanation: (4 + (13 / 5)) = 6
</pre>

Example 3:

<br />

<pre className="overflow-x-auto">
	Input: tokens =
	[&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]
	Output: 22 Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 /
	(12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 =
	(0 + 17) + 5 = 17 + 5 = 22
</pre>

Constraints:

    - <code>1 &lt;= tokens.length &lt;= 10<sup>4</sup></code>
    - <code>tokens[i]</code> is either an operator: <code>&quot;+&quot;</code>, <code>&quot;-&quot;</code>, <code>&quot;*&quot;</code>, or <code>&quot;/&quot;</code>, or an integer in the range <code>[-200, 200]</code>.

## Solution

### Javascript

```javascript
/**
 * https://leetcode.com/problems/evaluate-reverse-polish-notation
 * Time O(N^2) | Space(1)
 * @param {string[]} tokens
 * @return {number}
 */
var evalRPN = function (tokens, index = 0) {
	while (1 < tokens.length) {
		/* Time O(N) */
		const isOperation = () => tokens[index] in OPERATORS
		while (!isOperation()) index++ /* Time O(N) */

		const value = performOperation(tokens, index)

		tokens[index] = value
		tokens.splice(index - 2, 2) /* Time O(N) */
		index--
	}

	return tokens[0]
}

var OPERATORS = {
	'+': (a, b) => a + b,
	'-': (a, b) => a - b,
	'*': (a, b) => a * b,
	'/': (a, b) => Math.trunc(a / b),
}

var performOperation = (tokens, index) => {
	const [rightNum, leftNum] = [
		Number(tokens[index - 1]),
		Number(tokens[index - 2]),
	]
	const operation = OPERATORS[tokens[index]]

	return operation(leftNum, rightNum)
}

/**
 * https://leetcode.com/problems/evaluate-reverse-polish-notation
 * Time O(N) | Space(N)
 * @param {string[]} tokens
 * @return {number}
 */
var evalRPN = function (tokens, stack = []) {
	for (const char of tokens) {
		/* Time O(N) */
		const isOperation = char in OPERATORS
		if (isOperation) {
			const value = performOperation(char, stack)

			stack.push(value) /* Space O(N) */

			continue
		}

		stack.push(Number(char)) /* Space O(N) */
	}

	return stack.pop()
}

var OPERATORS = {
	'+': (a, b) => a + b,
	'-': (a, b) => a - b,
	'*': (a, b) => a * b,
	'/': (a, b) => Math.trunc(a / b),
}

var performOperation = (char, stack) => {
	const [rightNum, leftNum] = [stack.pop(), stack.pop()]
	const operation = OPERATORS[char]

	return operation(leftNum, rightNum)
}
```

### Python

```python
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        stack = []
        for c in tokens:
            if c == "+":
                stack.append(stack.pop() + stack.pop())
            elif c == "-":
                a, b = stack.pop(), stack.pop()
                stack.append(b - a)
            elif c == "*":
                stack.append(stack.pop() * stack.pop())
            elif c == "/":
                a, b = stack.pop(), stack.pop()
                stack.append(int(float(b) / a))
            else:
                stack.append(int(c))
        return stack[0]

```

### C++

```cpp
/*
    Evaluate RPN, valid operators: +, -, *, /

    Stack, if num push, if operator apply to top 2 nums

    Time: O(n)
    Space: O(n)
*/

class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> stk;

        for (int i = 0; i < tokens.size(); i++) {
            string token = tokens[i];

            if (token.size() > 1 || isdigit(token[0])) {
                stk.push(stoi(token));
                continue;
            }

            int num2 = stk.top();
            stk.pop();
            int num1 = stk.top();
            stk.pop();

            int result = 0;
            if (token == "+") {
                result = num1 + num2;
            } else if (token == "-") {
                result = num1 - num2;
            } else if (token == "*") {
                result = num1 * num2;
            } else {
                result = num1 / num2;
            }
            stk.push(result);
        }

        return stk.top();
    }
};

```

### Java

```java
class Solution {

    public int evalRPN(String[] tokens) {
        Stack<Integer> stack = new Stack<>();
        for (String token : tokens) {
            if (token.equals("+")) {
                stack.add(stack.pop() + stack.pop());
            } else if (token.equals("-")) {
                int a = stack.pop();
                int b = stack.pop();
                stack.add(b - a);
            } else if (token.equals("*")) {
                stack.add(stack.pop() * stack.pop());
            } else if (token.equals("/")) {
                int a = stack.pop();
                int b = stack.pop();
                stack.add(b / a);
            } else {
                stack.add(Integer.parseInt(token));
            }
        }
        return stack.pop();
    }
}

```
