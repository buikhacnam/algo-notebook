---
title: 132 Pattern
category: Stack
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/132-pattern)

</Callout>

## Description
Given an array of <code>n</code> integers <code>nums</code>, a 132 pattern is a subsequence of three integers <code>nums[i]</code>, <code>nums[j]</code> and <code>nums[k]</code> such that <code>i &lt; j &lt; k</code> and <code>nums[i] &lt; nums[k] &lt; nums[j]</code>.

Return <code>true</code>* if there is a 132 pattern in *<code>nums</code>*, otherwise, return *<code>false</code>*.*

 
Example 1:

<br /><pre className="overflow-x-auto">
Input: nums = [1,2,3,4]
Output: false
Explanation: There is no 132 pattern in the sequence.
</pre>

Example 2:

<br /><pre className="overflow-x-auto">
Input: nums = [3,1,4,2]
Output: true
Explanation: There is a 132 pattern in the sequence: [1, 4, 2].
</pre>

Example 3:

<br /><pre className="overflow-x-auto">
Input: nums = [-1,3,2,0]
Output: true
Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].
</pre>

 
Constraints:


	- <code>n == nums.length</code>
	- <code>1 &lt;= n &lt;= 2 * 10<sup>5</sup></code>
	- <code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code>



## Solution

### Javascript
```javascript
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var find132pattern = function (nums) {
    let stack = []; // [num, minLeft]
    let curMin = nums[0];

    for (n of nums.slice(1)) {
        while (stack.length > 0 && n >= stack.at(-1)[0]) {
            stack.pop();
        }
        if (stack.length > 0 && n > stack.at(-1)[1]) {
            return true;
        }

        stack.push([n, curMin]);
        curMin = Math.min(curMin, n);
    }

    return false;
};

```
### Python
```python
class Solution:
    def find132pattern(self, nums: List[int]) -> bool:
        stack = [] # pair [num, curLeftMin], mono-decreasing stack
        curMin = nums[0]

        for n in nums:
            while stack and n >= stack[-1][0]:
                stack.pop()
            if stack and n < stack[-1][0] and n > stack[-1][1]:
                return True

            stack.append([n, curMin]) 
            curMin = min(n, curMin)

        return False

```
### C++
```cpp
404: Not Found
```
### Java
```java
class Solution {
    /*
     * Mono Stack
     * TC: O(n)
     * SC: O(n)
     */
    public boolean find132pattern(int[] nums) {
        int n = nums.length;
        Stack<Integer> st = new Stack<>();
        int secondMax = Integer.MIN_VALUE;

        for (int x = n - 1; x >= 0; x--) {
            if (nums[x] < secondMax)
                return true;

            while (!st.isEmpty() && st.peek() < nums[x])
                secondMax = Math.max(st.pop(), secondMax);

            st.push(nums[x]);
        }
        return false;
    }
}

```


