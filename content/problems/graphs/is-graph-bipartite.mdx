---
title: Is Graph Bipartite?
category: Graphs
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/is-graph-bipartite)

</Callout>

## Description

There is an undirected graph with <code>n</code> nodes, where each node is numbered between <code>0</code> and <code>n - 1</code>. You are given a 2D array <code>graph</code>, where <code>graph[u]</code> is an array of nodes that node <code>u</code> is adjacent to. More formally, for each <code>v</code> in <code>graph[u]</code>, there is an undirected edge between node <code>u</code> and node <code>v</code>. The graph has the following properties:

    - There are no self-edges (<code>graph[u]</code> does not contain <code>u</code>).
    - There are no parallel edges (<code>graph[u]</code> does not contain duplicate values).
    - If <code>v</code> is in <code>graph[u]</code>, then <code>u</code> is in <code>graph[v]</code> (the graph is undirected).
    - The graph may not be connected, meaning there may be two nodes <code>u</code> and <code>v</code> such that there is no path between them.

A graph is bipartite if the nodes can be partitioned into two independent sets <code>A</code> and <code>B</code> such that every edge in the graph connects a node in set <code>A</code> and a node in set <code>B</code>.

Return <code>true</code>_ if and only if it is bipartite_.

Example 1:

<Image
	alt=""
	src="https://assets.leetcode.com/uploads/2020/10/21/bi2.jpg"
	width={222}
	height={222}
/>
<br />
<pre className="overflow-x-auto">
	Input: graph = [[1,2,3],[0,2],[0,1,3],[0,2]] Output: false Explanation: There
	is no way to partition the nodes into two independent sets such that every
	edge connects a node in one and a node in the other.
</pre>

Example 2:

<Image
	alt=""
	src="https://assets.leetcode.com/uploads/2020/10/21/bi1.jpg"
	width={222}
	height={222}
/>
<br />
<pre className="overflow-x-auto">
	Input: graph = [[1,3],[0,2],[1,3],[0,2]] Output: true Explanation: We can
	partition the nodes into two sets: {(0, 2)} and {(1, 3)}.
</pre>

Constraints:

    - <code>graph.length == n</code>
    - <code>1 &lt;= n &lt;= 100</code>
    - <code>0 &lt;= graph[u].length &lt; n</code>
    - <code>0 &lt;= graph[u][i] &lt;= n - 1</code>
    - <code>graph[u]</code> does not contain <code>u</code>.
    - All the values of <code>graph[u]</code> are unique.
    - If <code>graph[u]</code> contains <code>v</code>, then <code>graph[v]</code> contains <code>u</code>.

## Solution

### Javascript

```javascript
Solution will be updated soon
```

### Python

```python
Solution will be updated soon
```

### C++

```cpp
Solution will be updated soon
```

### Java

```java
class Solution {
    public boolean isBipartite(int[][] graph) {
        int[] color = new int[graph.length]; // 1 for one color , -1 for second color and 0 for not visited.

        for(int i = 0; i < graph.length; i++){
            if(color[i] != 0){
                continue;
            }

            Queue<Integer> q = new LinkedList<>();
            q.add(i);
            color[i] = 1;

            while(!q.isEmpty()){
                int curr = q.poll();

                for(int n : graph[curr]){
                    if(color[n] == 0){
                        color[n] = -1 * color[curr];
                        q.add(n);
                    }
                    if(color[n] == color[curr])
                        return false;
                }
            }
        }
        return true;
    }
}

```
