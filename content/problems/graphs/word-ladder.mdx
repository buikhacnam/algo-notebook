---
title: Word Ladder
category: Graphs
difficulty: Hard
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/word-ladder)

</Callout>

## Description

A transformation sequence from word <code>beginWord</code> to word <code>endWord</code> using a dictionary <code>wordList</code> is a sequence of words <code>beginWord -&gt; s<sub>1</sub> -&gt; s<sub>2</sub> -&gt; ... -&gt; s<sub>k</sub></code> such that:

    - Every adjacent pair of words differs by a single letter.
    - Every <code>s<sub>i</sub></code> for <code>1 &lt;= i &lt;= k</code> is in <code>wordList</code>. Note that <code>beginWord</code> does not need to be in <code>wordList</code>.
    - <code>s<sub>k</sub> == endWord</code>

Given two words, <code>beginWord</code> and <code>endWord</code>, and a dictionary <code>wordList</code>, return _the number of words in the shortest transformation sequence from_ <code>beginWord</code> _to_ <code>endWord</code>_, or _<code>0</code>_ if no such sequence exists._

Example 1:

<br />

<pre className="overflow-x-auto">
	Input: beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList =
	[&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]
	Output: 5 Explanation: One shortest transformation sequence is &quot;hit&quot;
	-&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt;
	cog&quot;, which is 5 words long.
</pre>

Example 2:

<br />

<pre className="overflow-x-auto">
	Input: beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList =
	[&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]
	Output: 0 Explanation: The endWord &quot;cog&quot; is not in wordList,
	therefore there is no valid transformation sequence.
</pre>

Constraints:

    - <code>1 &lt;= beginWord.length &lt;= 10</code>
    - <code>endWord.length == beginWord.length</code>
    - <code>1 &lt;= wordList.length &lt;= 5000</code>
    - <code>wordList[i].length == beginWord.length</code>
    - <code>beginWord</code>, <code>endWord</code>, and <code>wordList[i]</code> consist of lowercase English letters.
    - <code>beginWord != endWord</code>
    - All the words in <code>wordList</code> are unique.

## Solution

### Javascript

```javascript
/**
 * https://leetcode.com/problems/word-ladder/
 * Time O(ROWS * COLS) | Space O(ROWS * COLS)
 * @param {string} beginWord
 * @param {string} endWord
 * @param {string[]} wordList
 * @return {number}
 */
var ladderLength = function (beginWord, endWord, wordList) {
	const [queue, wordSet, seen] = [
		new Queue([[beginWord, 1]]),
		new Set(wordList),
		new Set([beginWord]),
	]

	return bfs(
		queue,
		wordSet,
		seen,
		endWord,
	) /* Time O(ROWS * COLS) | Space O(ROWS * COLS) */
}

const bfs = (queue, wordSet, seen, endWord) => {
	while (!queue.isEmpty()) {
		for (let i = queue.size() - 1; 0 <= i; i--) {
			const [word, depth] = queue.dequeue()

			const isTarget = word === endWord
			if (isTarget) return depth

			transform(queue, wordSet, seen, word, depth)
		}
	}

	return 0
}

const transform = (queue, wordSet, seen, word, depth) => {
	for (const index in word) {
		for (const char of 'abcdefghijklmnopqrstuvwxyz') {
			const neighbor = getNeighbor(word, index, char)

			const hasSeen = !wordSet.has(neighbor) || seen.has(neighbor)
			if (hasSeen) continue

			queue.enqueue([neighbor, depth + 1])
			seen.add(neighbor)
		}
	}
}

const getNeighbor = (word, index, char) => {
	const neighbor = word.split('')

	neighbor[index] = char

	return neighbor.join('')
}
```

### Python

```python
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        if endWord not in wordList:
            return 0

        nei = collections.defaultdict(list)
        wordList.append(beginWord)
        for word in wordList:
            for j in range(len(word)):
                pattern = word[:j] + "*" + word[j + 1 :]
                nei[pattern].append(word)

        visit = set([beginWord])
        q = deque([beginWord])
        res = 1
        while q:
            for i in range(len(q)):
                word = q.popleft()
                if word == endWord:
                    return res
                for j in range(len(word)):
                    pattern = word[:j] + "*" + word[j + 1 :]
                    for neiWord in nei[pattern]:
                        if neiWord not in visit:
                            visit.add(neiWord)
                            q.append(neiWord)
            res += 1
        return 0

```

### C++

```cpp
/*
    Given 2 words & a dictionary, return min # of words to transform b/w them
    Ex. begin = "hit", end = "cog", dict = ["hot","dot","dog","lot","log","cog"] -> 5
    "hit" -> "hot" -> "dot" -> "dog" -> "cog"

    BFS, change 1 letter at a time (neighbors), if in dict add to queue, else skip

    Time: O(m^2 x n) -> m = length of each word, n = # of words in input word list
    Space: O(m^2 x n)
*/

class Solution {
public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        unordered_set<string> dict;
        for (int i = 0; i < wordList.size(); i++) {
            dict.insert(wordList[i]);
        }

        queue<string> q;
        q.push(beginWord);

        int result = 1;

        while (!q.empty()) {
            int count = q.size();

            for (int i = 0; i < count; i++) {
                string word = q.front();
                q.pop();

                if (word == endWord) {
                    return result;
                }
                dict.erase(word);

                for (int j = 0; j < word.size(); j++) {
                    char c = word[j];
                    for (int k = 0; k < 26; k++) {
                        word[j] = k + 'a';
                        if (dict.find(word) != dict.end()) {
                            q.push(word);
                            dict.erase(word);
                        }
                        word[j] = c;
                    }
                }
            }

            result++;
        }

        return 0;
    }
};

```

### Java

```java
package java;

class Solution {

    public int ladderLength(
        String beginWord,
        String endWord,
        List<String> wordList
    ) {
        Map<String, List<String>> adjlist = new HashMap<>();
        wordList.add(beginWord);
        for (String word : wordList) {
            StringBuilder string = null;
            for (int i = 0; i < word.length(); i++) {
                string = new StringBuilder(word);
                string.setCharAt(i, '*');
                List<String> wordlist = adjlist.getOrDefault(
                    string.toString(),
                    new ArrayList<String>()
                );
                wordlist.add(word);
                adjlist.put(string.toString(), wordlist);
            }
        }

        Queue<String> queue = new LinkedList<>();
        queue.offer(beginWord);
        Set<String> visited = new HashSet<>();
        visited.add(beginWord);
        int step = 1;
        StringBuilder string = null;
        while (!queue.isEmpty()) {
            step++;
            int size = queue.size();
            for (int j = 0; j < size; j++) {
                String str = queue.poll();

                for (int i = 0; i < str.length(); i++) {
                    string = new StringBuilder(str);
                    string.setCharAt(i, '*');
                    for (String pat : adjlist.get(string.toString())) {
                        if (pat.equals(endWord)) {
                            return step;
                        }
                        if (visited.contains(pat)) {
                            continue;
                        }
                        queue.offer(pat);
                        visited.add(pat);
                    }
                }
            }
            // step++;
        }
        return 0;
    }
}

```
