---
title: Walls and Gates
category: Graphs
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/walls-and-gates)

</Callout>

## Description
This problem is on Premium plan or is not available

## Solution

### Javascript
```javascript
/**
 * https://leetcode.com/problems/walls-and-gates/
 * Time O(ROWS * COLS) | Space O(ROWS * COLS)
 * @param {number[][]} rooms
 * @return {void} Do not return anything, modify rooms in-place instead.
 */
var wallsAndGates = function(rooms) {
    const [ rows, cols ] = [ rooms.length, rooms[0].length ];

    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            const isGate = rooms[row][col] === 0;
            if (!isGate) continue;

            dfs(rooms, row, col);
        }
    }
}

const dfs = (rooms, row, col) => {
    const [ rows, cols ] = [ rooms.length, rooms[0].length ];

    for (const [ _row, _col ] of getNeighbors(row, rows, col, cols)) {
        const isPreviousDistanceGreater = rooms[_row][_col] <= (rooms[row][col] + 1);
        if (isPreviousDistanceGreater) continue;

        rooms[_row][_col] = (rooms[row][col] + 1);

        dfs(rooms, _row, _col);
    }
}

var getNeighbors = (row, rows, col, cols) => [ [ 0, 1 ],[ 0, -1 ], [ 1, 0 ], [ -1, 0 ] ]
    .map(([ _row, _col ]) => [ (row + _row), (col + _col) ])
    .filter(([ _row, _col ]) => (0 <= _row) && (0 <= _col) && (_row < rows) && (_col < cols));

/**
 * https://leetcode.com/problems/walls-and-gates/
 * Time O(ROWS * COLS) | Space O(ROWS * COLS)
 * @param {number[][]} rooms
 * @return {void} Do not return anything, modify rooms in-place instead.
 */
var wallsAndGates = function(rooms) {
    const queue = searchGrid(rooms);

    bfs(rooms, queue);
};

const searchGrid = (rooms, queue = new Queue([])) => {
    const [ rows, cols ] = [ rooms.length, rooms[0].length ];

    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            const isGate = rooms[row][col] === 0;
            if (!isGate) continue;

            queue.enqueue([ row, col ]);
        }
    }

    return queue;
}

const bfs = (rooms, queue) => {
    while (!queue.isEmpty()) {
        for (let i = (queue.size() - 1); 0 <= i; i--) {
            checkNeighbors(rooms, queue);
        }
    }
}

const checkNeighbors = (rooms, queue) => {
    const [ rows, cols ] = [ rooms.length, rooms[0].length ];
    const [ row, col ] = queue.dequeue();

    for (const [ _row, _col ] of getNeighbors(row, rows, col, cols)) {
        const isINF = rooms[_row][_col] === 2147483647; /* (2 ** 31) - 1 */
        if (!isINF) continue;

        rooms[_row][_col] = (rooms[row][col] + 1);
        queue.enqueue([ _row, _col ]);
    }
}

var getNeighbors = (row, rows, col, cols) => [ [ 0, 1 ],[ 0, -1 ], [ 1, 0 ], [ -1, 0 ] ]
    .map(([ _row, _col ]) => [ (row + _row), (col + _col) ])
    .filter(([ _row, _col ]) => (0 <= _row) && (0 <= _col) && (_row < rows) && (_col < cols));

```
### Python
```python
class Solution:
    """
    @param rooms: m x n 2D grid
    @return: nothing
    """

    def walls_and_gates(self, rooms: List[List[int]]):
        ROWS, COLS = len(rooms), len(rooms[0])
        visit = set()
        q = deque()

        def addRooms(r, c):
            if (
                min(r, c) < 0
                or r == ROWS
                or c == COLS
                or (r, c) in visit
                or rooms[r][c] == -1
            ):
                return
            visit.add((r, c))
            q.append([r, c])

        for r in range(ROWS):
            for c in range(COLS):
                if rooms[r][c] == 0:
                    q.append([r, c])
                    visit.add((r, c))

        dist = 0
        while q:
            for i in range(len(q)):
                r, c = q.popleft()
                rooms[r][c] = dist
                addRooms(r + 1, c)
                addRooms(r - 1, c)
                addRooms(r, c + 1)
                addRooms(r, c - 1)
            dist += 1

```
### C++
```cpp
/*
    Given grid: -1 wall, 0 gate, INF empty, fill each empty w/ dist to nearest gate

    BFS traversal, shortest path from each gate to all empty rooms
    Each gate only looks at within 1 space, then next gate, guarantees shortest

    Time: O(m x n)
    Space: O(m x n)
*/

class Solution {
public:
    void wallsAndGates(vector<vector<int>>& rooms) {
        int m = rooms.size();
        int n = rooms[0].size();
        
        queue<pair<int, int>> q;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (rooms[i][j] == 0) {
                    q.push({i, j});
                }
            }
        }
        
        while (!q.empty()) {
            int row = q.front().first;
            int col = q.front().second;
            q.pop();
            
            for (int i = 0; i < 4; i++) {
                int x = row + dirs[i][0];
                int y = col + dirs[i][1];
                
                if (x < 0 || x >= m || y < 0 || y >= n || rooms[x][y] != INT_MAX) {
                    continue;
                }
                
                rooms[x][y] = rooms[row][col] + 1;
                q.push({x, y});
            }
        }
    }
private:
    vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
};

```
### Java
```java
//Same as rotting oranges
//Time complexity will be O(N^2) since we are basically traversing every value in the grid.

class Solution {

    public void wallsAndGates(int[][] rooms) {
        Queue<int[]> q = new LinkedList<>();
        int m = rooms.length;
        int n = rooms[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (rooms[i][j] == 0) q.add(new int[] { i, j });
            }
        }
        if (q.size() == 0) return;
        int[][] dirs = { { -1, 0 }, { 0, -1 }, { 1, 0 }, { 0, 1 } };
        int dis = 0;
        while (!q.isEmpty()) {
            ++dis;
            int[] cur = q.poll();
            int row = cur[0];
            int col = cur[1];
            for (int[] dir : dirs) {
                int x = row + dir[0];
                int y = col + dir[1];
                if (
                    x >= m ||
                    y >= n ||
                    x < 0 ||
                    y < 0 ||
                    rooms[x][y] != Integer.MAX_VALUE
                ) continue;
                q.add(new int[] { x, y });
                //since cur is basically the index of door (which is equal to 0)
                //So, we can just grab that value (rooms[row][col]) and add 1 to it and change it every time
                rooms[x][y] = rooms[row][col] + 1;
                //So, one level further from door (value 0) is equal to 1. Now, we do bfs from that position so value will be 2 and so on.
            }
        }
    }
}

```


