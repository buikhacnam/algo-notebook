---
title: Reorder Routes to Make All Paths Lead to the City Zero
category: Graphs
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero)

</Callout>

## Description
There are <code>n</code> cities numbered from <code>0</code> to <code>n - 1</code> and <code>n - 1</code> roads such that there is only one way to travel between two different cities (this network form a tree). Last year, The ministry of transport decided to orient the roads in one direction because they are too narrow.

Roads are represented by <code>connections</code> where <code>connections[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> represents a road from city <code>a<sub>i</sub></code> to city <code>b<sub>i</sub></code>.

This year, there will be a big event in the capital (city <code>0</code>), and many people want to travel to this city.

Your task consists of reorienting some roads such that each city can visit the city <code>0</code>. Return the minimum number of edges changed.

It&#39;s guaranteed that each city can reach city <code>0</code> after reorder.

 
Example 1:
<Image alt="" src="https://assets.leetcode.com/uploads/2020/05/13/sample_1_1819.png" width={311} height={189} />
<br /><pre className="overflow-x-auto">
Input: n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]]
Output: 3
Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).
</pre>

Example 2:
<Image alt="" src="https://assets.leetcode.com/uploads/2020/05/13/sample_2_1819.png" width={509} height={79} />
<br /><pre className="overflow-x-auto">
Input: n = 5, connections = [[1,0],[1,2],[3,2],[3,4]]
Output: 2
Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).
</pre>

Example 3:

<br /><pre className="overflow-x-auto">
Input: n = 3, connections = [[1,0],[2,0]]
Output: 0
</pre>

 
Constraints:


	- <code>2 &lt;= n &lt;= 5 * 10<sup>4</sup></code>
	- <code>connections.length == n - 1</code>
	- <code>connections[i].length == 2</code>
	- <code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code>
	- <code>a<sub>i</sub> != b<sub>i</sub></code>



## Solution

### Javascript
```javascript
404: Not Found
```
### Python
```python
404: Not Found
```
### C++
```cpp
class Solution {
public:
    int minReorder(int n, vector<vector<int>>& connections) {
        unordered_map<int, vector<pair<int, bool>>> graph;
        unordered_set<int> visited;

        for (int i = 0; i < n; i++)
            graph[i] = vector<pair<int, bool>>{};

        for (vector<int> connection : connections) {
            graph[connection[0]].push_back(make_pair(connection[1], true));
            graph[connection[1]].push_back(make_pair(connection[0], false));
        }

        int cnt = 0;
        stack<int> stk;
        stk.push(0);
        visited.insert(0);

        while (!stk.empty()) {
            int u = stk.top();
            stk.pop();
            for (pair<int, bool> v : graph[u]) {
                if (visited.count(v.first))
                    continue;
                stk.push(v.first);
                visited.insert(v.first);
                if (v.second)
                    cnt += 1;
            }
        }

        return cnt;
    }
};


```
### Java
```java
class Solution {
    int res = 0;
    HashMap<Integer, List<Integer>> graph = new HashMap<>();
    HashSet<String> oldEdges = new HashSet<>();

    public int minReorder(int n, int[][] connections) {
        HashSet<Integer> visited = new HashSet<>();
        for (int[] edges : connections){
            int a = edges[0], b = edges[1];
            String s = a + "->" + b;
            oldEdges.add(s);
            graph.computeIfAbsent(a, val -> new ArrayList<>()).add(b);
            graph.computeIfAbsent(b, val -> new ArrayList<>()).add(a);
        }
        dfs(0, -1, visited);
        return res-1;
    }

    private void dfs(int curr, int parent, HashSet<Integer> visited) {
        if (visited.contains(curr))
            return;
        visited.add(curr);
        String s = curr + "->" + parent;
        if (!oldEdges.contains(s))
            res++;
        for (int child : graph.get(curr)){
            dfs(child, curr, visited);
        }
    }
}

```


