---
title: Count Sub Islands
category: Graphs
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/count-sub-islands)

</Callout>

## Description

You are given two <code>m x n</code> binary matrices <code>grid1</code> and <code>grid2</code> containing only <code>0</code>&#39;s (representing water) and <code>1</code>&#39;s (representing land). An island is a group of <code>1</code>&#39;s connected 4-directionally (horizontal or vertical). Any cells outside of the grid are considered water cells.

An island in <code>grid2</code> is considered a sub-island if there is an island in <code>grid1</code> that contains all the cells that make up this island in <code>grid2</code>.

Return the _number of islands in _<code>grid2</code> _that are considered sub-islands_.

Example 1:

<Image
	alt=""
	src="https://assets.leetcode.com/uploads/2021/06/10/test1.png"
	width={493}
	height={205}
/>
<br />

<pre className="overflow-x-auto">
	Input: grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]],
	grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]] Output:
	3 Explanation: In the picture above, the grid on the left is grid1 and the
	grid on the right is grid2. The 1s colored red in grid2 are those considered
	to be part of a sub-island. There are three sub-islands.
</pre>

Example 2:

<Image
	alt=""
	src="https://assets.leetcode.com/uploads/2021/06/03/testcasex2.png"
	width={491}
	height={201}
/>
<br />

<pre className="overflow-x-auto">
	Input: grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]],
	grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]] Output:
	2 Explanation: In the picture above, the grid on the left is grid1 and the
	grid on the right is grid2. The 1s colored red in grid2 are those considered
	to be part of a sub-island. There are two sub-islands.
</pre>

Constraints:

    - <code>m == grid1.length == grid2.length</code>
    - <code>n == grid1[i].length == grid2[i].length</code>
    - <code>1 &lt;= m, n &lt;= 500</code>
    - <code>grid1[i][j]</code> and <code>grid2[i][j]</code> are either <code>0</code> or <code>1</code>.

## Solution

### Javascript

```javascript
var countSubIslands = function (grid1, grid2) {
	let ROWS = grid1.length,
		COLS = grid1[0].length
	let visit = new Set()

	const dfs = function (r, c) {
		let flatCoord = r * COLS + c
		if (
			r < 0 ||
			c < 0 ||
			r == ROWS ||
			c == COLS ||
			grid2[r][c] == 0 ||
			visit.has(flatCoord)
		)
			return true

		visit.add(flatCoord)
		let res = true
		if (grid1[r][c] == 0) res = false

		res = dfs(r - 1, c) && res
		res = dfs(r + 1, c) && res
		res = dfs(r, c - 1) && res
		res = dfs(r, c + 1) && res
		return res
	}

	let count = 0
	for (let r = 0; r < ROWS; r++)
		for (let c = 0; c < COLS; c++)
			if (grid2[r][c] && !visit.has(r * COLS + c) && dfs(r, c)) count += 1
	return count
}
```

### Python

```python
class Solution:
    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:
        ROWS, COLS = len(grid1), len(grid1[0])
        visit = set()

        def dfs(r, c):
            if (
                r < 0
                or c < 0
                or r == ROWS
                or c == COLS
                or grid2[r][c] == 0
                or (r, c) in visit
            ):
                return True

            visit.add((r, c))
            res = True
            if grid1[r][c] == 0:
                res = False

            res = dfs(r - 1, c) and res
            res = dfs(r + 1, c) and res
            res = dfs(r, c - 1) and res
            res = dfs(r, c + 1) and res
            return res

        count = 0
        for r in range(ROWS):
            for c in range(COLS):
                if grid2[r][c] and (r, c) not in visit and dfs(r, c):
                    count += 1
        return count

```

### C++

```cpp
class Solution {
public:
    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {
        const int ROWS = grid1.size(), COLS = grid1[0].size();
        set<int> visit;

        function<bool(int, int)> dfs = [&] (int r, int c) -> bool {
            if (
                r < 0
                || c < 0
                || r == ROWS
                || c == COLS
                || grid2[r][c] == 0
                || visit.count(r*COLS + c)
            )
                return true;

            visit.insert(r*COLS + c);
            bool res = true;
            if(grid1[r][c] == 0)
                res = false;

            res = dfs(r - 1, c) && res;
            res = dfs(r + 1, c) && res;
            res = dfs(r, c - 1) && res;
            res = dfs(r, c + 1) && res;
            return res;
        };

        int count = 0;
        for(int r = 0; r < ROWS; r++)
            for(int c = 0; c < COLS; c++)
                if(grid2[r][c] && !visit.count(r*COLS + c) && dfs(r, c))
                    count += 1;
        return count;
    }
};

```

### Java

```java
class Solution {
    class RecursiveBiFunction<A, B, C> {
        BiFunction<A, B, C> func;
    }

    public int countSubIslands(final int[][] grid1, final int[][] grid2) {
        final int ROWS = grid1.length, COLS = grid1[0].length;
        final Set<Integer> visit = new HashSet<>();

        final RecursiveBiFunction<Integer, Integer, Boolean> dfs = new RecursiveBiFunction<>();
        dfs.func = (r, c) -> {
            int flatCoord = r*COLS + c;
            if(
                r < 0
                || c < 0
                || r == ROWS
                || c == COLS
                || grid2[r][c] == 0
                || visit.contains(flatCoord)
            )
                return true;

            visit.add(flatCoord);
            boolean res = true;
            if(grid1[r][c] == 0)
                res = false;

            res = dfs.func.apply(r - 1, c) && res;
            res = dfs.func.apply(r + 1, c) && res;
            res = dfs.func.apply(r, c - 1) && res;
            res = dfs.func.apply(r, c + 1) && res;
            return res;
        };

        int count = 0;
        for(int r = 0; r < ROWS; r++)
            for(int c = 0; c < COLS; c++)
                if(grid2[r][c] != 0 && !visit.contains(r*COLS + c) && dfs.func.apply(r, c))
                    count += 1;
        return count;
    }
}

```
