---
title: Verifying an Alien Dictionary
category: Graphs
difficulty: Easy
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/verifying-an-alien-dictionary)

</Callout>

## Description
In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different <code>order</code>. The <code>order</code> of the alphabet is some permutation of lowercase letters.

Given a sequence of <code>words</code> written in the alien language, and the <code>order</code> of the alphabet, return <code>true</code> if and only if the given <code>words</code> are sorted lexicographically in this alien language.

 
Example 1:

<br /><pre className="overflow-x-auto">
Input: words = [&quot;hello&quot;,&quot;leetcode&quot;], order = &quot;hlabcdefgijkmnopqrstuvwxyz&quot;
Output: true
Explanation: As &#39;h&#39; comes before &#39;l&#39; in this language, then the sequence is sorted.
</pre>

Example 2:

<br /><pre className="overflow-x-auto">
Input: words = [&quot;word&quot;,&quot;world&quot;,&quot;row&quot;], order = &quot;worldabcefghijkmnpqstuvxyz&quot;
Output: false
Explanation: As &#39;d&#39; comes after &#39;l&#39; in this language, then words[0] &gt; words[1], hence the sequence is unsorted.
</pre>

Example 3:

<br /><pre className="overflow-x-auto">
Input: words = [&quot;apple&quot;,&quot;app&quot;], order = &quot;abcdefghijklmnopqrstuvwxyz&quot;
Output: false
Explanation: The first three characters &quot;app&quot; match, and the second string is shorter (in size.) According to lexicographical rules &quot;apple&quot; &gt; &quot;app&quot;, because &#39;l&#39; &gt; &#39;&empty;&#39;, where &#39;&empty;&#39; is defined as the blank character which is less than any other character (<a href="https://en.wikipedia.org/wiki/Lexicographical_order" target="_blank">More info</a>).
</pre>

 
Constraints:


	- <code>1 &lt;= words.length &lt;= 100</code>
	- <code>1 &lt;= words[i].length &lt;= 20</code>
	- <code>order.length == 26</code>
	- All characters in <code>words[i]</code> and <code>order</code> are English lowercase letters.



## Solution

### Javascript
```javascript
var isAlienSorted = function(words, order) {
    // first differing char
    // if word A is prefix of word B, word B must be AFTER word A
    orderInd = new Map(); {
        let ind = 0;
        for(const c of order)
            orderInd.set(c, ind++);
    }
    
    for(let i = 0; i < words.length - 1; i++) {
        let w1 = words[i], w2 = words[i + 1];
        
        for(let j = 0; j < w1.length; j++) {
            if(j == w2.length)
                return false;
            
            if(w1.charAt(j) != w2.charAt(j))
                if(orderInd.get(w2.charAt(j)) < orderInd.get(w1.charAt(j)))
                    return false;
                else
                    break;
        }
    }
    return true;
};

```
### Python
```python
class Solution:
    def isAlienSorted(self, words: List[str], order: str) -> bool:
        # first differing char
        # if word A is prefix of word B, word B must be AFTER word A
        orderInd = { c : i for i, c in enumerate(order)}
        
        for i in range(len(words) - 1):
            w1, w2 = words[i], words[i + 1]
            
            for j in range(len(w1)):
                if j == len(w2):
                    return False
                
                if w1[j] != w2[j]:
                    if orderInd[w2[j]] < orderInd[w1[j]]:
                        return False
                    break
        return True

```
### C++
```cpp
/*
    Given list of words in another language, return string such that:
    Letters are sorted in lexicographical incr order wrt this language
    Ex. words = ["wrt","wrf","er","ett","rftt"]

    Build graph + record edges, BFS + topological sort, check cyclic

    Time: O(n)
    Space: O(n)
*/

class Solution {
public:
    string alienOrder(vector<string> &words) {
        
        unordered_map<char, unordered_set<char>> graph;
        unordered_map<char, int> indegree;

        // indegree make all char 0
        for(auto word : words){
            for(auto c : word){
                indegree[c]=0;
            }
        }

        for(int i=0; i<words.size()-1; i++){
            string curr = words[i];
            string next = words[i+1];
            
            bool flag = false;
            int len = min(curr.length(), next.length());
            for(int j=0; j<len; j++){
                char ch1 = curr[j];
                char ch2 = next[j];

                if(ch1 != ch2){
                    unordered_set<char> set;

                    if(graph.find(ch1) != graph.end()){
                        set = graph[ch1];

                        if(set.find(ch2) == set.end()){
                            set.insert(ch2);
                            indegree[ch2]++;
                            graph[ch1] = set;
                        }
                    }
                    else{
                        set.insert(ch2);
                        indegree[ch2]++;
                        graph[ch1] = set;
                    }

                    flag = true;
                    break;
                }
                
            }

            if(flag == false and (curr.length() > next.length())) return "";
        }

        priority_queue<char, vector<char>, greater<char>> q;

        for(auto it : indegree){
            if(it.second == 0){
                //cout<<it.first<<endl;
                q.push(it.first);
            }
        }

        int count=0;
        string ans = "";

        while(q.size()>0){
            auto rem = q.top();
            q.pop();

            ans += rem;
            count++;

            if(graph.find(rem) != graph.end()){
                unordered_set<char> nbrs = graph[rem];

                for(auto nbr : nbrs){
                    indegree[nbr]--;
                    if(indegree[nbr] == 0){
                        q.push(nbr);
                    }
                }
            }
        }

        if(count == indegree.size()){
            return ans;
        }
        return "";
    }
};

```
### Java
```java
class Solution {
    public boolean isAlienSorted(String[] words, String order) {
        Map<Character, Integer> orderInd = new HashMap<>(); {
            int ind = 0;
            for(char c: order.toCharArray())
                orderInd.put(c, ind++);
        }
        
        for(int i = 0; i < words.length - 1; i++) {
            String w1 = words[i], w2 = words[i + 1];
            
            for(int j = 0; j < w1.length(); j++)
                if(j == w2.length())
                    return false;
                else if(w1.charAt(j) != w2.charAt(j))
                    if(orderInd.get(w2.charAt(j)) < orderInd.get(w1.charAt(j)))
                        return false;
                    else
                        break;
        }
        
        return true;
    }
}

```


