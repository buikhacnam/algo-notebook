---
title: Surrounded Regions
category: Graphs
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/surrounded-regions)

</Callout>

## Description
Given an <code>m x n</code> matrix <code>board</code> containing <code>&#39;X&#39;</code> and <code>&#39;O&#39;</code>, *capture all regions that are 4-directionally surrounded by* <code>&#39;X&#39;</code>.

A region is captured by flipping all <code>&#39;O&#39;</code>s into <code>&#39;X&#39;</code>s in that surrounded region.

 
Example 1:
<Image alt="" src="https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg" width={550} height={237} />
<br /><pre className="overflow-x-auto">
Input: board = [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]
Output: [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]
Explanation: Notice that an &#39;O&#39; should not be flipped if:
- It is on the border, or
- It is adjacent to an &#39;O&#39; that should not be flipped.
The bottom &#39;O&#39; is on the border, so it is not flipped.
The other three &#39;O&#39; form a surrounded region, so they are flipped.
</pre>

Example 2:

<br /><pre className="overflow-x-auto">
Input: board = [[&quot;X&quot;]]
Output: [[&quot;X&quot;]]
</pre>

 
Constraints:


	- <code>m == board.length</code>
	- <code>n == board[i].length</code>
	- <code>1 &lt;= m, n &lt;= 200</code>
	- <code>board[i][j]</code> is <code>&#39;X&#39;</code> or <code>&#39;O&#39;</code>.



## Solution

### Javascript
```javascript
/**
 * https://leetcode.com/problems/surrounded-regions/
 * Time O(ROWS * COLS) | Space O(ROWS * COLS)
 * @param {character[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
 var solve = function solve(board) {
    searchRows(board);/* Time O(ROWS * COLS) | Space O(ROWS * COLS) */
    searchCols(board);/* Time O(ROWS * COLS) | Space O(ROWS * COLS) */
    searchGrid(board);/* Time O(ROWS * COLS) | Space O(ROWS * COLS) */
}

var searchRows = (board) => {
    const [ rows, cols ] = [ board.length, board[0].length ];

    for (let row = 0; row < rows; row++) {      /* Time O(ROWS) */
        dfs(board, row, rows, 0, cols);         /* Space O(ROWS) */
        dfs(board, row, rows, (cols - 1), cols);/* Space O(ROWS) */
    }
}

var searchCols = (board) => {
    const [ rows, cols ] = [ board.length, board[0].length ];

    for (let col = 1; col < (cols - 1); col++) {/* Time O(COLS) */
        dfs(board, 0, rows, col, cols);         /* Space O(COLS) */
        dfs(board, (rows - 1), rows, col, cols);/* Space O(COLS) */
    }
}

var searchGrid = (board) => {
    const [ rows, cols ] = [ board.length, board[0].length ];

    for (let row = 0; row < rows; row++) {/* Time O(ROWS) */
        for (let col = 0; col < cols; col++) {/* Time O(COLS) */
            const isO = board[row][col] === 'O';
            if (isO) board[row][col] = 'X';

            const isStar = board[row][col] === '*';
            if (isStar) board[row][col] = 'O';
        }
    }
}

const dfs = (board, row, rows, col, cols) => {
    const isBaseCase = board[row][col] !== 'O';
    if (isBaseCase) return;

    board[row][col] = '*';

    for (const [ _row, _col ] of getNeighbors(row, rows, col, cols)) {
        dfs(board, _row, rows, _col, cols);/* Time O(HEIGHT) | Space O(HEIGHT) */
    }
}

var getNeighbors = (row, rows, col, cols) => [ [0, 1], [0, -1], [1, 0], [-1, 0] ]
    .map(([ _row, _col ]) => [ (row + _row), (col + _col)])
    .filter(([ _row, _col ]) => (0 <= _row) && (_row < rows) && (0 <= _col) && (_col < cols))


/**
 * https://leetcode.com/problems/surrounded-regions/
 * Time O(ROWS * COLS) | Space O(ROWS * COLS)
 * @param {character[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
 var solve = function solve(board, queue = new Queue([])) {
    searchRows(board, queue);/* Time O(ROWS + COLS) | Space O(ROWS + COLS) */
    searchCols(board, queue);/* Time O(ROWS + COLS) | Space O(ROWS + COLS) */
    bfs(board, queue);       /* Time O(ROWS * COLS) | Space O(ROWS * COLS) */
    searchGrid(board);       /* Time O(ROWS * COLS) */
}

var searchRows = (board, queue) => {
    const [ rows, cols ] = [ board.length, board[0].length ]

    for (let row = 0; row < rows; row++) { /* Time O(ROWS) */
        queue.enqueue([ row, 0 ]);         /* Space O(ROWS) */
        queue.enqueue([ row, (cols - 1) ]);/* Space O(ROWS) */
    }
}

var searchCols = (board, queue) => {
    const [ rows, cols ] = [ board.length, board[0].length ]

    for (let col = 0; col < (cols - 1); col++) {/* Time O(COLS) */
        queue.enqueue([ 0, col ]);              /* Space O(COLS) */
        queue.enqueue([ (rows - 1), col ]);     /* Space O(COLS) */
    }
}

var bfs = (board, queue) => {
    const [ rows, cols ] = [ board.length, board[0].length ];

    while (!queue.isEmpty()) {
        for (let i = (queue.size() - 1); 0 <= i; i--) {/* Time O(WIDTH) */
            const [ row, col ] = queue.dequeue();

            const isBaseCase = board[row][col] !== 'O';
            if (isBaseCase) continue;

            board[row][col] = '*';

            for (const [ _row, _col ] of getNeighbors(row, rows, col, cols)) {
                queue.enqueue([ _row, _col ]);         /* Space O(WIDTH) */
            }
        }
    } 
}

var searchGrid = (board) => {
    const [ rows, cols ] = [ board.length, board[0].length ];

    for (let row = 0; row < rows; row++) {/* Time O(ROWS) */
        for (let col = 0; col < cols; col++) {/* Time O(COLS) */
            const isO = board[row][col] === 'O';
            if (isO) board[row][col] = 'X';

            const isStar = board[row][col] === '*';
            if (isStar) board[row][col] = 'O';
        }
    }
}
```
### Python
```python
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        ROWS, COLS = len(board), len(board[0])

        def capture(r, c):
            if r < 0 or c < 0 or r == ROWS or c == COLS or board[r][c] != "O":
                return
            board[r][c] = "T"
            capture(r + 1, c)
            capture(r - 1, c)
            capture(r, c + 1)
            capture(r, c - 1)

        # 1. (DFS) Capture unsurrounded regions (O -> T)
        for r in range(ROWS):
            for c in range(COLS):
                if board[r][c] == "O" and (r in [0, ROWS - 1] or c in [0, COLS - 1]):
                    capture(r, c)

        # 2. Capture surrounded regions (O -> X)
        for r in range(ROWS):
            for c in range(COLS):
                if board[r][c] == "O":
                    board[r][c] = "X"

        # 3. Uncapture unsurrounded regions (T -> O)
        for r in range(ROWS):
            for c in range(COLS):
                if board[r][c] == "T":
                    board[r][c] = "O"

```
### C++
```cpp
/*
    Given a matrix, capture ('X') all regions that are surrounded ('O')

    Distinguish captured vs escaped, 'X' vs 'O' vs 'E'

    Time: O(m x n)
    Space: O(m x n)
*/

class Solution {
public:
    void solve(vector<vector<char>>& board) {
        int m = board.size();
        int n = board[0].size();
        
        // marking escaped cells along the border
        for (int i = 0; i < m; i++) {
            dfs(board,i,0,m,n);
            dfs(board,i,n-1,m,n);
        }
        
        for (int j = 0; j < n; j++) {
            dfs(board,0,j,m,n);
            dfs(board,m-1,j,m,n);
        }
        
        // flip cells to correct final states
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (board[i][j] == 'O') {
                    board[i][j] = 'X';
                }
                if (board[i][j] == 'E') {
                    board[i][j] = 'O';
                }
            }
        }
    }
private:
    void dfs(vector<vector<char>>& board, int i, int j, int m, int n) {
        if (i < 0 || i >= m || j < 0 || j >= n || board[i][j] != 'O') {
            return;
        }
        
        board[i][j] = 'E';
        
        dfs(board, i - 1, j, m, n);
        dfs(board, i + 1, j, m, n);
        dfs(board, i, j - 1, m, n);
        dfs(board, i, j + 1, m, n);
    }
};

```
### Java
```java
class Solution {

    public void solve(char[][] board) {
        int nRows = board.length;
        int nCols = board[0].length;

        // 1a) Capture unsurrounded regions - top and bottom row (O -> T)
        for (int i = 0; i < nCols; i++) {
            if (board[0][i] == 'O') dfs(board, 0, i);
            if (board[nRows - 1][i] == 'O') dfs(board, nRows - 1, i);
        }

        // 1b) Capture unsurrounded regions - Left and right columns (O -> T)
        for (int i = 0; i < nRows; i++) {
            if (board[i][0] == 'O') dfs(board, i, 0);
            if (board[i][nCols - 1] == 'O') dfs(board, i, nCols - 1);
        }

        for (int r = 0; r < nRows; r++) {
            for (int c = 0; c < nCols; c++) {
                if (board[r][c] == 'O') board[r][c] = 'X'; // 2) Capture surrounded regions (O -> X)
                if (board[r][c] == 'T') board[r][c] = 'O'; // 3) Uncapture unsurrounded regions (T- O)
            }
        }
    }

    private void dfs(char[][] board, int r, int c) {
        int nRows = board.length;
        int nCols = board[0].length;
        if (
            r < 0 || c < 0 || r >= nRows || c >= nCols || board[r][c] != 'O'
        ) return;

        board[r][c] = 'T';
        dfs(board, r + 1, c);
        dfs(board, r - 1, c);
        dfs(board, r, c + 1);
        dfs(board, r, c - 1);
    }
}

```


