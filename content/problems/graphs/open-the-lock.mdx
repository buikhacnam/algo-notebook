---
title: Open the Lock
category: Graphs
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/open-the-lock)

</Callout>

## Description
You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: <code>&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;</code>. The wheels can rotate freely and wrap around: for example we can turn <code>&#39;9&#39;</code> to be <code>&#39;0&#39;</code>, or <code>&#39;0&#39;</code> to be <code>&#39;9&#39;</code>. Each move consists of turning one wheel one slot.

The lock initially starts at <code>&#39;0000&#39;</code>, a string representing the state of the 4 wheels.

You are given a list of <code>deadends</code> dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.

Given a <code>target</code> representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.

 
Example 1:

<br /><pre className="overflow-x-auto">
Input: deadends = [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target = &quot;0202&quot;
Output: 6
Explanation: 
A sequence of valid moves would be &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;.
Note that a sequence like &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; would be invalid,
because the wheels of the lock become stuck after the display becomes the dead end &quot;0102&quot;.
</pre>

Example 2:

<br /><pre className="overflow-x-auto">
Input: deadends = [&quot;8888&quot;], target = &quot;0009&quot;
Output: 1
Explanation: We can turn the last wheel in reverse to move from &quot;0000&quot; -&gt; &quot;0009&quot;.
</pre>

Example 3:

<br /><pre className="overflow-x-auto">
Input: deadends = [&quot;8887&quot;,&quot;8889&quot;,&quot;8878&quot;,&quot;8898&quot;,&quot;8788&quot;,&quot;8988&quot;,&quot;7888&quot;,&quot;9888&quot;], target = &quot;8888&quot;
Output: -1
Explanation: We cannot reach the target without getting stuck.
</pre>

 
Constraints:


	- <code>1 &lt;= deadends.length &lt;= 500</code>
	- <code>deadends[i].length == 4</code>
	- <code>target.length == 4</code>
	- target will not be in the list <code>deadends</code>.
	- <code>target</code> and <code>deadends[i]</code> consist of digits only.



## Solution

### Javascript
```javascript
404: Not Found
```
### Python
```python
class Solution:
    def openLock(self, deadends: List[str], target: str) -> int:
        if "0000" in deadends:
            return -1

        def children(wheel):
            res = []
            for i in range(4):
                digit = str((int(wheel[i]) + 1) % 10)
                res.append(wheel[:i] + digit + wheel[i + 1 :])
                digit = str((int(wheel[i]) + 10 - 1) % 10)
                res.append(wheel[:i] + digit + wheel[i + 1 :])
            return res

        q = deque()
        visit = set(deadends)
        q.append(["0000", 0])  # [wheel, turns]
        while q:
            wheel, turns = q.popleft()
            if wheel == target:
                return turns
            for child in children(wheel):
                if child not in visit:
                    visit.add(child)
                    q.append([child, turns + 1])
        return -1

```
### C++
```cpp
404: Not Found
```
### Java
```java
//Simple BFS solution

class Solution {

    public int openLock(String[] deadends, String target) {
        String start = "0000";
        int ans = 0;
        Queue<String> q = new LinkedList<>();
        HashSet<String> visited = new HashSet<>();
        //Add all the deadends in the visited set so we can ignore them and visited values altogether.
        for (String s : deadends) visited.add(s);
        q.offer(start);
        while (!q.isEmpty()) {
            int size = q.size();
            for (int j = 0; j < size; j++) {
                String str = q.poll();
                StringBuilder cur = new StringBuilder(str);
                if (str.equals(target)) return ans;
                if (!visited.contains(cur.toString())) {
                    for (int i = 0; i < start.length(); i++) {
                        //edge case for 0
                        if (cur.charAt(i) == '0') {
                            cur.setCharAt(i, '1');
                            q.offer(cur.toString());
                            cur.setCharAt(i, '9');
                            q.offer(cur.toString());
                        } else if (cur.charAt(i) == '9') { //edge case for 9
                            cur.setCharAt(i, '0');
                            q.offer(cur.toString());
                            cur.setCharAt(i, '8');
                            q.offer(cur.toString());
                        } else {
                            cur.setCharAt(i, ((char) (cur.charAt(i) + 1)));
                            q.offer(cur.toString());
                            cur.setCharAt(i, ((char) (cur.charAt(i) - 2)));
                            q.offer(cur.toString());
                        }
                        visited.add(str);
                        cur.setLength(0);
                        cur.append(str);
                    }
                }
            }
            ans++;
        }
        return -1;
    }
}

```


