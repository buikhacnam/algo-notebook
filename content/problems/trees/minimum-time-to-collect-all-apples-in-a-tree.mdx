---
title: Minimum Time to Collect All Apples in a Tree
category: Trees
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree)

</Callout>

## Description

Given an undirected tree consisting of <code>n</code> vertices numbered from <code>0</code> to <code>n-1</code>, which has some apples in their vertices. You spend 1 second to walk over one edge of the tree. _Return the minimum time in seconds you have to spend to collect all apples in the tree, starting at vertex 0 and coming back to this vertex._

The edges of the undirected tree are given in the array <code>edges</code>, where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> means that exists an edge connecting the vertices <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>. Additionally, there is a boolean array <code>hasApple</code>, where <code>hasApple[i] = true</code> means that vertex <code>i</code> has an apple; otherwise, it does not have any apple.

Example 1:

<Image
	alt=""
	src="https://assets.leetcode.com/uploads/2020/04/23/min_time_collect_apple_1.png"
	width={300}
	height={212}
/>
<br />
<pre className="overflow-x-auto">
	Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple =
	[false,false,true,false,true,true,false] Output: 8 Explanation: The figure
	above represents the given tree where red vertices have an apple. One optimal
	path to collect all apples is shown by the green arrows.
</pre>

Example 2:

<Image
	alt=""
	src="https://assets.leetcode.com/uploads/2020/04/23/min_time_collect_apple_2.png"
	width={300}
	height={212}
/>
<br />
<pre className="overflow-x-auto">
	Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple =
	[false,false,true,false,false,true,false] Output: 6 Explanation: The figure
	above represents the given tree where red vertices have an apple. One optimal
	path to collect all apples is shown by the green arrows.
</pre>

Example 3:

<br />
<pre className="overflow-x-auto">
	Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple =
	[false,false,false,false,false,false,false] Output: 0
</pre>

Constraints:

    - <code>1 &lt;= n &lt;= 10<sup>5</sup></code>
    - <code>edges.length == n - 1</code>
    - <code>edges[i].length == 2</code>
    - <code>0 &lt;= a<sub>i</sub> &lt; b<sub>i</sub> &lt;= n - 1</code>
    - <code>hasApple.length == n</code>

## Solution

### Javascript

```javascript
Solution will be updated soon
```

### Python

```python
Solution will be updated soon
```

### C++

```cpp
Solution will be updated soon
```

### Java

```java
Solution will be updated soon
```
