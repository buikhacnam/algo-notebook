---
title: Binary Search Tree Iterator
category: Trees
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/binary-search-tree-iterator)

</Callout>

## Description

Implement the <code>BSTIterator</code> class that represents an iterator over the <a href="https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR)" target="_blank">in-order traversal</a> of a binary search tree (BST):

    - <code>BSTIterator(TreeNode root)</code> Initializes an object of the <code>BSTIterator</code> class. The <code>root</code> of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.
    - <code>boolean hasNext()</code> Returns <code>true</code> if there exists a number in the traversal to the right of the pointer, otherwise returns <code>false</code>.
    - <code>int next()</code> Moves the pointer to the right, then returns the number at the pointer.

Notice that by initializing the pointer to a non-existent smallest number, the first call to <code>next()</code> will return the smallest element in the BST.

You may assume that <code>next()</code> calls will always be valid. That is, there will be at least a next number in the in-order traversal when <code>next()</code> is called.

Example 1:

<Image
	alt=""
	src="https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png"
	width={189}
	height={178}
/>
<br />

<pre className="overflow-x-auto">
	Input [&quot;BSTIterator&quot;, &quot;next&quot;, &quot;next&quot;,
	&quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;,
	&quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;] [[[7, 3, 15, null,
	null, 9, 20]], [], [], [], [], [], [], [], [], []] Output [null, 3, 7, true,
	9, true, 15, true, 20, false] Explanation BSTIterator bSTIterator = new
	BSTIterator([7, 3, 15, null, null, 9, 20]); bSTIterator.next(); // return 3
	bSTIterator.next(); // return 7 bSTIterator.hasNext(); // return True
	bSTIterator.next(); // return 9 bSTIterator.hasNext(); // return True
	bSTIterator.next(); // return 15 bSTIterator.hasNext(); // return True
	bSTIterator.next(); // return 20 bSTIterator.hasNext(); // return False
</pre>

Constraints:

    - The number of nodes in the tree is in the range <code>[1, 10<sup>5</sup>]</code>.
    - <code>0 &lt;= Node.val &lt;= 10<sup>6</sup></code>
    - At most <code>10<sup>5</sup></code> calls will be made to <code>hasNext</code>, and <code>next</code>.

Follow up:

    - Could you implement <code>next()</code> and <code>hasNext()</code> to run in average <code>O(1)</code> time and use <code>O(h)</code> memory, where <code>h</code> is the height of the tree?

## Solution

### Javascript

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */

/**
 * Controlled Recursion - Average Time (1)
 * Time O(N) | Space O(N)
 * https://leetcode.com/problems/binary-search-tree-iterator/
 * @param {TreeNode} root
 */
class BSTIterator {
	constructor(root) {
		this.stack = [] /*           | Space O(N) */
		this.getLeft(root) /* Time O(N) | Space O(N)*/
	}

	/**
	 * Time O(N) | Space O(H)
	 * @return {number}
	 */
	getLeft(root, { stack } = this) {
		while (root !== null) {
			/* Time O(N) */
			stack.push(root) /* Space O(N) */
			root = root.left
		}
	}

	/**
	 * Time O(N) | Space O(N)
	 * @return the next smallest number
	 * @return {number}
	 */
	next({ stack } = this) {
		const node = stack.pop()

		if (node.right) this.getLeft(node.right) /* Time O(N) | Space O(N) */

		return node.val
	}

	/**
	 * Time O(1) | Space O(1)
	 * @return whether we have a next smallest number
	 * @return {boolean}
	 */
	hasNext({ stack } = this) {
		return stack.length !== 0
	}
}

/**
 * Your BSTIterator object will be instantiated and called as such:
 * var obj = new BSTIterator(root)
 * var param_1 = obj.next()
 * var param_2 = obj.hasNext()
 */
```

### Python

```python
Solution will be updated soon
```

### C++

```cpp
Solution will be updated soon
```

### Java

```java
class BSTIterator {

    TreeNode iterator;
    Queue<Integer> traversal;

    public BSTIterator(TreeNode root) {
        iterator = root;
        traversal = new ArrayDeque<>();
        fillStack(iterator);
    }

    public void fillStack(TreeNode iterator){
        if (iterator.left != null) {
            fillStack(iterator.left);
        }
        traversal.add(iterator.val);
        if (iterator.right != null) {
            fillStack(iterator.right);
        }
    }

    public int next() {
        while (!traversal.isEmpty()) {
            return traversal.poll();
        }
        return -1;
    }

    public boolean hasNext() {
        return !traversal.isEmpty();
    }
}
```
