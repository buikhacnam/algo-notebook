---
title: Balanced Binary Tree
category: Trees
difficulty: Easy
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/balanced-binary-tree)

</Callout>

## Description

Given a binary tree, determine if it is <span data-keyword="height-balanced">height-balanced</span>.

Example 1:

<Image
	alt=""
	src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg"
	width={342}
	height={221}
/>
<br />

<pre className="overflow-x-auto">
	Input: root = [3,9,20,null,null,15,7] Output: true
</pre>

Example 2:

<Image
	alt=""
	src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg"
	width={452}
	height={301}
/>
<br />

<pre className="overflow-x-auto">
	Input: root = [1,2,2,3,3,null,null,4,4] Output: false
</pre>

Example 3:

<br />

<pre className="overflow-x-auto">Input: root = [] Output: true</pre>

Constraints:

    - The number of nodes in the tree is in the range <code>[0, 5000]</code>.
    - <code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code>

## Solution

### Javascript

```javascript
/**
 * https://leetcode.com/problems/balanced-binary-tree/
 * TIme O(N) | Space O(H)
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function (root) {
	const isBaseCase = root === null
	if (isBaseCase) return true
	if (!isAcceptableHeight(root)) return false
	if (!isChildBalanced(root)) return false

	return true
}

const isChildBalanced = (root) => {
	const left = isBalanced(root.left)
	const right = isBalanced(root.right)

	return left && right
}

const isAcceptableHeight = (root) => {
	const left = getHeight(root.left)
	const right = getHeight(root.right)

	const difference = Math.abs(left - right)

	return difference <= 1
}

const getHeight = (root) => {
	const isBaseCase = root === null
	if (isBaseCase) return 0

	return dfs(root)
}

var dfs = (root) => {
	const left = getHeight(root.left)
	const right = getHeight(root.right)

	const height = Math.max(left, right)

	return height + 1
}

/**
 * https://leetcode.com/problems/balanced-binary-tree/
 * TIme O(N) | Space O(H)
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function (root) {
	const [_height, _isBalanced] = isRootBalanced(root)

	return _isBalanced
}

var isRootBalanced = (root) => {
	const isBaseCase = root === null
	if (isBaseCase) return [-1, true]

	return dfs(root)
}

var dfs = (root) => {
	const [left, isLeftBalanced] = isRootBalanced(root.left)
	const [right, isRightBalanced] = isRootBalanced(root.right)
	const [height, difference] = [Math.max(left, right), Math.abs(left - right)]

	const isAcceptableHeight = difference <= 1
	const _isBalanced = isLeftBalanced && isRightBalanced

	const _isRootBalanced = _isBalanced && isAcceptableHeight

	return [height + 1, _isRootBalanced]
}
```

### Python

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        def dfs(root):
            if not root:
                return [True, 0]

            left, right = dfs(root.left), dfs(root.right)
            balanced = left[0] and right[0] and abs(left[1] - right[1]) <= 1
            return [balanced, 1 + max(left[1], right[1])]

        return dfs(root)[0]

```

### C++

```cpp
/*
    Given binary tree, determine if height-balanced (all left & right subtrees height diff <= 1)

    Check if subtrees are balanced, if so, use their heights to determine further balance

    Time: O(n)
    Space: O(n)
*/

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isBalanced(TreeNode* root) {
        int height = 0;
        return dfs(root, height);
    }
private:
    bool dfs(TreeNode* root, int& height) {
        if (root == NULL) {
            height = -1;
            return true;
        }

        int left = 0;
        int right = 0;

        if (!dfs(root->left, left) || !dfs(root->right, right)) {
            return false;
        }
        if (abs(left - right) > 1) {
            return false;
        }

        height = 1 + max(left, right);
        return true;
    }
};

```

### Java

```java
package com.coding.patterns.tree;

class BalancedBinaryTree {

    private static Pair<Boolean, Integer> dfs(TreeNode root) {
        if (root == null) {
            return new Pair<Boolean, Integer>(true, 0);
        }

        var left = dfs(root.left);
        var right = dfs(root.right);

        var balanced =
            left.getKey() &&
            right.getKey() &&
            (Math.abs(left.getValue() - right.getValue()) <= 1);

        return new Pair<Boolean, Integer>(
            balanced,
            1 + Math.max(left.getValue(), right.getValue())
        );
    }

    public static boolean isBalanced(TreeNode root) {
        return dfs(root).getKey();
    }
}

```
