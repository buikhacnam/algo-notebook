---
title: Delete Node in a BST
category: Trees
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/delete-node-in-a-bst)

</Callout>

## Description

Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return _the root node reference (possibly updated) of the BST_.

Basically, the deletion can be divided into two stages:

<ol>- Search for a node to remove. - If the node is found, delete the node.</ol>

Example 1:

<Image
	alt=""
	src="https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg"
	width={800}
	height={214}
/>
<br />
<pre className="overflow-x-auto">
	Input: root = [5,3,6,2,4,null,7], key = 3 Output: [5,4,6,2,null,null,7]
	Explanation: Given key to delete is 3. So we find the node with value 3 and
	delete it. One valid answer is [5,4,6,2,null,null,7], shown in the above BST.
	Please notice that another valid answer is [5,2,6,null,4,null,7] and it&#39;s
	also accepted.
	<Image
		alt=""
		src="https://assets.leetcode.com/uploads/2020/09/04/del_node_supp.jpg"
		width={350}
		height={255}
	/>
</pre>

Example 2:

<br />
<pre className="overflow-x-auto">
	Input: root = [5,3,6,2,4,null,7], key = 0 Output: [5,3,6,2,4,null,7]
	Explanation: The tree does not contain a node with value = 0.
</pre>

Example 3:

<br />
<pre className="overflow-x-auto">Input: root = [], key = 0 Output: []</pre>

Constraints:

    - The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.
    - <code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code>
    - Each node has a unique value.
    - <code>root</code> is a valid binary search tree.
    - <code>-10<sup>5</sup> &lt;= key &lt;= 10<sup>5</sup></code>

Follow up: Could you solve it with time complexity <code>O(height of tree)</code>?

## Solution

### Javascript

```javascript
Solution will be updated soon
```

### Python

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:
        if not root:
            return root

        if key > root.val:
            root.right = self.deleteNode(root.right, key)
        elif key < root.val:
            root.left = self.deleteNode(root.left, key)
        else:
            if not root.left:
                return root.right
            elif not root.right:
                return root.left

            # Find the min from right subtree
            cur = root.right
            while cur.left:
                cur = cur.left
            root.val = cur.val
            root.right = self.deleteNode(root.right, root.val)
        return root

```

### C++

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

// Time: O(h)
// Space: O(1)
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(root == nullptr) return root;

        if(root->val > key) {
            root->left = deleteNode(root->left, key);
        }
        else if(root->val < key) {
            root->right = deleteNode(root->right, key);
        }

        // perform deletion if root->val == key
        else {
            if(!root->left) return root->right;
            if(!root->right) return root->left;

            // both left and right subtrees are not null
            // traverse the right subtree to find the minimum/leftmost value
            // (or) travel the left subtree to find the maximum/rightmost value
            TreeNode* temp = root->right;
            while(temp->left) {
                temp = temp->left;
            }
            root->val = temp->val;

            root->right = deleteNode(root->right, temp->val);
        }

        return root;
    }
};

```

### Java

```java
Solution will be updated soon
```
