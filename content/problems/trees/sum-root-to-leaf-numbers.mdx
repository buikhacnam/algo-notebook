---
title: Sum Root to Leaf Numbers
category: Trees
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/sum-root-to-leaf-numbers)

</Callout>

## Description

You are given the <code>root</code> of a binary tree containing digits from <code>0</code> to <code>9</code> only.

Each root-to-leaf path in the tree represents a number.

    - For example, the root-to-leaf path <code>1 -&gt; 2 -&gt; 3</code> represents the number <code>123</code>.

Return _the total sum of all root-to-leaf numbers_. Test cases are generated so that the answer will fit in a 32-bit integer.

A leaf node is a node with no children.

Example 1:

<Image
	alt=""
	src="https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg"
	width={212}
	height={182}
/>
<br />
<pre className="overflow-x-auto">
	Input: root = [1,2,3] Output: 25 Explanation: The root-to-leaf path{' '}
	<code>1-&gt;2</code> represents the number <code>12</code>. The root-to-leaf
	path <code>1-&gt;3</code> represents the number <code>13</code>. Therefore,
	sum = 12 + 13 = <code>25</code>.
</pre>

Example 2:

<Image
	alt=""
	src="https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg"
	width={292}
	height={302}
/>
<br />
<pre className="overflow-x-auto">
	Input: root = [4,9,0,5,1] Output: 1026 Explanation: The root-to-leaf path{' '}
	<code>4-&gt;9-&gt;5</code> represents the number 495. The root-to-leaf path{' '}
	<code>4-&gt;9-&gt;1</code> represents the number 491. The root-to-leaf path{' '}
	<code>4-&gt;0</code> represents the number 40. Therefore, sum = 495 + 491 + 40
	= <code>1026</code>.
</pre>

Constraints:

    - The number of nodes in the tree is in the range <code>[1, 1000]</code>.
    - <code>0 &lt;= Node.val &lt;= 9</code>
    - The depth of the tree will not exceed <code>10</code>.

## Solution

### Javascript

```javascript
Solution will be updated soon
```

### Python

```python
Solution will be updated soon
```

### C++

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

class Solution {
public:
    int sumNumbers(TreeNode* root) {
        if (!root)
            return 0;
        stack<pair<TreeNode*, int> > stk;
        stk.push(make_pair(root, root->val));

        int sum = 0;
        while (!stk.empty()) {
            pair<TreeNode*, int> elm = stk.top();
            stk.pop();
            TreeNode* node = elm.first;
            int num = elm.second;
            if (!node->left && !node->right) {
                sum += num;
                continue;
            }
            if (node->left)
                stk.push(make_pair(node->left, num * 10 + node->left->val));
            if (node->right)
                stk.push(make_pair(node->right, num * 10 + node->right->val));
        }
        return sum;
    }
};

```

### Java

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
// solution from the video
class Solution {
    /*
        Time complexity: O(V) where V is the number of vertices
        Space complexity: O(h) where h is the height of the tree
    */

    public int sumNumbers(TreeNode root) {
        // track the sum that we want to add
        int solution = 0;

        // execute a dfs to find the leaf nodes
        solution = findLeafNodes(root, solution);

        // return the solution
        return solution;
    }

    // dfs method
    public int findLeafNodes(TreeNode node, int currentPath){
        // base case, if no node then return 0
        if(node==null){
            return 0;
        }

        // add the current node value to the currentPath (move decimal to right by 1 and add)
        currentPath = (currentPath * 10) + node.val;

        // if we are at a non-null node, check if it is a leaf
        if(node.left==null && node.right==null){
            // return the solution
            return currentPath;
        }

        // check find the leaf nodes on the left and right
        return findLeafNodes(node.left, currentPath) + findLeafNodes(node.right, currentPath);
    }
}

// solution using strings
class Solution {
    /*
        Time complexity: O(V) where V is the number of vertices
        Space complexity: O(V) where V is the number of vertices
    */

    // keep track of the different root to node values as a string
    List<String> rootToLeafs = new ArrayList<String>();

    public int sumNumbers(TreeNode root) {
        // track the sum that we want to add
        int solution = 0;

        String currentPath = "";

        // execute a dfs to find the leaf nodes
        findLeafNodes(root, currentPath);

        // loop through all the paths, convert to int, add to solution
        for(String curr:rootToLeafs){
            // save the current string as an integer
            int currentVal = Integer.parseInt(curr);

            // add the current value to the solution
            solution+=currentVal;
        }

        // return the solution
        return solution;
    }

    // dfs method
    public void findLeafNodes(TreeNode node, String currentPath){
        // base case, if no node then return
        if(node==null){
            return;
        }

        // add the current node value to the currentPath string
        currentPath+=Integer.toString(node.val);

        // check the left most value
        findLeafNodes(node.left, currentPath);

        // check the right most value
        findLeafNodes(node.right, currentPath);

        // if we are at a non-null node, check if it is a leaf
        if(node.left==null && node.right==null){
            // add the currentPath to the arraylist
            rootToLeafs.add(currentPath);
        }
    }
}
```
