---
title: Count Good Nodes in Binary Tree
category: Trees
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/count-good-nodes-in-binary-tree)

</Callout>

## Description
Given a binary tree <code>root</code>, a node *X* in the tree is named good if in the path from root to *X* there are no nodes with a value *greater than* X.

Return the number of good nodes in the binary tree.

 
Example 1:

<Image alt="" src="https://assets.leetcode.com/uploads/2020/04/02/test_sample_1.png" width={263} height={156} />

<br /><pre className="overflow-x-auto">
Input: root = [3,1,4,3,null,1,5]
Output: 4
Explanation: Nodes in blue are good.
Root Node (3) is always a good node.
Node 4 -&gt; (3,4) is the maximum value in the path starting from the root.
Node 5 -&gt; (3,4,5) is the maximum value in the path
Node 3 -&gt; (3,1,3) is the maximum value in the path.</pre>

Example 2:

<Image alt="" src="https://assets.leetcode.com/uploads/2020/04/02/test_sample_2.png" width={157} height={161} />

<br /><pre className="overflow-x-auto">
Input: root = [3,3,null,4,2]
Output: 3
Explanation: Node 2 -&gt; (3, 3, 2) is not good, because &quot;3&quot; is higher than it.</pre>

Example 3:

<br /><pre className="overflow-x-auto">
Input: root = [1]
Output: 1
Explanation: Root is considered as good.</pre>

 
Constraints:


	- The number of nodes in the binary tree is in the range <code>[1, 10^5]</code>.
	- Each node&#39;s value is between <code>[-10^4, 10^4]</code>.


## Solution

### Javascript
```javascript
/**
 * https://leetcode.com/problems/count-good-nodes-in-binary-tree/
 * Time O(N) | Space O(H)
 * @param {TreeNode} root
 * @return {number}
 */
 var goodNodes = function(root, max = -Infinity, total = [ 0 ]) {
    count(root, max, total);

    return total[0]
};

const count = (root, max, total) => {
    const isBaseCase = root === null;
    if (isBaseCase) return 0;

    return dfs(root, max, total);
}

const dfs = (root, max, total) => {
    const isGood = max <= root.val
    if (isGood) total[0]++;

    max = Math.max(max, root.val);

    count(root.left, max, total);
    count(root.right, max, total);
}

/**
 * https://leetcode.com/problems/count-good-nodes-in-binary-tree/
 * Time O(N) | Space O(W)
 * @param {TreeNode} root
 * @return {number}
 */
var goodNodes = function(root, ) {
    const isBaseCase = root === null;
    if (isBaseCase) return 0
    
    return bfs([[ root, -Infinity ]]);
}

const bfs = (queue, total = 0) => {
    while (queue.length) {
        for (let i = (queue.length - 1); 0 <= i; i--) {
            let [ root, max ] = queue.shift();

            const isGood = max <= root.val;
            if (isGood) total++;

            max = Math.max(max, root.val);

            if (root.right) queue.push([ root.right, max ]);
            if (root.left) queue.push([ root.left, max ]);
        }
    }

    return total;
}

```
### Python
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def goodNodes(self, root: TreeNode) -> int:
        def dfs(node, maxVal):
            if not node:
                return 0

            res = 1 if node.val >= maxVal else 0
            maxVal = max(maxVal, node.val)
            res += dfs(node.left, maxVal)
            res += dfs(node.right, maxVal)
            return res

        return dfs(root, root.val)

```
### C++
```cpp
/*
    Given binary tree, node is "good" if path from root has no nodes > X, return # of "good"

    Maintain greatest value seen so far on a path, if further node >= this max, "good" node

    Time: O(n)
    Space: O(n)
*/

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int goodNodes(TreeNode* root) {
        int result = 0;
        dfs(root, root->val, result);
        return result;
    }
private:
    void dfs(TreeNode* root, int maxSoFar, int& result) {
        if (root == NULL) {
            return;
        }
        
        if (root->val >= maxSoFar) {
            result++;
        }
        
        dfs(root->left, max(maxSoFar, root->val), result);
        dfs(root->right, max(maxSoFar, root->val), result);
    }
};

```
### Java
```java
class Solution {

    public int goodNodes(TreeNode root) {
        return helper(root, -99999);
    }

    public int helper(TreeNode root, int max) {
        if (root == null) return 0;

        int res = root.val >= max ? 1 : 0;

        res += helper(root.left, Math.max(root.val, max));
        res += helper(root.right, Math.max(root.val, max));

        return res;
    }
}

```


