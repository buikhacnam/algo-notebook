---
title: Construct String from Binary Tree
category: Trees
difficulty: Easy
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/construct-string-from-binary-tree)

</Callout>

## Description

Given the <code>root</code> of a binary tree, construct a string consisting of parenthesis and integers from a binary tree with the preorder traversal way, and return it.

Omit all the empty parenthesis pairs that do not affect the one-to-one mapping relationship between the string and the original binary tree.

Example 1:

<Image
	alt=""
	src="https://assets.leetcode.com/uploads/2021/05/03/cons1-tree.jpg"
	width={292}
	height={301}
/>
<br />
<pre className="overflow-x-auto">
	Input: root = [1,2,3,4] Output: &quot;1(2(4))(3)&quot; Explanation:
	Originally, it needs to be &quot;1(2(4)())(3()())&quot;, but you need to omit
	all the unnecessary empty parenthesis pairs. And it will be
	&quot;1(2(4))(3)&quot;
</pre>

Example 2:

<Image
	alt=""
	src="https://assets.leetcode.com/uploads/2021/05/03/cons2-tree.jpg"
	width={207}
	height={293}
/>
<br />
<pre className="overflow-x-auto">
	Input: root = [1,2,3,null,4] Output: &quot;1(2()(4))(3)&quot; Explanation:
	Almost the same as the first example, except we cannot omit the first
	parenthesis pair to break the one-to-one mapping relationship between the
	input and the output.
</pre>

Constraints:

    - The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.
    - <code>-1000 &lt;= Node.val &lt;= 1000</code>

## Solution

### Javascript

```javascript
Solution will be updated soon
```

### Python

```python
class Solution:
    def tree2str(self, root: Optional[TreeNode]) -> str:
        # Solution with O(n) time and space complexity
        res = []
        self.dfs(root, res)
        return "".join(res)

    def dfs(self, t: TreeNode, res: list):
        # If the current node is None, do nothing and return
        if t is None:
            return
        res.append(str(t.val))

        # If both left and right children are None, return as there are no more branches to explore
        if t.left is None and t.right is None:
            return
        res.append('(')

        # Recursively call the DFS function for the left child
        self.dfs(t.left, res)
        res.append(')')

        # If the right child exists, process it
        if t.right is not None:
            res.append('(')

            # Recursively call the DFS function for the right child
            self.dfs(t.right, res)
            res.append(')')

```

### C++

```cpp
Solution will be updated soon
```

### Java

```java
class Solution {
    public String tree2str(TreeNode root) {
        if(root == null) return "";
        String output = String.valueOf(root.val);
        if(root.left != null || root.right != null)
            output += "(" + tree2str(root.left) + ")";
        if(root.right != null)
            output += "(" + tree2str(root.right) + ")";

        return output;
    }


}

```
