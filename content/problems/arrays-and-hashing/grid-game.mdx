---
title: Grid Game
category: Arrays And Hashing
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/grid-game)

</Callout>

## Description
You are given a 0-indexed 2D array <code>grid</code> of size <code>2 x n</code>, where <code>grid[r][c]</code> represents the number of points at position <code>(r, c)</code> on the matrix. Two robots are playing a game on this matrix.

Both robots initially start at <code>(0, 0)</code> and want to reach <code>(1, n-1)</code>. Each robot may only move to the right (<code>(r, c)</code> to <code>(r, c + 1)</code>) or down (<code>(r, c)</code> to <code>(r + 1, c)</code>).

At the start of the game, the first robot moves from <code>(0, 0)</code> to <code>(1, n-1)</code>, collecting all the points from the cells on its path. For all cells <code>(r, c)</code> traversed on the path, <code>grid[r][c]</code> is set to <code>0</code>. Then, the second robot moves from <code>(0, 0)</code> to <code>(1, n-1)</code>, collecting the points on its path. Note that their paths may intersect with one another.

The first robot wants to minimize the number of points collected by the second robot. In contrast, the second robot wants to maximize the number of points it collects. If both robots play optimally, return *the <b>number of points</b> collected by the second robot.*

 
Example 1:
<Image alt="" src="https://assets.leetcode.com/uploads/2021/09/08/a1.png" width={388} height={103} />
<br /><pre className="overflow-x-auto">
Input: grid = [[2,5,4],[1,5,1]]
Output: 4
Explanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.
The cells visited by the first robot are set to 0.
The second robot will collect 0 + 0 + 4 + 0 = 4 points.
</pre>

Example 2:
<Image alt="" src="https://assets.leetcode.com/uploads/2021/09/08/a2.png" width={384} height={105} />
<br /><pre className="overflow-x-auto">
Input: grid = [[3,3,1],[8,5,2]]
Output: 4
Explanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.
The cells visited by the first robot are set to 0.
The second robot will collect 0 + 3 + 1 + 0 = 4 points.
</pre>

Example 3:
<Image alt="" src="https://assets.leetcode.com/uploads/2021/09/08/a3.png" width={493} height={103} />
<br /><pre className="overflow-x-auto">
Input: grid = [[1,3,1,15],[1,3,3,1]]
Output: 7
Explanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.
The cells visited by the first robot are set to 0.
The second robot will collect 0 + 1 + 3 + 3 + 0 = 7 points.
</pre>

 
Constraints:


	- <code>grid.length == 2</code>
	- <code>n == grid[r].length</code>
	- <code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code>
	- <code>1 &lt;= grid[r][c] &lt;= 10<sup>5</sup></code>



## Solution

### Javascript
```javascript
/**
 * Submission Details: 
 * https://leetcode.com/problems/grid-game/
 * Time O(n), Space O(1)
 * Runtime: 89ms (beats 79.31%) || 53.5mb (beats 89.66%)
 */

/**
 * @param {number[][]} grid
 * @return {number}
 */

var gridGame = function(grid) {
    let one = grid[0].reduce((a,b)=>a+b) - grid[0][0];
    let two = 0;
    let res = one;
    for(let i = 1; i < grid[0].length; i++){
        one-=grid[0][i];
        two+=grid[1][i-1];
        res = Math.min(res, Math.max(one,two));
    }
    return res;
};
```
### Python
```python
# Time: O(n) Space: O(1)

class Solution(object):
    def gridGame(self, grid):
        result = float("inf")
        left, right = 0, sum(grid[0])

        for a, b in zip(grid[0], grid[1]):
            right -= a
            result = min(result, max(left, right))
            left += b
        return result

```
### C++
```cpp
/* 
Approch:
    2nd robot can collect either all the bottom points
    before the break point (when 1st robot goes to bottom)
    or collect all the top points after that break point.
Time Complexity: O(N)
Space Complexity: O(1)
*/

class Solution {
public:
    long long gridGame(vector<vector<int>>& grid) {
  
        // prefix sum
        long long top = grid[0][0],bottom = 0, answer = LONG_MAX;
        for(int i =1;i<grid[0].size();i++){
            top += grid[0][i];
        }

        for(int i =0;i<grid[0].size();i++){
            // All the top points 2nd robot can collect
            top -= grid[0][i];

            // min because first robot wants to  minimize 
            answer = min(answer,max(top,bottom));

            // All the bootom points the robot could collect
            bottom += grid[1][i];
        }

        return answer;
    }
};
```
### Java
```java
404: Not Found
```


