---
title: Naming a Company
category: Arrays And Hashing
difficulty: Hard
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/naming-a-company)

</Callout>

## Description

You are given an array of strings <code>ideas</code> that represents a list of names to be used in the process of naming a company. The process of naming a company is as follows:

<ol>
	- Choose 2 distinct names from <code>ideas</code>, call them{' '}
	<code>
		idea<sub>A</sub>
	</code>{' '}
	and{' '}
	<code>
		idea<sub>B</sub>
	</code>
	. - Swap the first letters of{' '}
	<code>
		idea<sub>A</sub>
	</code>{' '}
	and{' '}
	<code>
		idea<sub>B</sub>
	</code>{' '}
	with each other. - If both of the new names are not found in the original{' '}
	<code>ideas</code>, then the name{' '}
	<code>
		idea<sub>A</sub> idea<sub>B</sub>
	</code>{' '}
	(the concatenation of{' '}
	<code>
		idea<sub>A</sub>
	</code>{' '}
	and{' '}
	<code>
		idea<sub>B</sub>
	</code>
	, separated by a space) is a valid company name. - Otherwise, it is not a
	valid name.
</ol>

Return _the number of distinct valid names for the company_.

Example 1:

<br /><pre className="overflow-x-auto">
Input: ideas = [&quot;coffee&quot;,&quot;donuts&quot;,&quot;time&quot;,&quot;toffee&quot;]
Output: 6
Explanation: The following selections are valid:
- (&quot;coffee&quot;, &quot;donuts&quot;): The company name created is &quot;doffee conuts&quot;.
- (&quot;donuts&quot;, &quot;coffee&quot;): The company name created is &quot;conuts doffee&quot;.
- (&quot;donuts&quot;, &quot;time&quot;): The company name created is &quot;tonuts dime&quot;.
- (&quot;donuts&quot;, &quot;toffee&quot;): The company name created is &quot;tonuts doffee&quot;.
- (&quot;time&quot;, &quot;donuts&quot;): The company name created is &quot;dime tonuts&quot;.
- (&quot;toffee&quot;, &quot;donuts&quot;): The company name created is &quot;doffee tonuts&quot;.
Therefore, there are a total of 6 distinct company names.

The following are some examples of invalid selections:

- (&quot;coffee&quot;, &quot;time&quot;): The name &quot;toffee&quot; formed after swapping already exists in the original array.
- (&quot;time&quot;, &quot;toffee&quot;): Both names are still the same after swapping and exist in the original array.
- (&quot;coffee&quot;, &quot;toffee&quot;): Both names formed after swapping already exist in the original array.
  </pre>

Example 2:

<br />
<pre className="overflow-x-auto">
	Input: ideas = [&quot;lack&quot;,&quot;back&quot;] Output: 0 Explanation:
	There are no valid selections. Therefore, 0 is returned.
</pre>

Constraints:

    - <code>2 &lt;= ideas.length &lt;= 5 * 10<sup>4</sup></code>
    - <code>1 &lt;= ideas[i].length &lt;= 10</code>
    - <code>ideas[i]</code> consists of lowercase English letters.
    - All the strings in <code>ideas</code> are unique.

## Solution

### Javascript

```javascript
Solution will be updated soon
```

### Python

```python
Solution will be updated soon
```

### C++

```cpp
Solution will be updated soon
```

### Java

```java
class Solution {
    public long distinctNames(String[] ideas) {
        Map<Character, Set<String>> map = new HashMap<>();
        for (String s : ideas) {
            char key = s.charAt(0);
            String val = s.substring(1, s.length());
            Set<String> set = map.getOrDefault(key, new HashSet<>());
            set.add(val);
            map.put(key, set);
        }

        long res = 0;
        for (char key1 : map.keySet()) {
            Set<String> set1 = map.get(key1);
            for (char key2 : map.keySet()) {
                if (key1 == key2) continue;
                Set<String> set2 = map.get(key2);
                int overlap = 0;
                for (String s : set1) {
                    if (set2.contains(s)) overlap++;
                }
                res += (set1.size() - overlap) * (set2.size() - overlap);
            }
        }
        return res;
    }
}

```
