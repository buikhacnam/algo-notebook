---
title: Next Greater Element I
category: Arrays And Hashing
difficulty: Easy
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/next-greater-element-i)

</Callout>

## Description
The next greater element of some element <code>x</code> in an array is the first greater element that is to the right of <code>x</code> in the same array.

You are given two distinct 0-indexed integer arrays <code>nums1</code> and <code>nums2</code>, where <code>nums1</code> is a subset of <code>nums2</code>.

For each <code>0 &lt;= i &lt; nums1.length</code>, find the index <code>j</code> such that <code>nums1[i] == nums2[j]</code> and determine the next greater element of <code>nums2[j]</code> in <code>nums2</code>. If there is no next greater element, then the answer for this query is <code>-1</code>.

Return *an array *<code>ans</code>* of length *<code>nums1.length</code>* such that *<code>ans[i]</code>* is the next greater element as described above.*

 
Example 1:

<br /><pre className="overflow-x-auto">
Input: nums1 = [4,1,2], nums2 = [1,3,4,2]
Output: [-1,3,-1]
Explanation: The next greater element for each value of nums1 is as follows:
- 4 is underlined in nums2 = [1,3,<u>4</u>,2]. There is no next greater element, so the answer is -1.
- 1 is underlined in nums2 = [<u>1</u>,3,4,2]. The next greater element is 3.
- 2 is underlined in nums2 = [1,3,4,<u>2</u>]. There is no next greater element, so the answer is -1.
</pre>

Example 2:

<br /><pre className="overflow-x-auto">
Input: nums1 = [2,4], nums2 = [1,2,3,4]
Output: [3,-1]
Explanation: The next greater element for each value of nums1 is as follows:
- 2 is underlined in nums2 = [1,<u>2</u>,3,4]. The next greater element is 3.
- 4 is underlined in nums2 = [1,2,3,<u>4</u>]. There is no next greater element, so the answer is -1.
</pre>

 
Constraints:


	- <code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code>
	- <code>0 &lt;= nums1[i], nums2[i] &lt;= 10<sup>4</sup></code>
	- All integers in <code>nums1</code> and <code>nums2</code> are unique.
	- All the integers of <code>nums1</code> also appear in <code>nums2</code>.


 
Follow up: Could you find an <code>O(nums1.length + nums2.length)</code> solution?

## Solution

### Javascript
```javascript
var nextGreaterElement = function(nums1, nums2) {
    // O (n + m)
    let nums1Idx = new Map(); {
        let idx = 0;
        for(const n of nums1)
            nums1Idx.set(n, idx++);
    }
    let res = [];
    for(let i = 0; i < nums1.length; i++)
        res.push(-1);
    
    let stack = [];
    for(let i = 0; i < nums2.length; i++) {
        let cur = nums2[i];
        
        // while stack is not empty and current is greater than the top of the stack
        while(stack.length > 0 && cur > stack[stack.length - 1]) {
            let val = stack.pop();
            let idx = nums1Idx.get(val);
            res[idx] = cur;
        }
        
        if(nums1Idx.has(cur))
            stack.push(cur);
    }
    
    return res;
};

```
### Python
```python
class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:

        # O (n + m)
        nums1Idx = { n:i for i, n in enumerate(nums1) }
        res = [-1] * len(nums1)

        stack = []
        for i in range(len(nums2)):
            cur = nums2[i]

            # while stack exists and current is greater than the top of the stack
            while stack and cur > stack[-1]:
                val = stack.pop() # take top val
                idx = nums1Idx[val]
                res[idx] = cur

            if cur in nums1Idx:
                stack.append(cur)
        
        return res
    
    
        # O (n * m)
        nums1Idx = { n:i for i, n in enumerate(nums1) }
        res = [-1] * len(nums1)
        
        for i in range(len(nums2)):
            if nums2[i] not in nums1Idx:
                continue
            for j in range(i + 1, len(nums2)):
                if nums2[j] > nums2[i]:
                    idx = nums1Idx[nums2[i]]
                    res[idx] = nums2[j]
                    break
        
        return res
```
### C++
```cpp
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        // O (n + m)
        map<int, int> nums1Idx; {
            int idx = 0;
            for(int n: nums1)
                nums1Idx[n] = idx++;
        }
        vector<int> res;
        for(int i = 0; i < nums1.size(); i++)
            res.push_back(-1);
        
        stack<int> stack;
        for(int i = 0; i < nums2.size(); i++) {
            int cur = nums2[i];
            
            // while stack has elements and current is greater than the top of the stack
            while(stack.size() && cur > stack.top()) {
                int val = stack.top(); // take top val
                stack.pop();
                int idx = nums1Idx[val];
                res[idx] = cur;
            }
            
            if(nums1Idx.count(cur))
                stack.push(cur);
        }
        
        return res;
    }
};

```
### Java
```java
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        
        int[] res = new int[nums1.length];
        int counter=0;
        
        for(int i: nums1){
            res[counter++]=ans(i, nums2);
        }
        
        return res;
        
    }
    
    private int ans(int i, int[] nums){
        for(int n=0; n<nums.length; n++){
            if(nums[n]==i){
                for(int j=n+1; j<nums.length; j++){
                    if(nums[j]>i)
                        return nums[j];
                }
            }
        }
        return -1;
    }
}
```


