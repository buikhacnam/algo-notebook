---
title: Continuous Subarray Sum
category: Arrays And Hashing
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/continuous-subarray-sum)

</Callout>

## Description

Given an integer array nums and an integer k, return <code>true</code> _if _<code>nums</code>_ has a good subarray or _<code>false</code>_ otherwise_.

A good subarray is a subarray where:

    - its length is at least two, and
    - the sum of the elements of the subarray is a multiple of <code>k</code>.

Note that:

    - A subarray is a contiguous part of the array.
    - An integer <code>x</code> is a multiple of <code>k</code> if there exists an integer <code>n</code> such that <code>x = n * k</code>. <code>0</code> is always a multiple of <code>k</code>.

Example 1:

<br />

<pre className="overflow-x-auto">
	Input: nums = [23,<u>2,4</u>,6,7], k = 6 Output: true Explanation: [2, 4] is a
	continuous subarray of size 2 whose elements sum up to 6.
</pre>

Example 2:

<br />

<pre className="overflow-x-auto">
	Input: nums = [<u>23,2,6,4,7</u>], k = 6 Output: true Explanation: [23, 2, 6,
	4, 7] is an continuous subarray of size 5 whose elements sum up to 42. 42 is a
	multiple of 6 because 42 = 7 * 6 and 7 is an integer.
</pre>

Example 3:

<br />

<pre className="overflow-x-auto">
	Input: nums = [23,2,6,4,7], k = 13 Output: false
</pre>

Constraints:

    - <code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code>
    - <code>0 &lt;= nums[i] &lt;= 10<sup>9</sup></code>
    - <code>0 &lt;= sum(nums[i]) &lt;= 2<sup>31</sup> - 1</code>
    - <code>1 &lt;= k &lt;= 2<sup>31</sup> - 1</code>

## Solution

### Javascript

```javascript
/**
 * https://leetcode.com/problems/continuous-subarray-sum/
 * Hasing
 * Time O(n) | Space O(n)
 * @param {number[]} nums
 * @param {number} k
 * @return {boolean}
 */
var checkSubarraySum = function (arr, k) {
	let sum = 0
	const remainderMap = new Map([[0, -1]])

	for (let i = 0; i < arr.length; i++) {
		sum += arr[i]
		if (remainderMap.has(sum % k) && i - remainderMap.get(sum % k) > 1) {
			return true
		}
		if (!remainderMap.has(sum % k)) {
			remainderMap.set(sum % k, i)
		}
	}

	return false
}
```

### Python

```python
#We are basically storing sum%k and storing it in the hashmap and checking it.
#Math logic is that the overall sum will get cancelled out because of modulo

class Solution:
    def checkSubarraySum(self, nums: List[int], k: int) -> bool:
        hashmap = {}
        hashmap[0]=-1
        summ=0
        for i,j in enumerate(nums):
            summ+=j
            if summ%k in hashmap.keys():
                if i-hashmap[summ%k]>=2:
                    return True
                else:
                    continue
            hashmap[summ%k]=i
        return False


```

### C++

```cpp
class Solution {
public:
    bool checkSubarraySum(vector<int>& nums, int k) {
        unordered_map<int,int>m;
        m[0] = -1;
        int sum = 0;

        for(int i = 0;i < nums.size();i++){
            sum += nums[i];
            if(k != 0){
                sum %= k;
            }

            if(m.count(sum) > 0){
                if(i - m[sum] > 1) return true;
            }
            else{
                m[sum] = i;
            }

        }
        return false;
    }
};

```

### Java

```java
//We are basically storing sum%k and storing it in the hashmap and checking it.
//Math logic is that the overall sum will get cancelled out because of modulo

class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        HashMap<Integer, Integer> map = new HashMap<>();
        map.put(0, -1);
        int sum = 0;
        for (int i = 0; i<nums.length; i++) {
            sum += nums[i];
            int rem = sum%k;
            if (map.containsKey(rem))
                if (i - map.get(rem)>=2)
                    return true;
            if (!map.containsKey(rem))
                map.put(rem, i);
        }
        return false;
    }
}

```
