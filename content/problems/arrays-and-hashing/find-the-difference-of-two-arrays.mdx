---
title: Find the Difference of Two Arrays
category: Arrays And Hashing
difficulty: Easy
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/find-the-difference-of-two-arrays)

</Callout>

## Description
Given two 0-indexed integer arrays <code>nums1</code> and <code>nums2</code>, return *a list* <code>answer</code> *of size* <code>2</code> *where:*


	- <code>answer[0]</code> *is a list of all distinct integers in* <code>nums1</code> *which are not present in* <code>nums2</code>*.*
	- <code>answer[1]</code> *is a list of all distinct integers in* <code>nums2</code> *which are not present in* <code>nums1</code>.


Note that the integers in the lists may be returned in any order.

 
Example 1:

<br /><pre className="overflow-x-auto">
Input: nums1 = [1,2,3], nums2 = [2,4,6]
Output: [[1,3],[4,6]]
Explanation:
For nums1, nums1[1] = 2 is present at index 0 of nums2, whereas nums1[0] = 1 and nums1[2] = 3 are not present in nums2. Therefore, answer[0] = [1,3].
For nums2, nums2[0] = 2 is present at index 1 of nums1, whereas nums2[1] = 4 and nums2[2] = 6 are not present in nums2. Therefore, answer[1] = [4,6].</pre>

Example 2:

<br /><pre className="overflow-x-auto">
Input: nums1 = [1,2,3,3], nums2 = [1,1,2,2]
Output: [[3],[]]
Explanation:
For nums1, nums1[2] and nums1[3] are not present in nums2. Since nums1[2] == nums1[3], their value is only included once and answer[0] = [3].
Every integer in nums2 is present in nums1. Therefore, answer[1] = [].
</pre>

 
Constraints:


	- <code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code>
	- <code>-1000 &lt;= nums1[i], nums2[i] &lt;= 1000</code>



## Solution

### Javascript
```javascript
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[][]}
 */

// Time Complexity: O(m + n), we check each element of nums1Set and nums2Set
// Space Complexity: O(m + n), where m and n are length sets in worst case.

var findDifference = function (nums1, nums2) {
    const nums1Set = new Set(nums1);
    const nums2Set = new Set(nums2);

    const lst1 = Array.from(nums1Set).filter((num) => !nums2Set.has(num));
    const lst2 = Array.from(nums2Set).filter((num) => !nums1Set.has(num));

    return [lst1, lst2];
};

```
### Python
```python
# Time Complexity: O(m + n), we check each element of nums1Set and nums2Set
# Space Complexity: O(m + n), where m and n are length sets in worst case.

from typing import List  # ignore this, just for typing


class Solution:
    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:
        nums1_set = set(nums1)
        nums2_set = set(nums2)

        lst1 = [num for num in nums1_set if num not in nums2_set]
        lst2 = [num for num in nums2_set if num not in nums1_set]

        return [lst1, lst2]

```
### C++
```cpp
// Time Complexity: O(m + n), we check each element of nums1Set and nums2Set
// Space Complexity: O(m + n), where m and n are length sets in worst case.

class Solution
{
public:
    vector<vector<int>> findDifference(vector<int> &nums1, vector<int> &nums2)
    {
        unordered_set<int> nums1Set(nums1.begin(), nums1.end());
        unordered_set<int> nums2Set(nums2.begin(), nums2.end());

        vector<int> lst1;
        vector<int> lst2;

        for (const auto &num : nums1Set)
        {
            if (nums2Set.find(num) == nums2Set.end())
            {
                lst1.push_back(num);
            }
        }

        for (const auto &num : nums2Set)
        {
            if (nums1Set.find(num) == nums1Set.end())
            {
                lst2.push_back(num);
            }
        }

        return {lst1, lst2};
    }
};
```
### Java
```java
class Solution {
    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {
        List<List<Integer>> res = new ArrayList<>();

        List<Integer> num1 = new ArrayList<>();
        for(int n: nums1) num1.add(n);

        List<Integer> num2 = new ArrayList<>();
        for(int n: nums2) num2.add(n);

        Set<Integer> set1 = new HashSet<>();
        Set<Integer> set2 = new HashSet<>();

        //Because we need to return result in 2 list of the result list, therefore we are creating these placeholders
        res.add(new ArrayList<>()); 
        res.add(new ArrayList<>());

        for(int i=0; i<nums1.length; i++){
            if(!num2.contains(nums1[i])) set1.add(nums1[i]);
        }

        for(int i=0; i<nums2.length; i++){
            if(!num1.contains(nums2[i])) set2.add(nums2[i]);
        }

        for(int n: set1) res.get(0).add(n);

        for(int n: set2) res.get(1).add(n);

        return res;
    }
}

```


