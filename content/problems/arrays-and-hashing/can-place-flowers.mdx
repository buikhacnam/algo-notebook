---
title: Can Place Flowers
category: Arrays And Hashing
difficulty: Easy
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/can-place-flowers)

</Callout>

## Description
You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.

Given an integer array <code>flowerbed</code> containing <code>0</code>&#39;s and <code>1</code>&#39;s, where <code>0</code> means empty and <code>1</code> means not empty, and an integer <code>n</code>, return <code>true</code> *if* <code>n</code> *new flowers can be planted in the* <code>flowerbed</code> *without violating the no-adjacent-flowers rule and* <code>false</code> *otherwise*.

 
Example 1:
<br /><pre className="overflow-x-auto">Input: flowerbed = [1,0,0,0,1], n = 1
Output: true
</pre>Example 2:
<br /><pre className="overflow-x-auto">Input: flowerbed = [1,0,0,0,1], n = 2
Output: false
</pre>
 
Constraints:


	- <code>1 &lt;= flowerbed.length &lt;= 2 * 10<sup>4</sup></code>
	- <code>flowerbed[i]</code> is <code>0</code> or <code>1</code>.
	- There are no two adjacent flowers in <code>flowerbed</code>.
	- <code>0 &lt;= n &lt;= flowerbed.length</code>



## Solution

### Javascript
```javascript
// time complexity is O(n). 

var canPlaceFlowers = function(flowerbed, n) {
    
    for(let i = 0; i < flowerbed.length; i++) {
        if(flowerbed[i] === 0) {
            if((flowerbed[i-1] === 0 && flowerbed[i+1] === 0) || 
               (flowerbed[i-1] === undefined && flowerbed[i+1] === 0) || 
                (flowerbed[i+1] === undefined && flowerbed[i-1] === 0) || 
                (flowerbed[i-1] === undefined && flowerbed[i+1] === undefined && flowerbed[i] === 0)) {

                flowerbed[i] = 1;
                n--;
            } 
        }
    }

    return n > 0 ? false : true;
};

```
### Python
```python
class Solution:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
        # Solution with O(1) space complexity
        empty = 0 if flowerbed[0] else 1

        for f in flowerbed:
           if f:
               n -= int((empty - 1) / 2)  # int division, round toward zero
               empty = 0
           else:
               empty += 1

        n -= (empty) // 2
        return n <= 0
        
class Solution2:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
       # Another solution with O(1) space complexity
       for i in range(len(flowerbed)):
            if n == 0:
                return True
            if ((i == 0 or flowerbed[i - 1] == 0)   # If at the first element or the previous element equals to 0
                and (flowerbed[i] == 0)             # If current element equals to 0
                and (i == len(flowerbed) - 1 or flowerbed[i + 1] == 0)): # If at the last element or the next element equals to 0
                # Place flower at the current position
                flowerbed[i] = 1
                n -= 1

       return n == 0
       
class Solution3:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
       # Solution with O(n) space complexity
       f = [0] + flowerbed + [0]
       
       for i in range(1, len(f) - 1):  # skip first & last
           if f[i - 1] == 0 and f[i] == 0 and f[i + 1] == 0:
               f[i] = 1
               n -= 1
       return n <= 0

```
### C++
```cpp
class Solution {
public:
    bool canPlaceFlowers(vector<int>& flowerbed, int n) {
        // pre-check, if n is 0 ... return true
        if(n == 0){
            return true;
        }
        
        // add a zero to the front and end of FB
        flowerbed.insert (flowerbed.begin(),0);
        flowerbed.push_back(0);

        // iterate through vector (1, vector -1) (for)
        //  if prev, curr, and next are 0
        //      plant flower (1)
        //      decrement n
        for(int i = 1; i < flowerbed.size() - 1; i++){
            if (flowerbed[i - 1] == 0 && flowerbed[i] == 0 && flowerbed[i+1] == 0){
                flowerbed[i] = 1;
                n--;
            }
            if (n == 0){
                return true;
            }

        }

        // return false as else
        return false;

    }
};

```
### Java
```java
class Solution {
    public boolean canPlaceFlowers(int[] flowerbed, int n) {
        int size = flowerbed.length;
        if(n==0) return true;
        for(int i=0; i<size; i++){
            if(flowerbed[i]==0 && (i==0 || flowerbed[i-1]==0) && (i==size-1 || flowerbed[i+1]==0)){
                n--;
                if(n==0) return true;
                flowerbed[i]=1;
            }
        }
        return false;
    }
}

```


