---
title: Word Pattern
category: Arrays And Hashing
difficulty: Easy
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/word-pattern)

</Callout>

## Description
Given a <code>pattern</code> and a string <code>s</code>, find if <code>s</code> follows the same pattern.

Here <b>follow</b> means a full match, such that there is a bijection between a letter in <code>pattern</code> and a <b>non-empty</b> word in <code>s</code>.

 
Example 1:

<br /><pre className="overflow-x-auto">
Input: pattern = &quot;abba&quot;, s = &quot;dog cat cat dog&quot;
Output: true
</pre>

Example 2:

<br /><pre className="overflow-x-auto">
Input: pattern = &quot;abba&quot;, s = &quot;dog cat cat fish&quot;
Output: false
</pre>

Example 3:

<br /><pre className="overflow-x-auto">
Input: pattern = &quot;aaaa&quot;, s = &quot;dog cat cat dog&quot;
Output: false
</pre>

 
Constraints:


	- <code>1 &lt;= pattern.length &lt;= 300</code>
	- <code>pattern</code> contains only lower-case English letters.
	- <code>1 &lt;= s.length &lt;= 3000</code>
	- <code>s</code> contains only lowercase English letters and spaces <code>&#39; &#39;</code>.
	- <code>s</code> does not contain any leading or trailing spaces.
	- All the words in <code>s</code> are separated by a single space.



## Solution

### Javascript
```javascript
// problem link https://leetcode.com/problems/word-pattern
// time coplexity O(n)
// space complexity O(n)

var wordPattern = function(pattern, s) {
    
s = s.split(' ');

if(s.length !== pattern.length) return false;

wordToChar = new Map();
charToWord = new Map();

for(let i = 0; i < pattern.length; i++) {
    wordToChar.set(s[i], pattern[i]);
    charToWord.set(pattern[i], s[i]);
};


for(let i = 0; i < pattern.length; i++)  {
    if(charToWord.get(pattern[i]) !== s[i] || pattern[i] !== wordToChar.get(s[i])) {
        return false;
    }
}

return true;
};

```
### Python
```python
class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        words = s.split(" ")
        if len(pattern) != len(words):
            return False
        charToWord = {}
        wordToChar = {}
        
        for c, w in zip(pattern, words):
            if c in charToWord and charToWord[c] != w:
                return False
            if w in wordToChar and wordToChar[w] != c:
                return False
            charToWord[c] = w
            wordToChar[w] = c
        return True

```
### C++
```cpp
class Solution {
public:
    bool wordPattern(string pattern, string str) {
        vector<int> pat_map (26, 0);
        unordered_map<string,int> str_map;
        int i=0, n = pattern.size();
        istringstream ss (str);
        string token;
        
        for(string token; ss >> token; ++i) {
            if(i == n || pat_map[pattern[i]-'a'] != str_map[token]) return false;
            
            // 1-based indexing since map assigns 0 as a default value for keys not found.
            pat_map[pattern[i]-'a'] = str_map[token] = i+1;
        }
        
        return i == n;
    }
};

```
### Java
```java
class Solution {
    public boolean wordPattern(String pattern, String s) {
        String[] sArray = s.split("\s");
        if(sArray.length != pattern.length()) {
            return false;
        }
        
        HashMap<Character,String> charToWord = new HashMap<>();
        HashMap<String,Character> wordToChar = new HashMap<>();
        
        for (int i = 0; i < pattern.length(); i++) {
        
            if(charToWord.containsKey(pattern.charAt(i)) && !charToWord.get(pattern.charAt(i)).equals(sArray[i])) {
                return false;
            }
            
            if(wordToChar.containsKey(sArray[i]) && !wordToChar.get(sArray[i]).equals(pattern.charAt(i))) {
                return false;
            }
            
            charToWord.put(pattern.charAt(i),sArray[i]);
            wordToChar.put(sArray[i],pattern.charAt(i));
        }
        return true;    
    }
}

```


