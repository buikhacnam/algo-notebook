---
title: Repeated DNA Sequences
category: Arrays And Hashing
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/repeated-dna-sequences)

</Callout>

## Description
The DNA sequence is composed of a series of nucleotides abbreviated as <code>&#39;A&#39;</code>, <code>&#39;C&#39;</code>, <code>&#39;G&#39;</code>, and <code>&#39;T&#39;</code>.


	- For example, <code>&quot;ACGAATTCCG&quot;</code> is a DNA sequence.


When studying DNA, it is useful to identify repeated sequences within the DNA.

Given a string <code>s</code> that represents a DNA sequence, return all the <code>10</code>-letter-long sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in any order.

 
Example 1:
<br /><pre className="overflow-x-auto">Input: s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"
Output: ["AAAAACCCCC","CCCCCAAAAA"]
</pre>Example 2:
<br /><pre className="overflow-x-auto">Input: s = "AAAAAAAAAAAAA"
Output: ["AAAAAAAAAA"]
</pre>
 
Constraints:


	- <code>1 &lt;= s.length &lt;= 10<sup>5</sup></code>
	- <code>s[i]</code> is either <code>&#39;A&#39;</code>, <code>&#39;C&#39;</code>, <code>&#39;G&#39;</code>, or <code>&#39;T&#39;</code>.



## Solution

### Javascript
```javascript
/**
 * https://leetcode.com/problems/repeated-dna-sequences/
 * Hashing
 * s = the number of letters in the sequence. In our case, it's 10. so the time complexity would be 10*n which boils down to n.
 * Time O(n) | Space O(n)
 * @param {string} s
 * @return {string[]}
 */
var findRepeatedDnaSequences = function (s) {
    const sequenceSet = new Set();
    let resultSet = new Set();

    for (let i = 0; i < s.length; i++) {
        const subSequence = getSubSequence(s, i, 10);
        if (sequenceSet.has(subSequence)) {
            resultSet.add(subSequence);
        } else {
            sequenceSet.add(subSequence);
        }
    }

    resultSet = [...resultSet];
    return resultSet;
};

function getSubSequence(s, i, len) {
    return s.slice(i, i + len);
}

// an alternative code with the same approach.
/**
 * https://leetcode.com/problems/repeated-dna-sequences/
 * Hashing
 * s = the number of letters in the sequence. In our case, it's 10. so the time complexity would be 10*n which boils down to n.
 * Time O(n) | Space O(n)
 * @param {string} s
 * @return {string[]}
 */
var findRepeatedDnaSequences1 = function (s) {
    const seen = new Set();
    const res = new Set();
    const arr = Array.from(s);

    for (let l = 0; l < arr.length - 9; l++) {
        const sequence = s.slice(l, l + 10);

        if (seen.has(sequence)) {
            res.add(sequence);
        } else {
            seen.add(sequence);
        }
    }

    return Array.from(res);
};

```
### Python
```python
class Solution:
    def findRepeatedDnaSequences(self, s: str) -> list[str]:
        result = set()
        previous_sequences = set()
        for i in range(len(s) - 9):
            current = s[i:i+10]
            if current in previous_sequences:
                result.add(current)
            previous_sequences.add(current)
        return list(result)

```
### C++
```cpp
class Solution {
public:
    vector<string> findRepeatedDnaSequences(string s) {

        int n = s.size();
        if(n <=10){ return {};}
        vector<string> answer;

        unordered_map<string,int> hash;

        for(int i = 0;i<=s.size()-10;i++){
            string ss = s.substr(i,10);
            hash[ss]++;
            if(hash[ss]==2){
                answer.push_back(ss);
            }
        }

        return answer;
    }
};
```
### Java
```java
class Solution {

    public List<String> findRepeatedDnaSequences(String s) {
        HashSet<String> set = new HashSet<>();
        int start = 0;
        HashSet<String> ans = new HashSet<>();
        for (int end = 10; end <= s.length(); end++) {
            if (set.contains(s.substring(start, end))) ans.add(
                s.substring(start, end)
            );
            set.add(s.substring(start, end));
            start++;
        }
        List<String> list = new ArrayList<>(ans);
        return list;
    }
}

```


