---
title: Pascal's Triangle
category: Arrays And Hashing
difficulty: Easy
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/pascals-triangle)

</Callout>

## Description
Given an integer <code>numRows</code>, return the first numRows of Pascal&#39;s triangle.

In Pascal&#39;s triangle, each number is the sum of the two numbers directly above it as shown:
<Image alt="" src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" height:240} width:260px" />
 
Example 1:
<br /><pre className="overflow-x-auto">Input: numRows = 5
Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
</pre>Example 2:
<br /><pre className="overflow-x-auto">Input: numRows = 1
Output: [[1]]
</pre>
 
Constraints:


	- <code>1 &lt;= numRows &lt;= 30</code>



## Solution

### Javascript
```javascript

// link to the problem https://leetcode.com/problems/pascals-triangle/
// the time complexity will basically be the number of elements in pascale tringle. roughly height of tringle * number of honeycomb in each row.
// O(n^2);

var generate = function(num) {
    
    const outerArray = [];
    // adding first two rows of pascals triangle
    if (num >= 2) {
      outerArray.push([1]);
      outerArray.push([1, 1]);
    } else {
      outerArray.push([1]);
    }
  
    // will  only run if we had number greater than 2
    if (num > 2) {
      for (let i = 2; i < num; i++) {
        let subArray = [];
         subArray.push(1);
        for (let j = 0; j < outerArray[i - 1].length - 1; j++) {
          subArray.push(outerArray[i - 1][j] + outerArray[i - 1][j + 1]);
        }
        subArray.push(1);
        outerArray.push(subArray);
      }
    }
  
    return outerArray;
 };

```
### Python
```python
class Solution:
    def generate(self, rowIndex) -> List[List[int]]:
        if rowIndex == 0:
            return [[1]]
        else:
            return self.getAllRow(rowIndex - 1)

    def getAllRow(self, rowIndex):
        if rowIndex == 0:
            return [[1]]
        ListPrec = self.getAllRow(rowIndex - 1)
        Len = len(ListPrec[-1])
        ListPrec.append([1])
        for i in range(0, Len - 1):
            ListPrec[-1].append(ListPrec[-2][i] + ListPrec[-2][i + 1])
        ListPrec[-1].append(1)
        return ListPrec

```
### C++
```cpp
class Solution {
public:
    vector<vector<int>> generate(int numRows)
    {
        vector<vector<int>> ret;

        for(int i = 0; i < numRows ; i++){
            vector<int> row(i+1, 1);
            for(int j = 1; j < i ; j++){
                row[j] = ret[i-1][j] + ret[i-1][j-1];
            }
            ret.push_back(row);
        }

        return ret;
    }
};
```
### Java
```java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        
        List<List<Integer>> res = new ArrayList<>();
        
        for(int i=0; i<numRows; i++){
            List<Integer> list = new ArrayList<>();
            
            for(int j=0; j<=i; j++){
                if(j>0 && i>0 && res.get(i-1).size()-1>=j){
                    list.add(res.get(i-1).get(j-1)+res.get(i-1).get(j));
                } else{
                    list.add(1);
                }
            }
            res.add(list);
        }
        
        return res;
        
    }
}
```


