---
title: Combination Sum IV
category: 1d Dynamic Programming
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/combination-sum-iv)

</Callout>

## Description
Given an array of distinct integers <code>nums</code> and a target integer <code>target</code>, return *the number of possible combinations that add up to* <code>target</code>.

The test cases are generated so that the answer can fit in a 32-bit integer.

 
Example 1:

<br /><pre className="overflow-x-auto">
Input: nums = [1,2,3], target = 4
Output: 7
Explanation:
The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
Note that different sequences are counted as different combinations.
</pre>

Example 2:

<br /><pre className="overflow-x-auto">
Input: nums = [9], target = 3
Output: 0
</pre>

 
Constraints:


	- <code>1 &lt;= nums.length &lt;= 200</code>
	- <code>1 &lt;= nums[i] &lt;= 1000</code>
	- All the elements of <code>nums</code> are unique.
	- <code>1 &lt;= target &lt;= 1000</code>


 
Follow up: What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?


## Solution

### Javascript
```javascript
404: Not Found
```
### Python
```python
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        cache = {0: 1}

        for total in range(1, target + 1):
            cache[total] = 0
            for n in nums:
                cache[total] += cache.get(total - n, 0)
        return cache[target]

        def dfs(total):
            if total == target:
                return 1
            if total > target:
                return 0
            if total in cache:
                return cache[total]

            cache[total] = 0
            for n in nums:
                cache[total] += dfs(total + n)
            return cache[total]

        return dfs(0)

```
### C++
```cpp
/*
    Given an array of distinct integers nums and a target integer 'target', 
    return the number of possible combinations that add up to target.
    
    Ex. nums = [1,2,3] target = 4
    Possible Combinations: (1,1,1,1) (1,1,2) (1,2,1) (1,3) (2,1,1,)
    (2,2) (3,1). 
    So, total number of combinations possible is 7.

    Time: O(n * m)
    Space: O(m)
*/

class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
    sort(nums.begin(), nums.end());
    vector<unsigned int> dp(target+1, 0);
    dp[0] = 1;
    for(int total=1; total<=target; total++) {
        for(int i=0; i<nums.size(); i++) {
            if(nums[i] <= total) dp[total] += dp[total - nums[i]];
            else break;
        }
    }
    return dp[target];
    }
};
```
### Java
```java
404: Not Found
```


