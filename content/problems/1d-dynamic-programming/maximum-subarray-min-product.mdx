---
title: Maximum Subarray Min-Product
category: 1d Dynamic Programming
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/maximum-subarray-min-product)

</Callout>

## Description
The min-product of an array is equal to the minimum value in the array multiplied by the array&#39;s sum.


	- For example, the array <code>[3,2,5]</code> (minimum value is <code>2</code>) has a min-product of <code>2 * (3+2+5) = 2 * 10 = 20</code>.


Given an array of integers <code>nums</code>, return *the maximum min-product of any non-empty subarray of *<code>nums</code>. Since the answer may be large, return it modulo <code>10<sup>9</sup> + 7</code>.

Note that the min-product should be maximized before performing the modulo operation. Testcases are generated such that the maximum min-product without modulo will fit in a 64-bit signed integer.

A subarray is a contiguous part of an array.

 
Example 1:

<br /><pre className="overflow-x-auto">
Input: nums = [1,<u>2,3,2</u>]
Output: 14
Explanation: The maximum min-product is achieved with the subarray [2,3,2] (minimum value is 2).
2 * (2+3+2) = 2 * 7 = 14.
</pre>

Example 2:

<br /><pre className="overflow-x-auto">
Input: nums = [2,<u>3,3</u>,1,2]
Output: 18
Explanation: The maximum min-product is achieved with the subarray [3,3] (minimum value is 3).
3 * (3+3) = 3 * 6 = 18.
</pre>

Example 3:

<br /><pre className="overflow-x-auto">
Input: nums = [3,1,<u>5,6,4</u>,2]
Output: 60
Explanation: The maximum min-product is achieved with the subarray [5,6,4] (minimum value is 4).
4 * (5+6+4) = 4 * 15 = 60.
</pre>

 
Constraints:


	- <code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code>
	- <code>1 &lt;= nums[i] &lt;= 10<sup>7</sup></code>



## Solution

### Javascript
```javascript
404: Not Found
```
### Python
```python
404: Not Found
```
### C++
```cpp
404: Not Found
```
### Java
```java
class Solution {
    public int maxSumMinProduct(int[] nums) {
        Stack<long[]> stack = new Stack<>(); // index, value
        long[] pre = new long[nums.length];
        pre[0] = nums[0];
        long res = 0, mod = (int) 1e9 + 7;
        for (int i = 1; i < nums.length; i++) {
            pre[i] = pre[i - 1] + nums[i];
        }
        for (int i = 0; i < nums.length; i++) {
            int idx = i;
            while (stack.size() != 0 && nums[i] < stack.peek()[1]) {
                long[] t = stack.pop();
                int start = (int) t[0];
                long value = t[1];
                long sum = pre[i - 1] - ((start - 1) < 0 ? 0 : pre[start - 1]);
                res = Math.max(res, (value * sum));
                idx = start;
            }
            stack.push(new long[] { idx, nums[i] });
        }
        while (stack.size() != 0) {
            long[] t = stack.pop();
            int start = (int) t[0];
            long value = t[1];
            long sum = pre[nums.length - 1] - ((start - 1) < 0 ? 0 : pre[start - 1]);
            res = Math.max(res, (value * sum));
        }
        return (int) ((res + mod) % mod);
    }
}
```


