---
title: Palindrome Linked List
category: Linked List
difficulty: Easy
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/palindrome-linked-list)

</Callout>

## Description
Given the <code>head</code> of a singly linked list, return <code>true</code>* if it is a *<span data-keyword="palindrome-sequence">*palindrome*</span>* or *<code>false</code>* otherwise*.

 
Example 1:
<Image alt="" src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" width={422} height={62} />
<br /><pre className="overflow-x-auto">
Input: head = [1,2,2,1]
Output: true
</pre>

Example 2:
<Image alt="" src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" width={182} height={62} />
<br /><pre className="overflow-x-auto">
Input: head = [1,2]
Output: false
</pre>

 
Constraints:


	- The number of nodes in the list is in the range <code>[1, 10<sup>5</sup>]</code>.
	- <code>0 &lt;= Node.val &lt;= 9</code>


 
Follow up: Could you do it in <code>O(n)</code> time and <code>O(1)</code> space?

## Solution

### Javascript
```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var isPalindrome = function (head) {
    // find mid point
    let slow = head;
    let fast = head;
    while (fast && fast.next) {
        slow = slow.next;
        fast = fast.next.next;
    }

    // reverse 2nd half
    let curr = slow;
    let prev = null;
    while (curr) {
        let next = curr.next;
        curr.next = prev;
        prev = curr;
        curr = next;
    }
    let head2 = prev;

    // compare both halfs
    while (head && head2) {
        if (head.val !== head2.val) {
            return false;
        }

        head = head.next;
        head2 = head2.next;
    }

    return true;
};

```
### Python
```python
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        fast = head
        slow = head
        
        # find the middle (slow)
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
            
        # reverse second half
        prev = None
        while slow:
            tmp = slow.next
            slow.next = prev
            prev = slow
            slow = tmp
        
        # check palindrome
        left, right = head, prev
        while right:
            if left.val != right.val:
                return False
            left = left.next
            right = right.next
        return True

```
### C++
```cpp
class Solution{    
    public:    
        bool isPalindrome(ListNode* head){            
            vector<int> v;            
            while(head != nullptr){                
                v.push_back(head -> val);                
                head = head -> next;              
            }         
            for(int i = 0; i < v.size() / 2; i++){                
                if(v[i] != v[v.size() - i - 1]){                    
                    return false;                    
                }                
            }            
            return true;
        }    
};

```
### Java
```java
//reverse the later half
//after reversing just start comparing if at any time the value doesn't match it's not a palindrome, i.e. return false, else it's a palindrome and return true.
//It'll automatically take care of the edge cases of odd and even

class Solution {

    public boolean isPalindrome(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        ListNode temp = reverse(slow);
        while (temp != null && head != null) {
            if (temp.val != head.val) return false;
            temp = temp.next;
            head = head.next;
        }
        return true;
    }

    public ListNode reverse(ListNode head) {
        ListNode p = null;
        ListNode q = null;
        ListNode r = head;
        while (r != null) {
            p = q;
            q = r;
            r = r.next;
            q.next = p;
        }
        return q;
    }
}

```


