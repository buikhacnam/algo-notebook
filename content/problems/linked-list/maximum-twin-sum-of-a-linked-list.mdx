---
title: Maximum Twin Sum of a Linked List
category: Linked List
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list)

</Callout>

## Description

In a linked list of size <code>n</code>, where <code>n</code> is even, the <code>i<sup>th</sup></code> node (0-indexed) of the linked list is known as the twin of the <code>(n-1-i)<sup>th</sup></code> node, if <code>0 &lt;= i &lt;= (n / 2) - 1</code>.

    - For example, if <code>n = 4</code>, then node <code>0</code> is the twin of node <code>3</code>, and node <code>1</code> is the twin of node <code>2</code>. These are the only nodes with twins for <code>n = 4</code>.

The twin sum is defined as the sum of a node and its twin.

Given the <code>head</code> of a linked list with even length, return _the maximum twin sum of the linked list_.

Example 1:

<Image
	alt=""
	src="https://assets.leetcode.com/uploads/2021/12/03/eg1drawio.png"
	width={250}
	height={70}
/>
<br />
<pre className="overflow-x-auto">
	Input: head = [5,4,2,1] Output: 6 Explanation: Nodes 0 and 1 are the twins of
	nodes 3 and 2, respectively. All have twin sum = 6. There are no other nodes
	with twins in the linked list. Thus, the maximum twin sum of the linked list
	is 6.
</pre>

Example 2:

<Image
	alt=""
	src="https://assets.leetcode.com/uploads/2021/12/03/eg2drawio.png"
	width={250}
	height={70}
/>
<br />
<pre className="overflow-x-auto">
	Input: head = [4,2,2,3] Output: 7 Explanation: The nodes with twins present in
	this linked list are: - Node 0 is the twin of node 3 having a twin sum of 4 +
	3 = 7. - Node 1 is the twin of node 2 having a twin sum of 2 + 2 = 4. Thus,
	the maximum twin sum of the linked list is max(7, 4) = 7.
</pre>

Example 3:

<Image
	alt=""
	src="https://assets.leetcode.com/uploads/2021/12/03/eg3drawio.png"
	width={200}
	height={88}
/>
<br />
<pre className="overflow-x-auto">
	Input: head = [1,100000] Output: 100001 Explanation: There is only one node
	with a twin in the linked list having twin sum of 1 + 100000 = 100001.
</pre>

Constraints:

    - The number of nodes in the list is an even integer in the range <code>[2, 10<sup>5</sup>]</code>.
    - <code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code>

## Solution

### Javascript

```javascript
Solution will be updated soon
```

### Python

```python
class Solution:
    def pairSum(self, head: Optional[ListNode]) -> int:
        slow, fast = head, head
        prev = None
        while fast and fast.next:
            fast = fast.next.next
            tmp = slow.next
            slow.next = prev
            prev = slow
            slow = tmp

        res = 0
        while slow:
            res = max(res, prev.val + slow.val)
            prev = prev.next
            slow = slow.next
        return res

```

### C++

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */

// Time: O(n)
// Space: O(1)
class Solution {
public:
    int pairSum(ListNode* head) {
        ListNode *fast = head, *slow = head;

        while(fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        slow = reverseList(slow);

        int mx = 0;
        while(head && slow) {
            mx = max(mx, head->val + slow->val);
            head = head->next;
            slow = slow->next;
        }

        return mx;
    }
private:
    ListNode* reverseList(ListNode* head) {
        ListNode* prev = NULL;
        ListNode* curr = head;
        ListNode* NEXT = NULL;

        while(curr) {
            NEXT = curr->next;
            curr->next = prev;
            prev = curr;
            curr = NEXT;
        }

        return prev;
    }
};

```

### Java

```java
//The basic idea is to use the slow and fast pointers to find the mid
// Once found we will reverse the second half of the Linkedlist and compare the values

class Solution {
    public ListNode reverse(ListNode head){
        if(head == null) return head;

        ListNode curr = head;
        ListNode prev = null;

        while(curr != null){
            ListNode nxt = curr.next;
            curr.next = prev;
            prev = curr;
            curr = nxt;
        }
        return prev;
    }
    public int pairSum(ListNode head) {
        int mx = Integer.MIN_VALUE;

        ListNode slow=head, fast=head;

        while(fast != null && fast.next != null){
            fast = fast.next.next;
            slow = slow.next;
        }

        ListNode prev = reverse(slow);

        ListNode head1 = head, head2 = prev;
        while(head2 != null){
            mx = Math.max(mx, head1.val+head2.val);
            head1 = head1.next;
            head2 = head2.next;
        }
        return mx;
    }
}

```
