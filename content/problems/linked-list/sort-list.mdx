---
title: Sort List
category: Linked List
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/sort-list)

</Callout>

## Description
Given the <code>head</code> of a linked list, return *the list after sorting it in ascending order*.

 
Example 1:
<Image alt="" src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg" width={450} height={194} />
<br /><pre className="overflow-x-auto">
Input: head = [4,2,1,3]
Output: [1,2,3,4]
</pre>

Example 2:
<Image alt="" src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg" width={550} height={184} />
<br /><pre className="overflow-x-auto">
Input: head = [-1,5,3,4,0]
Output: [-1,0,3,4,5]
</pre>

Example 3:

<br /><pre className="overflow-x-auto">
Input: head = []
Output: []
</pre>

 
Constraints:


	- The number of nodes in the list is in the range <code>[0, 5 * 10<sup>4</sup>]</code>.
	- <code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code>


 
Follow up: Can you sort the linked list in <code>O(n logn)</code> time and <code>O(1)</code> memory (i.e. constant space)?


## Solution

### Javascript
```javascript
404: Not Found
```
### Python
```python
class Solution:
    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return head

        mid = self.get_mid(head)
        left, right = self.sortList(head), self.sortList(mid)

        return self.merge_two_sorted(left, right)


    def merge_two_sorted(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        if not list1:
            return list2

        if not list2:
            return list1

        sentinel = ListNode()
        prev = sentinel
        while list1 and list2:
            if list1.val < list2.val:
                prev.next = list1
                list1 = list1.next
            else:
                prev.next = list2
                list2 = list2.next
            prev = prev.next

        if list1:
            prev.next = list1
        else:
            prev.next = list2

        return sentinel.next


    def get_mid(self, head: Optional[ListNode]) -> Optional[ListNode]:
        mid_prev = None
        while head and head.next:
            mid_prev = mid_prev.next if mid_prev else head
            head = head.next.next

        mid = mid_prev.next
        mid_prev.next = None

        return mid

```
### C++
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
private:
    // find middle of LL using slow and fast pointers
    ListNode* findLLMid(ListNode* head) {
        ListNode* slow = head;
        ListNode* fast = head->next;
        while (fast != NULL && fast->next != NULL) {
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }

    // merges two sorted LLs
    ListNode* merge(ListNode* head1, ListNode* head2) {
        ListNode* dummy = new ListNode();
        ListNode* p = dummy;
        ListNode* p1 = head1;
        ListNode* p2 = head2;

        while (p1 != NULL && p2 != NULL) {
            if (p1->val < p2->val) {
                ListNode* temp = p1->next;
                p->next = p1;
                p1->next = NULL;
                p1 = temp;
            } else {
                ListNode* temp = p2->next;
                p->next = p2;
                p2->next = NULL;
                p2 = temp;
            }
            p = p->next;
        }

        if (p1 == NULL) {
            p->next = p2;
        } else if (p2 == NULL) {
            p->next = p1;
        }

        return dummy->next;
    }
public:
    // merge sort implementation
    ListNode* sortList(ListNode* head) {
        // base cases
        if (head == NULL)
            return NULL;
        if (head->next == NULL) 
            return head;
        
        // split LL into two halves
        ListNode* middleOfLL = findLLMid(head);
        ListNode* leftHalf = head;
        ListNode* rightHalf = middleOfLL->next;
        middleOfLL->next = NULL; // this cuts off the right half from the left half

        // sort the two halves seperately and then merge them into one 
        leftHalf = sortList(leftHalf); 
        rightHalf = sortList(rightHalf);
        head = merge(leftHalf, rightHalf);

        return head;
    }
};
```
### Java
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    // Merge Sort Implementation
    public ListNode getMid(ListNode head){
        ListNode slow=head, fast=head.next;
        while(fast != null && fast.next != null){
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow;
    }
    public ListNode merge(ListNode left, ListNode right){
        ListNode dummy = new ListNode();
        ListNode tail = dummy;

        while(left != null && right != null){
            if(left.val < right.val){
                tail.next = left;
                left = left.next;
            }else{
                tail.next = right;
                right = right.next;
            }
            tail = tail.next;
        }
        if(left != null){
            tail.next = left;
        }
        if(right != null){
            tail.next = right;
        }
        return dummy.next;
    }
    public ListNode sortList(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }

        // Split the list in 2 halfs
        ListNode left = head;
        ListNode right = getMid(head);
        ListNode tmp = right.next;
        right.next = null;
        right = tmp;

        left = sortList(left);
        right = sortList(right);
        return merge(left, right);
    }
}

// Using a Heap to sort the list
class Solution {
    public ListNode sortList(ListNode head) {
        if(head == null || head.next == null){
            return head;
        }
        PriorityQueue<Integer> queue = new PriorityQueue<>();
        ListNode temp = head;
        while(temp.next!=null){
            queue.add(temp.val);
            temp = temp.next;
        }
        queue.add(temp.val);
        temp = head;
        while(!queue.isEmpty()){
            temp.val = queue.poll();
            temp = temp.next;
        }
        return head;  
    }
}

```


