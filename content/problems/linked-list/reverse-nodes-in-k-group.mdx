---
title: Reverse Nodes in k-Group
category: Linked List
difficulty: Hard
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/reverse-nodes-in-k-group)

</Callout>

## Description
Given the <code>head</code> of a linked list, reverse the nodes of the list <code>k</code> at a time, and return *the modified list*.

<code>k</code> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of <code>k</code> then left-out nodes, in the end, should remain as it is.

You may not alter the values in the list&#39;s nodes, only nodes themselves may be changed.

 
Example 1:
<Image alt="" src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg" width={542} height={222} />
<br /><pre className="overflow-x-auto">
Input: head = [1,2,3,4,5], k = 2
Output: [2,1,4,3,5]
</pre>

Example 2:
<Image alt="" src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg" width={542} height={222} />
<br /><pre className="overflow-x-auto">
Input: head = [1,2,3,4,5], k = 3
Output: [3,2,1,4,5]
</pre>

 
Constraints:


	- The number of nodes in the list is <code>n</code>.
	- <code>1 &lt;= k &lt;= n &lt;= 5000</code>
	- <code>0 &lt;= Node.val &lt;= 1000</code>


 
Follow-up: Can you solve the problem in <code>O(1)</code> extra memory space?


## Solution

### Javascript
```javascript
/**
 * https://leetcode.com/problems/reverse-nodes-in-k-group/
 * Time O(N) | Space O(N)
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
 var reverseKGroup = function(head, k) {
    const sentinel = tail = new ListNode(0, head);

    while (true) {
        let [ start, last ]= moveNode(tail, k);
        if (!last) break;

        reverse([ start, tail.next, start ])

        const next = tail.next;
        tail.next = last;
        tail = next;
    }

    return sentinel.next;
};

const moveNode = (curr, k) => {
    const canMove = () => k && curr;
    while (canMove()) {
        curr = curr.next;
        k--;
    }

    return [ (curr?.next || null), curr ];
}

const reverse = ([ prev, curr, start ]) => {
    const isSame = () => curr === start;
    while (!isSame()) {
        const next = curr.next;
        curr.next = prev;

        prev = curr;
        curr = next;
    }
}

```
### Python
```python
class Solution:
    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:
        dummy = groupPrev = ListNode(0, head)
        
        while True:
            kth = self.getKth(groupPrev, k)
            if not kth:
                break
            groupPrev.next = kth
            groupNext = kth.next

            # reverse group
            prev, curr = groupNext, head
            while curr != groupNext:
                nxt = curr.next
                curr.next = prev
                prev = curr
                curr = nxt

            groupPrev = head
            head = groupNext
        return dummy.next

    def getKth(self, curr, k):
        while curr and k > 0:
            curr = curr.next
            k -= 1
        return curr

```
### C++
```cpp
/*
    Given head of linked list, reverse nodes of list k at a time
    Ex. head = [1,2,3,4,5], k = 2 -> [2,1,4,3,5]

    Maintain prev, curr, & temp pointers to reverse, count k times

    Time: O(n)
    Space: O(1)
*/

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* dummy = new ListNode();
        dummy->next = head;
        
        ListNode* prev = dummy;
        ListNode* curr = dummy->next;
        ListNode* temp = NULL;
        
        int count = k;
        
        while (curr != NULL) {
            if (count > 1) {
                temp = prev->next;
                prev->next = curr->next;
                curr->next = curr->next->next;
                prev->next->next = temp;

                count--;
            } else {
                prev = curr;
                curr = curr->next;
                count = k;
                
                ListNode* end = curr;
                for (int i = 0; i < k; i++) {
                    if (end == NULL) {
                        return dummy->next;
                    }
                    end = end->next;
                }
            }
        }
        
        return dummy->next;
    }
};

```
### Java
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */

//This recursive approach is super intuitive taken from leetcode discuss.

// Time Complexity: O(n)
// Extra Space Complexity: O(n)

class Solution1 {

    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode cur = head;
        int count = 0;
        while (cur != null && count != k) {
            cur = cur.next;
            count++;
        }
        if (count == k) {
            cur = reverseKGroup(cur, k);
            while (count-- > 0) {
                ListNode temp = head.next;
                head.next = cur;
                cur = head;
                head = temp;
            }
            head = cur;
        }
        return head;
    }
}

// An iterative approach

// Time Complexity: O(n)
// Extra Space Complexity: O(1)

class Solution2 {

    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode dummy = new ListNode(0, head);
        ListNode curr = head;
        ListNode prev = dummy;
        ListNode temp = null;

        int count = k;

        while (curr != null) {
            if (count > 1) {
                temp = prev.next;
                prev.next = curr.next;
                curr.next = curr.next.next;
                prev.next.next = temp;

                count--;
            } else {
                prev = curr;
                curr = curr.next;

                ListNode end = curr;

                for (int i = 0; i < k; ++i) {
                    if (end == null) {
                        return dummy.next;
                    }
                    end = end.next;
                }
                count = k;
            }
        }

        return dummy.next;
    }
}

```


