---
title: Reverse Linked List II
category: Linked List
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/reverse-linked-list-ii)

</Callout>

## Description

Given the <code>head</code> of a singly linked list and two integers <code>left</code> and <code>right</code> where <code>left &lt;= right</code>, reverse the nodes of the list from position <code>left</code> to position <code>right</code>, and return _the reversed list_.

Example 1:

<Image
	alt=""
	src="https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg"
	width={542}
	height={222}
/>
<br />

<pre className="overflow-x-auto">
	Input: head = [1,2,3,4,5], left = 2, right = 4 Output: [1,4,3,2,5]
</pre>

Example 2:

<br />

<pre className="overflow-x-auto">
	Input: head = [5], left = 1, right = 1 Output: [5]
</pre>

Constraints:

    - The number of nodes in the list is <code>n</code>.
    - <code>1 &lt;= n &lt;= 500</code>
    - <code>-500 &lt;= Node.val &lt;= 500</code>
    - <code>1 &lt;= left &lt;= right &lt;= n</code>

Follow up: Could you do it in one pass?

## Solution

### Javascript

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} left
 * @param {number} right
 * @return {ListNode}
 */
var reverseBetween = function (head, left, right) {
	if (!head || !head.next || left === right) {
		return head
	}
	let idx = 1
	let prevLower = null
	let curLower = head
	while (curLower && idx < left) {
		prevLower = curLower
		curLower = curLower.next
		idx++
	}
	let storedPrevLower = prevLower
	let storedCurLower = curLower
	let prevPtr = null
	let tmpPtr = null
	while (curLower && idx <= right) {
		tmpPtr = curLower.next
		curLower.next = prevPtr
		prevPtr = curLower
		curLower = tmpPtr
		idx++
	}
	if (storedPrevLower) {
		storedPrevLower.next = prevPtr
	}
	storedCurLower.next = curLower
	return storedPrevLower ? head : prevPtr
}
```

### Python

```python
class Solution:
    def reverseBetween(
        self, head: Optional[ListNode], left: int, right: int
    ) -> Optional[ListNode]:
        dummy = ListNode(0, head)

        # 1) reach node at position "left"
        leftPrev, cur = dummy, head
        for i in range(left - 1):
            leftPrev, cur = cur, cur.next

        # Now cur="left", leftPrev="node before left"
        # 2) reverse from left to right
        prev = None
        for i in range(right - left + 1):
            tmpNext = cur.next
            cur.next = prev
            prev, cur = cur, tmpNext

        # 3) Update pointers
        leftPrev.next.next = cur  # cur is node after "right"
        leftPrev.next = prev  # prev is "right"
        return dummy.next

```

### C++

```cpp
/*
    Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.

    Time complexity: O(n)
    Space complexity: O(1)
*/
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        ListNode* dummy = new ListNode();
        dummy->next = head;

        int i=0;
        ListNode* leftConnector = dummy,*temp = head;
        while(i<left-1){
            leftConnector = temp;
            temp = temp->next;
            i++;
        }
        ListNode* prev = NULL;
        i=0;
        while(i<right-left+1){
            ListNode* store = temp->next;
            temp->next = prev;
            prev = temp;
            temp = store;
            i++;
        }
        leftConnector->next->next = temp;
        leftConnector->next = prev;

        return dummy->next;
    }
};
```

### Java

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
  public ListNode reverseBetween(ListNode head, int left, int right) {

    if (head == null || head.next == null) {
      return head;
    }

    if (left > right || left == right) {
      return head;
    }

    ListNode l = head;
    ListNode prevL = null;
    ListNode r = head;
    ListNode nextR = null;
    int posL = 1;
    int posR = 1;

    while (posL != left) {
      prevL = l;
      l = l.next;
      posL++;
    }

    while (posR != right) {
      r = r.next;
      posR++;
    }

    nextR = r.next;
    r.next = null;
    ListNode node = reverseList(l);
    node.next = nextR;
    if (prevL == null) {
      head = r;
    } else {
      prevL.next = r;
    }
    return head;
  }

  public ListNode reverseList(ListNode l) {
    if (l.next == null) {
      return l;
    }
    ListNode newNode = reverseList(l.next);
    newNode.next = l;
    l.next = null;
    return l;
  }
}

```
