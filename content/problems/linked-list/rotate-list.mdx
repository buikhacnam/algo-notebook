---
title: Rotate List
category: Linked List
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/rotate-list)

</Callout>

## Description
Given the <code>head</code> of a linked list, rotate the list to the right by <code>k</code> places.

 
Example 1:
<Image alt="" src="https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg" width={450} height={191} />
<br /><pre className="overflow-x-auto">
Input: head = [1,2,3,4,5], k = 2
Output: [4,5,1,2,3]
</pre>

Example 2:
<Image alt="" src="https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg" width={305} height={350} />
<br /><pre className="overflow-x-auto">
Input: head = [0,1,2], k = 4
Output: [2,0,1]
</pre>

 
Constraints:


	- The number of nodes in the list is in the range <code>[0, 500]</code>.
	- <code>-100 &lt;= Node.val &lt;= 100</code>
	- <code>0 &lt;= k &lt;= 2 * 10<sup>9</sup></code>



## Solution

### Javascript
```javascript
404: Not Found
```
### Python
```python
class Solution:
    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        if not head or not head.next or k == 0:
            return head

        old_head = head

        curr, size = head, 0
        while curr:
            curr, size = curr.next, size + 1

        if k % size == 0:
            return head

        k %= size
        slow = fast = head
        while fast and fast.next:
            if k <= 0:
                slow = slow.next
            fast = fast.next
            k -= 1

        new_tail, new_head, old_tail = slow, slow.next, fast
        new_tail.next, old_tail.next = None, old_head

        return new_head

```
### C++
```cpp
/*
    Given the head of a linked list, rotate the list to the right by k places.
    Example: list = [1,2,3,4,5] and k = 2
    Output: [4,5,1,2,3]
    
    Time complexity: O(n)
    Space complexity: O(1)
*/

class Solution {
private:
    int findLen(ListNode* head){
        int len = 0;
        while(head!=NULL){
            len++;
            head = head->next;
        }
        return len;
    }
    ListNode* findNewHead(ListNode* head,int k){
        int i=0;
        while(i+1<k){
            i++;
            head = head->next;
        }
        ListNode* ret = head->next;
        head->next = NULL;
        return ret;
    }
    ListNode* findLast(ListNode* head){
        while(head->next!=NULL) head = head->next;
        return head;
    }
public:
    ListNode* rotateRight(ListNode* head, int k) {
        int len = findLen(head); // Finds the length of the Linked List
        if(len==0) return head;
        k = k%len;
        if(k==0) return head;
        ListNode* newHead = findNewHead(head,len-k); // Finds the node that is the new head
        ListNode* last = findLast(newHead); // Finds the last node from the new head and connects it to the previous head
        last->next = head;
        return newHead;
    }
};
```
### Java
```java
//TC: O(n) + O(n- (n % k)) ~ O(n)
//SC: O(1)

class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        if (head == null || head.next == null || k == 0)
            return head;

        int l = 1; // length of list
        ListNode temp = head;

        // calculate the list's length
        while (temp.next != null) {
            l++;
            temp = temp.next;
        }

        temp.next = head; // make the list cyclic
        k = k % l; // handles the case where k>l
        k = l - k;

        while (k > 0) {
            temp = temp.next;
            k--;
        }
        head = temp.next;
        temp.next = null;

        return head;
    }
}
```


