---
title: Swap Nodes in Pairs
category: Linked List
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/swap-nodes-in-pairs)

</Callout>

## Description
Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list&#39;s nodes (i.e., only nodes themselves may be changed.)

 
Example 1:
<Image alt="" src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" width={422} height={222} />
<br /><pre className="overflow-x-auto">
Input: head = [1,2,3,4]
Output: [2,1,4,3]
</pre>

Example 2:

<br /><pre className="overflow-x-auto">
Input: head = []
Output: []
</pre>

Example 3:

<br /><pre className="overflow-x-auto">
Input: head = [1]
Output: [1]
</pre>

 
Constraints:


	- The number of nodes in the list is in the range <code>[0, 100]</code>.
	- <code>0 &lt;= Node.val &lt;= 100</code>



## Solution

### Javascript
```javascript
404: Not Found
```
### Python
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def swapPairs(self, head: ListNode) -> ListNode:
        dummy = ListNode(0, head)
        prev, curr = dummy, head

        while curr and curr.next:
            # save ptrs
            nxtPair = curr.next.next
            second = curr.next

            # reverse this pair
            second.next = curr
            curr.next = nxtPair
            prev.next = second

            # update ptrs
            prev = curr
            curr = nxtPair

        return dummy.next

```
### C++
```cpp
/*
  Given a linked list, swap every two adjacent nodes and return its head. 
  You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)

  Ex. Input: head = [1,2,3,4]
      Output: [2,1,4,3]

  Time  : O(N);
  Space : O(1);
*/

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {  
        if (!head || !head->next) 
            return head;

        ListNode *new_head = head->next;
        ListNode *prev = NULL;

        while (head && head->next) {
            ListNode *next_pair = head->next->next;
            ListNode *second = head->next;

            if (prev)
                prev->next = second;

            second->next = head;
            head->next = next_pair;

            prev = head;
            head = next_pair;
        }
        return new_head;
    }
};

```
### Java
```java
//Iterative version
class Solution {

    public ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null) return head;
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode temp = dummy;
        while (temp.next != null && temp.next.next != null) {
            ListNode first = temp.next;
            ListNode second = temp.next.next;
            temp.next = second;
            first.next = second.next;
            second.next = first;
            temp = first;
        }
        return dummy.next;
    }
}

//Recursive version
class Solution {

    public ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null) return head;
        ListNode p = head.next;
        head.next = swapPairs(head.next.next);
        p.next = head;
        return p;
    }
}

```


