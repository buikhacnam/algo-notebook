---
title: Task Scheduler
category: Heap And Priority Queue
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/task-scheduler)

</Callout>

## Description

Given a characters array <code>tasks</code>, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.

However, there is a non-negative integer <code>n</code> that represents the cooldown period between two <b>same tasks</b> (the same letter in the array), that is that there must be at least <code>n</code> units of time between any two same tasks.

Return _the least number of units of times that the CPU will take to finish all the given tasks_.

Example 1:

<br />

<pre className="overflow-x-auto">
	Input: tasks =
	[&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;],
	n = 2 Output: 8 Explanation: A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle
	-&gt; A -&gt; B There is at least 2 units of time between any two same tasks.
</pre>

Example 2:

<br />

<pre className="overflow-x-auto">
	Input: tasks =
	[&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;],
	n = 0 Output: 6 Explanation: On this case any permutation of size 6 would work
	since n = 0.
	[&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;]
	[&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;B&quot;]
	[&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;]
	... And so on.
</pre>

Example 3:

<br />

<pre className="overflow-x-auto">
	Input: tasks =
	[&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;],
	n = 2 Output: 16 Explanation: One possible solution is A -&gt; B -&gt; C -&gt;
	A -&gt; D -&gt; E -&gt; A -&gt; F -&gt; G -&gt; A -&gt; idle -&gt; idle -&gt;
	A -&gt; idle -&gt; idle -&gt; A
</pre>

Constraints:

    - <code>1 &lt;= task.length &lt;= 10<sup>4</sup></code>
    - <code>tasks[i]</code> is upper-case English letter.
    - The integer <code>n</code> is in the range <code>[0, 100]</code>.

## Solution

### Javascript

```javascript
/**
 * https://leetcode.com/problems/task-scheduler/
 * Time O(N * log(N)) | Space O(N)
 * @param {character[]} tasks
 * @param {number} n
 * @return {number}
 */
var leastInterval = function (tasks, n) {
	const frequencyMap = getFrequencyMap(tasks)
	const maxHeap = getMaxHeap(frequencyMap)

	return getMinimumCpuIntervals(maxHeap, n)
}

var getFrequencyMap = (tasks, frequencyMap = new Array(26).fill(0)) => {
	for (const task of tasks) {
		const index = task.charCodeAt(0) - 'A'.charCodeAt(0)

		frequencyMap[index]++
	}

	return frequencyMap
}

const getMaxHeap = (frequencyMap, maxHeap = new MaxPriorityQueue()) => {
	for (const frequency of frequencyMap) {
		const hasFrequency = 0 < frequency
		if (hasFrequency) maxHeap.enqueue(frequency)
	}

	return maxHeap
}

const getMinimumCpuIntervals = (maxHeap, n, cpuIntervals = [0]) => {
	while (!maxHeap.isEmpty()) {
		const { iterations, coolingPeriodQueue } = execute(n, maxHeap, cpuIntervals)

		reQueueCoolingPeriod(coolingPeriodQueue, maxHeap)

		if (!maxHeap.isEmpty()) cpuIntervals[0] += iterations
	}

	return cpuIntervals[0]
}

const execute = (
	n,
	maxHeap,
	cpuIntervals,
	iterations = n + 1,
	coolingPeriodQueue = new Queue(),
) => {
	while (0 < iterations && !maxHeap.isEmpty()) {
		const frequency = maxHeap.dequeue().element

		const hasFrequency = 0 < frequency - 1
		if (hasFrequency) coolingPeriodQueue.enqueue(frequency - 1)

		cpuIntervals[0]++
		iterations--
	}

	return { iterations, coolingPeriodQueue }
}

const reQueueCoolingPeriod = (coolingPeriodQueue, maxHeap) => {
	while (!coolingPeriodQueue.isEmpty()) {
		maxHeap.enqueue(coolingPeriodQueue.dequeue())
	}
}

/**
 * https://leetcode.com/problems/task-scheduler/
 * Time O(N) | Space O(1)
 * @param {character[]} tasks
 * @param {number} n
 * @return {number}
 */
var leastInterval = function (tasks, n) {
	const frequencyMap = getFrequencyMap(tasks)
	const maxFrequency = getMaxFrequency(frequencyMap)
	const mostFrequentTask = getMostFrequentTask(frequencyMap, maxFrequency)
	const interval = (maxFrequency - 1) * (n + 1) + mostFrequentTask

	return Math.max(tasks.length, interval)
}

var getFrequencyMap = (tasks, frequencyMap = new Array(26).fill(0)) => {
	for (const task of tasks) {
		const index = task.charCodeAt(0) - 'A'.charCodeAt(0)

		frequencyMap[index]++
	}

	return frequencyMap
}

const getMaxFrequency = (frequencyMap, maxFrequency = 0) => {
	for (const frequency of frequencyMap) {
		maxFrequency = Math.max(maxFrequency, frequency)
	}

	return maxFrequency
}

const getMostFrequentTask = (
	frequencyMap,
	maxFrequency,
	mostFrequentTask = 0,
) => {
	for (const frequency of frequencyMap) {
		const isSame = frequency === maxFrequency
		if (isSame) mostFrequentTask++
	}

	return mostFrequentTask
}
```

### Python

```python
class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        count = Counter(tasks)
        maxHeap = [-cnt for cnt in count.values()]
        heapq.heapify(maxHeap)

        time = 0
        q = deque()  # pairs of [-cnt, idleTime]
        while maxHeap or q:
            time += 1

            if not maxHeap:
                time = q[0][1]
            else:
                cnt = 1 + heapq.heappop(maxHeap)
                if cnt:
                    q.append([cnt, time + n])
            if q and q[0][1] == time:
                heapq.heappush(maxHeap, q.popleft()[0])
        return time

```

### C++

```cpp
/*
    Given array of tasks & cooldown b/w same tasks, return least # of units of time
    Ex. tasks = ["A","A","A","B","B","B"] n = 2 -> 8 (A->B->idle->A->B->idle->A->B)

    Key is to determine # of idles, greedy: always arrange task w/ most freq first
    3A, 2B, 1C -> A??A??A -> AB?AB?A -> ABCAB#A, since A most freq, needs most idles

    Time: O(n)
    Space: O(1)
*/
/*
class Solution {
public:
    int leastInterval(vector<char>& tasks, int n) {
        vector<int> counter(26);

        int maxCount = 0;
        int maxCountFrequency = 0;

        for (int i = 0; i < tasks.size(); i++) {
            counter[tasks[i] - 'A']++;
            int currCount = counter[tasks[i] - 'A'];

            if (maxCount == currCount) {
                maxCountFrequency++;
            } else if (maxCount < currCount) {
                maxCount = currCount;
                maxCountFrequency = 1;
            }
        }

        int partCount = maxCount - 1;
        int partLength = n - (maxCountFrequency - 1);
        int emptySlots = partCount * partLength;
        int availableTasks = tasks.size() - maxCount * maxCountFrequency;
        int idles = max(0, emptySlots - availableTasks);

        return tasks.size() + idles;
    }
};
*/

// Time O(n * cooldown)
class Solution {
public:
    int leastInterval(vector<char>& tasks, int n) {
        priority_queue<int> pq;
        queue<vector<int>> q;
        vector<int> counter(26);

        for (int i = 0; i < tasks.size(); ++i)
            ++counter[tasks[i] - 'A'];
        for (int i = 0; i < 26; ++i){
            if (counter[i])
                pq.push(counter[i]);
        }

        int time = 0;
        while (!q.empty() || !pq.empty()){
            ++time;
            if (!pq.empty()){
                if (pq.top() - 1)
                    q.push({pq.top() - 1, time + n});
                pq.pop();
            }
            if (!q.empty() && q.front()[1] == time){
                pq.push(q.front()[0]);
                q.pop();
            }
        }
        return time;
    }
};

```

### Java

```java
class Solution {

    public int leastInterval(char[] tasks, int n) {
        if (n == 0) return tasks.length;
        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);
        Queue<Pair<Integer, Integer>> q = new LinkedList<>();
        int[] arr = new int[26];
        for (char c : tasks) arr[c - 'A']++;
        for (int val : arr) if (val > 0) pq.add(val);
        int time = 0;

        while ((!pq.isEmpty() || !q.isEmpty())) {
            time++;
            if (!pq.isEmpty()) {
                int val = pq.poll();
                val--;
                if (val > 0) q.add(new Pair(val, time + n));
            }

            if (!q.isEmpty() && q.peek().getValue() == time) pq.add(
                q.poll().getKey()
            );
        }
        return time;
    }
}

```
