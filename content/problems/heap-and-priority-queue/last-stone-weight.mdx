---
title: Last Stone Weight
category: Heap And Priority Queue
difficulty: Easy
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/last-stone-weight)

</Callout>

## Description
You are given an array of integers <code>stones</code> where <code>stones[i]</code> is the weight of the <code>i<sup>th</sup></code> stone.

We are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights <code>x</code> and <code>y</code> with <code>x &lt;= y</code>. The result of this smash is:


	- If <code>x == y</code>, both stones are destroyed, and
	- If <code>x != y</code>, the stone of weight <code>x</code> is destroyed, and the stone of weight <code>y</code> has new weight <code>y - x</code>.


At the end of the game, there is at most one stone left.

Return *the weight of the last remaining stone*. If there are no stones left, return <code>0</code>.

 
Example 1:

<br /><pre className="overflow-x-auto">
Input: stones = [2,7,4,1,8,1]
Output: 1
Explanation: 
We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,
we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,
we combine 2 and 1 to get 1 so the array converts to [1,1,1] then,
we combine 1 and 1 to get 0 so the array converts to [1] then that&#39;s the value of the last stone.
</pre>

Example 2:

<br /><pre className="overflow-x-auto">
Input: stones = [1]
Output: 1
</pre>

 
Constraints:


	- <code>1 &lt;= stones.length &lt;= 30</code>
	- <code>1 &lt;= stones[i] &lt;= 1000</code>



## Solution

### Javascript
```javascript
/**
 * https://leetcode.com/problems/last-stone-weight/
 * Time O(N * log(N)) | Space O(N)
 * @param {number[]} stones
 * @return {number}
 */
var lastStoneWeight = function (stones) {
    const maxHeap = getMaxHeap(stones)

    shrink(maxHeap)

    return !maxHeap.isEmpty()
        ? maxHeap.front().element
        : 0
};

const getMaxHeap = (stones, maxHeap = new MaxPriorityQueue()) => {
    for (const stone of stones) {
        maxHeap.enqueue(stone)
    }

    return maxHeap
}

const shrink = (maxHeap) => {
    while (1 < maxHeap.size()) {
        const [ x, y ] = [ maxHeap.dequeue().element, maxHeap.dequeue().element ]
        const difference = x - y;

        const isPositive = 0 < difference
        if (isPositive) maxHeap.enqueue(difference);
    }
}
```
### Python
```python
class Solution:
    def lastStoneWeight(self, stones: List[int]) -> int:
        stones = [-s for s in stones]
        heapq.heapify(stones)

        while len(stones) > 1:
            first = heapq.heappop(stones)
            second = heapq.heappop(stones)
            if second > first:
                heapq.heappush(stones, first - second)

        stones.append(0)
        return abs(stones[0])

```
### C++
```cpp
/*
    Given array of stones to smash, return smallest possible weight of last stone
    If x == y both stones destroyed, if x != y stone x destroyed, stone y = y - x
    Ex. stones = [2,7,4,1,8,1] -> 1, [2,4,1,1,1], [2,1,1,1], [1,1,1], [1]

    Max heap, pop 2 biggest, push back difference until no more 2 elements left

    Time: O(n log n)
    Space: O(n)
*/

class Solution {
public:
    int lastStoneWeight(vector<int>& stones) {
        priority_queue<int> pq;
        for (int i = 0; i < stones.size(); i++) {
            pq.push(stones[i]);
        }
        
        while (pq.size() > 1) {
            int y = pq.top();
            pq.pop();
            int x = pq.top();
            pq.pop();
            if (y > x) {
                pq.push(y - x);
            }
        }
        
        if (pq.empty()) {
            return 0;
        }
        return pq.top();
    }
};

```
### Java
```java
class Solution {

    public int lastStoneWeight(int[] stones) {
        PriorityQueue<Integer> maxHeap = new PriorityQueue();
        for (int stone : stones) maxHeap.add(-stone);
        while (maxHeap.size() > 1) {
            int stone1 = maxHeap.remove();
            int stone2 = maxHeap.remove();
            if (stone1 != stone2) maxHeap.add(stone1 - stone2);
        }
        return maxHeap.size() != 0 ? (-maxHeap.remove()) : 0;
    }
}

```


