---
title: Reorganize String
category: Heap And Priority Queue
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/reorganize-string)

</Callout>

## Description

Given a string <code>s</code>, rearrange the characters of <code>s</code> so that any two adjacent characters are not the same.

Return _any possible rearrangement of_ <code>s</code> _or return_ <code>&quot;&quot;</code> _if not possible_.

Example 1:

<br />
<pre className="overflow-x-auto">Input: s = "aab" Output: "aba"</pre>

Example 2:

<br />
<pre className="overflow-x-auto">Input: s = "aaab" Output: ""</pre>
Constraints:

    - <code>1 &lt;= s.length &lt;= 500</code>
    - <code>s</code> consists of lowercase English letters.

## Solution

### Javascript

```javascript
Solution will be updated soon
```

### Python

```python
class Solution:
    def reorganizeString(self, s: str) -> str:
        count = Counter(s)  # Hashmap, count each char
        maxHeap = [[-cnt, char] for char, cnt in count.items()]
        heapq.heapify(maxHeap)  # O(n)

        prev = None
        res = ""
        while maxHeap or prev:
            if prev and not maxHeap:
                return ""
            # most frequent, except prev
            cnt, char = heapq.heappop(maxHeap)
            res += char
            cnt += 1

            if prev:
                heapq.heappush(maxHeap, prev)
                prev = None
            if cnt != 0:
                prev = [cnt, char]
        return res

```

### C++

```cpp
// Time: O(NlogN)
// Space: O(N)

class Solution {
public:
    string reorganizeString(string s) {
        string res="";

        unordered_map<char, int> mp;
        priority_queue<pair<int, char>> maxh;

        for(auto ch : s)
            mp[ch] += 1;

        for(auto m : mp)
            maxh.push(make_pair(m.second, m.first));

        while(maxh.size() > 1){
            auto top1= maxh.top();
            maxh.pop();
            auto top2 = maxh.top();
            maxh.pop();

            res += top1.second;
            res += top2.second;

            if(--top1.first > 0)
                maxh.push(top1);

            if(--top2.first > 0)
                maxh.push(top2);
        }

        if(!maxh.empty()){
            if(maxh.top().first > 1)
                return "";

            else
                res += maxh.top().second;
        }

        return res;
    }
};

```

### Java

```java
//See this comment for explanation https://leetcode.com/problems/reorganize-string/discuss/113440/Java-solution-PriorityQueue/211009

class Solution {

    public String reorganizeString(String s) {
        HashMap<Character, Integer> map = new HashMap<>();
        for (int i = 0; i < s.length(); i++) {
            map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0) + 1);
        }
        PriorityQueue<Map.Entry<Character, Integer>> pq = new PriorityQueue<>(
                (a, b) ->
            b.getValue() - a.getValue()
        );
        pq.addAll(map.entrySet());

        StringBuilder sb = new StringBuilder();

        while (!pq.isEmpty()) {
            Map.Entry<Character, Integer> temp1 = pq.poll();
            //if the character at sb's end is different from the max frequency character or the string is empty
            if (
                sb.length() == 0 || sb.charAt(sb.length() - 1) != temp1.getKey()
            ) {
                sb.append(temp1.getKey());
                //update the value
                temp1.setValue(temp1.getValue() - 1);
            } else { //the character is same
                //hold the current character and look for the 2nd most frequent character
                Map.Entry<Character, Integer> temp2 = pq.poll();
                //if there is no temp2 i.e. the temp1 was the only character in the heap then there is no way to avoid adjacent duplicate values
                if (temp2 == null) return "";
                //else do the same thing as above
                sb.append(temp2.getKey());
                //update the value
                temp2.setValue(temp2.getValue() - 1);
                //if still has some value left add again to the heap
                if (temp2.getValue() != 0) pq.offer(temp2);
            }
            if (temp1.getValue() != 0) pq.offer(temp1);
        }
        return sb.toString();
    }
}

```
