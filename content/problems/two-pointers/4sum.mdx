---
title: 4Sum
category: Two Pointers
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/4sum)

</Callout>

## Description
Given an array <code>nums</code> of <code>n</code> integers, return *an array of all the unique quadruplets* <code>[nums[a], nums[b], nums[c], nums[d]]</code> such that:


	- <code>0 &lt;= a, b, c, d &lt; n</code>
	- <code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code> are distinct.
	- <code>nums[a] + nums[b] + nums[c] + nums[d] == target</code>


You may return the answer in any order.

 
Example 1:

<br /><pre className="overflow-x-auto">
Input: nums = [1,0,-1,0,-2,2], target = 0
Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
</pre>

Example 2:

<br /><pre className="overflow-x-auto">
Input: nums = [2,2,2,2,2], target = 8
Output: [[2,2,2,2]]
</pre>

 
Constraints:


	- <code>1 &lt;= nums.length &lt;= 200</code>
	- <code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code>
	- <code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code>



## Solution

### Javascript
```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[][]}
 */
var fourSum = function (nums, target) {
    const sortedNums = nums.sort((a, b) => a - b);
    const res = [];
    const quad = [];

    const kSum = (k, start, target) => {
        if (k > 2) {
            for (let i = start; i < sortedNums.length; i++) {
                if (i !== start && sortedNums[i] === sortedNums[i - 1]) {
                    continue;
                }
                quad.push(sortedNums[i]);
                kSum(k - 1, i + 1, target - sortedNums[i]);
                quad.pop();
            }
        } else {
            let left = start;
            let right = sortedNums.length - 1;

            while (left < right) {
                const sum = sortedNums[left] + sortedNums[right];
                if (sum < target) {
                    left++;
                } else if (sum > target) {
                    right--;
                } else {
                    res.push(
                        quad.concat([sortedNums[left], sortedNums[right]])
                    );
                    left++;
                    while (
                        left < right &&
                        sortedNums[left] === sortedNums[left - 1]
                    ) {
                        left++;
                    }
                }
            }
        }
    };
    kSum(4, 0, target);
    return res;
};

```
### Python
```python
class Solution:
    def fourSum(self, nums, target):
        def findNsum(l, r, target, N, result, results):
            if r-l+1 < N or N < 2 or target < nums[l]*N or target > nums[r]*N:  
                return
            if N == 2: 
                while l < r:
                    s = nums[l] + nums[r]
                    if s == target:
                        results.append(result + [nums[l], nums[r]])
                        l += 1
                        while l < r and nums[l] == nums[l-1]:
                            l += 1
                    elif s < target:
                        l += 1
                    else:
                        r -= 1
            else:
                for i in range(l, r+1):
                    if i == l or (i > l and nums[i-1] != nums[i]):
                        findNsum(i+1, r, target-nums[i], N-1, result+[nums[i]], results)

        nums.sort()
        results = []
        findNsum(0, len(nums)-1, target, 4, [], results)
        return results
```
### C++
```cpp
// Time Complexity = O(n^3)
// Space Complexity = O(n)

class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());

        vector<vector<int> > res;
        int n = nums.size();

        for (int i = 0; i < n; i++) {
            if (i > 0 && nums[i] == nums[i - 1])
                continue;
            for (int j = i + 1; j < n; j++) {
                if (j > (i + 1) && nums[j] == nums[j - 1])
                    continue;
                int l = j + 1, r = n - 1;
                while (l < r) {
                    long sm = (long)nums[i] + (long)nums[j] + (long)nums[l] + (long)nums[r];
                    if (sm == target) {
                        res.push_back(vector<int>{nums[i], nums[j], nums[l], nums[r]});
                        l += 1;
                        while (l < r && nums[l] == nums[l - 1])
                            l += 1;
                    }
                    else if (sm > target)
                        r -= 1;
                    else
                        l += 1;
                }
            }
        }
        return res;
    }
};

```
### Java
```java
class Solution {
    public static List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> res = new ArrayList<>();
        Arrays.sort(nums);

        for (int a = 0; a < nums.length-3; a++) {
            if (a > 0 && nums[a] == nums[a - 1]) {
                continue;
            }
            for (int i = a + 1; i < nums.length - 2; i++) {
                if (i > 1 && nums[i] == nums[i - 1] && i-1 != a) {
                    continue;
                }
                int j = i + 1;
                int k = nums.length - 1;
                while (k > j) {
                    long sum = (long) nums[i] + nums[j] + nums[k] + nums[a];
                    if (sum == target) {
                        res.add(new ArrayList<>(Arrays.asList(nums[a],nums[i], nums[j], nums[k])));
                        j++;
                        while (nums[j] == nums[j - 1] && j < k) {
                            j++;
                        }
                    } else if (sum > target) {
                        k--;
                    } else
                        j++;
                }
            }
        }
        return res;
    }
}

```


