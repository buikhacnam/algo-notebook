---
title: Move Zeroes
category: Two Pointers
difficulty: Easy
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/move-zeroes)

</Callout>

## Description

Given an integer array <code>nums</code>, move all <code>0</code>&#39;s to the end of it while maintaining the relative order of the non-zero elements.

Note that you must do this in-place without making a copy of the array.

Example 1:

<br />
<pre className="overflow-x-auto">
	Input: nums = [0,1,0,3,12] Output: [1,3,12,0,0]
</pre>

Example 2:

<br />
<pre className="overflow-x-auto">Input: nums = [0] Output: [0]</pre>
Constraints:

    - <code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code>
    - <code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code>

Follow up: Could you minimize the total number of operations done?

## Solution

### Javascript

```javascript
/**
 * Two Pointer
 * Time O(N) | Space O(N)
 * https://leetcode.com/problems/move-zeroes/
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function (nums) {
	const arr = new Array(nums.length).fill(0)

	let [left, right] = [0, 0]

	while (right < nums.length) {
		const isZero = nums[right] === 0
		if (!isZero) {
			arr[left] = nums[right]
			left++
		}

		right++
	}

	return arr
}

/**
 * 2 Pointer
 * Time O(N) | Space O(1)
 * https://leetcode.com/problems/move-zeroes/
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = (nums) => {
	let [left, right] = [0, 0]

	while (right < nums.length) {
		const canSwap = nums[right] !== 0
		if (canSwap) {
			;[nums[left], nums[right]] = [nums[right], nums[left]]
			left++
		}

		right++
	}
}
```

### Python

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        slow = 0
        for fast in range(len(nums)):

            if nums[fast] != 0 and nums[slow] == 0:
                nums[slow], nums[fast] = nums[fast], nums[slow]

            if nums[slow] != 0:
                slow += 1
```

### C++

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int left = 0;

        for(int i = 0; i < nums.size(); i++){
            if(nums[i] != 0){
                nums[left++] = nums[i];
            }
        }

        for(left; left < nums.size(); left ++){
            nums[left] = 0;
        }
    }
};

```

### Java

```java
class Solution {
    public void moveZeroes(int[] nums) {
        //Do not return anything, modify nums in-place instead.
        int l = 0;
        for(int r = 0; r < nums.length; r++)
            if(nums[r] != 0) {
                int tmp = nums[l];
                nums[l] = nums[r];
                nums[r] = tmp;
                l += 1;
            }
    }
}

```
