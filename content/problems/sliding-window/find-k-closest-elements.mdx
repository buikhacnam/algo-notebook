---
title: Find K Closest Elements
category: Sliding Window
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/find-k-closest-elements)

</Callout>

## Description
Given a sorted integer array <code>arr</code>, two integers <code>k</code> and <code>x</code>, return the <code>k</code> closest integers to <code>x</code> in the array. The result should also be sorted in ascending order.

An integer <code>a</code> is closer to <code>x</code> than an integer <code>b</code> if:


	- <code>|a - x| &lt; |b - x|</code>, or
	- <code>|a - x| == |b - x|</code> and <code>a &lt; b</code>


 
Example 1:
<br /><pre className="overflow-x-auto">Input: arr = [1,2,3,4,5], k = 4, x = 3
Output: [1,2,3,4]
</pre>Example 2:
<br /><pre className="overflow-x-auto">Input: arr = [1,2,3,4,5], k = 4, x = -1
Output: [1,2,3,4]
</pre>
 
Constraints:


	- <code>1 &lt;= k &lt;= arr.length</code>
	- <code>1 &lt;= arr.length &lt;= 10<sup>4</sup></code>
	- <code>arr</code> is sorted in ascending order.
	- <code>-10<sup>4</sup> &lt;= arr[i], x &lt;= 10<sup>4</sup></code>



## Solution

### Javascript
```javascript
/**
 * @param {number[]} arr
 * @param {number} k
 * @param {number} x
 * @return {number[]}
 */
var findClosestElements = function (arr, k, x) {
    let [leftPtr, rightPtr] = [0, arr.length - k];
    while (leftPtr < rightPtr) {
        /*  This is basically rightPtr+leftPtr/2 written differently to
            avoid any overflow incase it happens.
        */
        let mid = parseInt(rightPtr + (leftPtr - rightPtr) / 2);

        if (x - arr[mid] > arr[mid + k] - x) {
            leftPtr = mid + 1;
        } else {
            rightPtr = mid;
        }
    }
    return arr.slice(leftPtr, leftPtr + k);
};

```
### Python
```python
# Log(n) + k
# More code but also more intuitive
class Solution:
    def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:
        l, r = 0, len(arr) - 1

        # Find index of x or the closest val to x
        val, idx = arr[0], 0
        while l <= r:
            m = (l + r) // 2
            curDiff, resDiff = abs(arr[m] - x), abs(val - x)
            if curDiff < resDiff or (curDiff == resDiff and arr[m] < val):
                val, idx = arr[m], m

            if arr[m] < x:
                l = m + 1
            elif arr[m] > x:
                r = m - 1
            else:
                break

        l = r = idx
        for i in range(k - 1):
            if l == 0:
                r += 1
            elif r == len(arr) - 1 or x - arr[l - 1] <= arr[r + 1] - x:
                l -= 1
            else:
                r += 1
        return arr[l : r + 1]


# Log(n-k) + k
# Elegant but very difficult to understand
class Solution:
    def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:
        l, r = 0, len(arr) - k

        while l < r:
            m = (l + r) // 2
            if x - arr[m] > arr[m + k] - x:
                l = m + 1
            else:
                r = m
        return arr[l : l + k]

```
### C++
```cpp
404: Not Found
```
### Java
```java
404: Not Found
```


