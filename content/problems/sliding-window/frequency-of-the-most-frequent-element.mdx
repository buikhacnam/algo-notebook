---
title: Frequency of the Most Frequent Element
category: Sliding Window
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/frequency-of-the-most-frequent-element)

</Callout>

## Description
The frequency of an element is the number of times it occurs in an array.

You are given an integer array <code>nums</code> and an integer <code>k</code>. In one operation, you can choose an index of <code>nums</code> and increment the element at that index by <code>1</code>.

Return *the maximum possible frequency of an element after performing at most *<code>k</code>* operations*.

 
Example 1:

<br /><pre className="overflow-x-auto">
Input: nums = [1,2,4], k = 5
Output: 3
Explanation: Increment the first element three times and the second element two times to make nums = [4,4,4].
4 has a frequency of 3.</pre>

Example 2:

<br /><pre className="overflow-x-auto">
Input: nums = [1,4,8,13], k = 5
Output: 2
Explanation: There are multiple optimal solutions:
- Increment the first element three times to make nums = [4,4,8,13]. 4 has a frequency of 2.
- Increment the second element four times to make nums = [1,8,8,13]. 8 has a frequency of 2.
- Increment the third element five times to make nums = [1,4,13,13]. 13 has a frequency of 2.
</pre>

Example 3:

<br /><pre className="overflow-x-auto">
Input: nums = [3,9,6], k = 2
Output: 1
</pre>

 
Constraints:


	- <code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code>
	- <code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code>
	- <code>1 &lt;= k &lt;= 10<sup>5</sup></code>



## Solution

### Javascript
```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var maxFrequency = function (nums, k) {
    const sortedNums = nums.sort((a, b) => a - b);

    let maxLength = 0;

    let currentSum = 0;
    let leftWindow = 0;
    for (let rightWindow = 0; rightWindow < sortedNums.length; rightWindow++) {
        const currentLength = rightWindow - leftWindow + 1;
        const rightNum = sortedNums[rightWindow];
        currentSum += rightNum;

        if (currentSum + k >= rightNum * currentLength) {
            maxLength = currentLength;
        } else {
            const leftNum = sortedNums[leftWindow];
            currentSum -= leftNum;
            leftWindow++;
        }
    }
    return maxLength;
};

```
### Python
```python
class Solution:
    def maxFrequency(self, nums: List[int], k: int) -> int:
        nums.sort()

        l, r = 0, 0
        res, total = 0, 0

        while r < len(nums):
            total += nums[r]
            while nums[r] * (r - l + 1) > total + k:
                total -= nums[l]
                l += 1
            res = max(res, r - l + 1)
            r += 1
        
        return res
        

```
### C++
```cpp

/*
    Time: O(nlogn)
    Space: O(1)
*/
class Solution {
public:
    int maxFrequency(vector<int>& nums, long long k) {
        sort(nums.begin(),nums.end());
        int l=0;
        int r=0;
        int res=0;
        long long total=0;
        int n=nums.size();
        while(r<n){
            total+=nums[r];
            //invalid window

            while((long)(r-l+1)*nums[r] > total+k){
                total-=nums[l];
                l++;
            }
            
            res=max(res,r-l+1);
            r++;
        }
        return res;
    }
};
```
### Java
```java
404: Not Found
```


