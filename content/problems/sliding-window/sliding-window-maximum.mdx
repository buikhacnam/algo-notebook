---
title: Sliding Window Maximum
category: Sliding Window
difficulty: Hard
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/sliding-window-maximum)

</Callout>

## Description

You are given an array of integers <code>nums</code>, there is a sliding window of size <code>k</code> which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position.

Return _the max sliding window_.

Example 1:

<br />

<pre className="overflow-x-auto">
	Input: nums = [1,3,-1,-3,5,3,6,7], k = 3 Output: [3,3,5,5,6,7] Explanation:
	Window position Max --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5
	3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3
	-1 -3 5 [3 6 7] 7
</pre>

Example 2:

<br />

<pre className="overflow-x-auto">Input: nums = [1], k = 1 Output: [1]</pre>

Constraints:

    - <code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code>
    - <code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code>
    - <code>1 &lt;= k &lt;= nums.length</code>

## Solution

### Javascript

```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
function Node(value) {
	this.value = value
	this.prev = null
	this.next = null
}

function Deque() {
	this.left = null
	this.right = null
	this.size = 0
	this.pushRight = function (value) {
		const node = new Node(value)
		if (this.size == 0) {
			this.left = node
			this.right = node
		} else {
			this.right.next = node
			node.prev = this.right
			this.right = node
		}
		this.size++
		return this.size
	}
	this.popRight = function () {
		if (this.size == 0) return null
		const removedNode = this.right
		this.right = this.right.prev
		if (this.right) this.right.next = null
		this.size--
		return removedNode
	}
	this.pushLeft = function (value) {
		const node = new Node(value)
		if (this.size == 0) {
			this.left = node
			this.right = node
		} else {
			this.left.prev = node
			node.next = this.left
			this.left = node
		}
		this.size++
		return this.size
	}
	this.popLeft = function () {
		if (this.size == 0) return null
		const removedNode = this.left
		this.left = this.left.next
		if (this.left) this.left.prev = null
		this.size--
		return removedNode
	}
}

var maxSlidingWindow = function (nums, k) {
	const output = []
	let deque = new Deque()
	let left = 0
	let right = 0

	while (right < nums.length) {
		// pop smaller values from q
		while (deque.right && nums[deque.right.value] < nums[right])
			deque.popRight()
		deque.pushRight(right)

		// remove left val from window
		if (left > deque.left.value) deque.popLeft()

		if (right + 1 >= k) {
			output.push(nums[deque.left.value])
			left++
		}
		right++
	}
	return output
}

/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */

// Deque Implementation using Lazy Deletion
class LazyDeletionDeque {
	constructor() {
		this.deque = []
		this.leftIdx = 0
	}

	isEmpty = () => {
		return this.deque.length === this.leftIdx
	}
	push = (num) => {
		this.deque.push(num)
	}
	popFront = () => {
		this.leftIdx++
	}
	popBack = () => {
		!this.isEmpty() && this.deque.pop()
	}
	front = () => {
		return this.deque[this.leftIdx]
	}
	back = () => {
		return this.deque[this.deque.length - 1]
	}
}

var maxSlidingWindowWithLazyDeletionDeque = function (nums, k) {
	const deque = new LazyDeletionDeque()
	const answer = []
	let leftWindow = 0
	for (let rightWindow = 0; rightWindow < nums.length; rightWindow++) {
		const rightNum = nums[rightWindow]
		while (!deque.isEmpty() && rightNum > deque.back()) {
			deque.popBack()
		}
		deque.push(rightNum)

		if (rightWindow >= k - 1) {
			const dequeFront = deque.front()
			const leftNum = nums[leftWindow]
			if (leftNum === dequeFront) {
				deque.popFront()
			}
			answer.push(dequeFront)
			leftWindow++
		}
	}
	return answer
}
```

### Python

```python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        output = []
        q = collections.deque()  # index
        l = r = 0
        # O(n) O(n)
        while r < len(nums):
            # pop smaller values from q
            while q and nums[q[-1]] < nums[r]:
                q.pop()
            q.append(r)

            # remove left val from window
            if l > q[0]:
                q.popleft()

            if (r + 1) >= k:
                output.append(nums[q[0]])
                l += 1
            r += 1

        return output

```

### C++

```cpp
/*
    Given int array & sliding window size k, return max sliding window
    Ex. nums = [1,3,-1,-3,5,3,6,7] k = 3 -> [3,3,5,5,6,7]

    Sliding window deque, ensure monotonic decr, leftmost largest

    Time: O(n)
    Space: O(n)
*/

class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        deque<int> dq;
        vector<int> result;

        int i = 0;
        int j = 0;

        while (j < nums.size()) {
            while (!dq.empty() && nums[dq.back()] < nums[j]) {
                dq.pop_back();
            }
            dq.push_back(j);

            if (i > dq.front()) {
                dq.pop_front();
            }

            if (j + 1 >= k) {
                result.push_back(nums[dq.front()]);
                i++;
            }
            j++;
        }

        return result;
    }
};

```

### Java

```java
class Solution {

    public int[] maxSlidingWindow(int[] nums, int k) {
        int[] ans = new int[nums.length - k + 1];
        int j = 0;
        Deque<Integer> q = new LinkedList<>();
        for (int i = 0; i < nums.length; i++) {
            if (!q.isEmpty() && q.peekFirst() < i - k + 1) q.pollFirst();
            while (!q.isEmpty() && nums[i] > nums[q.peekLast()]) q.pollLast();
            q.offer(i);
            if (i >= k - 1) ans[j++] = nums[q.peekFirst()];
        }
        return ans;
    }
}

```
