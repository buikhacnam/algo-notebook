---
title: Network Delay Time
category: Advanced Graphs
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/network-delay-time)

</Callout>

## Description
You are given a network of <code>n</code> nodes, labeled from <code>1</code> to <code>n</code>. You are also given <code>times</code>, a list of travel times as directed edges <code>times[i] = (u<sub>i</sub>, v<sub>i</sub>, w<sub>i</sub>)</code>, where <code>u<sub>i</sub></code> is the source node, <code>v<sub>i</sub></code> is the target node, and <code>w<sub>i</sub></code> is the time it takes for a signal to travel from source to target.

We will send a signal from a given node <code>k</code>. Return *the minimum time it takes for all the* <code>n</code> *nodes to receive the signal*. If it is impossible for all the <code>n</code> nodes to receive the signal, return <code>-1</code>.

 
Example 1:
<Image alt="" src="https://assets.leetcode.com/uploads/2019/05/23/931_example_1.png" width={217} height={239} />
<br /><pre className="overflow-x-auto">
Input: times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2
Output: 2
</pre>

Example 2:

<br /><pre className="overflow-x-auto">
Input: times = [[1,2,1]], n = 2, k = 1
Output: 1
</pre>

Example 3:

<br /><pre className="overflow-x-auto">
Input: times = [[1,2,1]], n = 2, k = 2
Output: -1
</pre>

 
Constraints:


	- <code>1 &lt;= k &lt;= n &lt;= 100</code>
	- <code>1 &lt;= times.length &lt;= 6000</code>
	- <code>times[i].length == 3</code>
	- <code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= n</code>
	- <code>u<sub>i</sub> != v<sub>i</sub></code>
	- <code>0 &lt;= w<sub>i</sub> &lt;= 100</code>
	- All the pairs <code>(u<sub>i</sub>, v<sub>i</sub>)</code> are unique. (i.e., no multiple edges.)



## Solution

### Javascript
```javascript
/**
 * Graph - BFS
 * Queue - Space (WIDTH)
 * Array - Greedy
 * https://leetcode.com/problems/network-delay-time/
 * @param {number[][]} times
 * @param {number} n
 * @param {number} k
 * @return {number}
 */
 var networkDelayTime = (times, n, k) => {
    const { graph, maxTime, queue } = buildGraph(times, n, k);

    bfs(queue, graph, maxTime, k);

    return checkAns(maxTime);
};

var initGraph = (n, k) => ({
    graph: Array.from({ length: n + 1}).fill().map(() => []),
    maxTime: Array.from({ length: n + 1}).fill(Infinity),
    queue: new Queue([[ k, 0 ]])
})

var buildGraph = (times, n, k) => {
    const { graph, maxTime, queue } = initGraph(n, k);

    for (const [ src, dst, weight ] of times ) {
        graph[src].push([ dst, weight ]);
    };

    maxTime[0] = 0;

    return { graph, maxTime, queue };
}

var bfs = (queue, graph, maxTime) => {
    while (!queue.isEmpty()) {
        for (let level = (queue.size() -1); (0 <= level); level-- ) {
            checkNeighbors(queue, graph, maxTime);
        }
    }
}

var checkNeighbors = (queue, graph, maxTime) => {
    const [ node, time ] = queue.dequeue();

    const canUpdate = (time < maxTime[node]);
    if (!canUpdate) return;

    maxTime[node] = time;

    for (const [ dst, weight ] of graph[node]) {
        queue.enqueue([ dst, (weight + time) ]);
    }
}

var checkAns = (maxTime) => {
    const max = Math.max(...maxTime);

    return (max < Infinity)
        ? max
        : (-1);
}

/**
 * https://leetcode.com/problems/network-delay-time/
 * @param {number[][]} times
 * @param {number} n
 * @param {number} k
 * @return {number}
 */
 var networkDelayTime =  (times, n, k) => {
    const { graph, seen, minHeap } = buildGraph(times, n, k) 
    const maxTime = getTime(graph, seen, minHeap);

    return (seen.size === n)
        ? maxTime 
        : -1;
};

var initGraph = (n, k) => ({
    graph: Array.from({ length: n + 1}).fill().map(() => []),
    seen: new Set(),
    minHeap: new MinPriorityQueue()
})

var buildGraph = (times, n, k) => {
    const { graph, seen, minHeap } = initGraph(n, k);

    for (const [ src, dst, weight ] of times ) {
        graph[src].push([ dst, weight ]);
    };

    minHeap.enqueue([k, 0], 0);

    return { graph, seen, minHeap };
}

const getTime = (graph, seen, minHeap, maxTime = 0) => {
    while (!minHeap.isEmpty()) {
        const [ node, cost ] = minHeap.dequeue().element;

        if (seen.has(node)) continue;
        seen.add(node);

        maxTime = Math.max(maxTime, cost);
        checkNeighbors(graph, node, cost, seen, minHeap);
    }

    return maxTime;
}

var checkNeighbors = (graph, src, srcCost, seen, minHeap) => {
    for (const [ dst, dstCost ] of graph[src]) {
        if (seen.has(dst)) continue;

        const cost = (dstCost + srcCost)
        const node = [ dst,  cost];

        minHeap.enqueue(node, cost);
    }
}
```
### Python
```python
class Solution:
    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        edges = collections.defaultdict(list)
        for u, v, w in times:
            edges[u].append((v, w))

        minHeap = [(0, k)]
        visit = set()
        t = 0
        while minHeap:
            w1, n1 = heapq.heappop(minHeap)
            if n1 in visit:
                continue
            visit.add(n1)
            t = w1

            for n2, w2 in edges[n1]:
                if n2 not in visit:
                    heapq.heappush(minHeap, (w1 + w2, n2))
        return t if len(visit) == n else -1

        # O(E * logV)

```
### C++
```cpp
/*
    Signal sent from node k to network of n nodes, return time for all nodes to receive it
    Ex. times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2 -> 2
                  u,v,w -> u = source node, v = target node, w = signal travel time

    Shortest path from node k to every other node, Dijkstra's to find fastest path

    Time: O(V + E log V)
    Space: O(V + E)
*/

class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        vector<pair<int, int>> adj[n + 1];
        for (int i = 0; i < times.size(); i++) {
            int source = times[i][0];
            int dest = times[i][1];
            int time = times[i][2];
            adj[source].push_back({time, dest});
        }
        
        vector<int> signalReceiveTime(n + 1, INT_MAX);
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        pq.push({0, k});
        
        // time for start node is 0
        signalReceiveTime[k] = 0;
        
        while (!pq.empty()) {
            int currNodeTime = pq.top().first;
            int currNode = pq.top().second;
            pq.pop();
            
            if (currNodeTime > signalReceiveTime[currNode]) {
                continue;
            }
            
            // send signal to adjacent nodes
            for (int i = 0; i < adj[currNode].size(); i++) {
                pair<int, int> edge = adj[currNode][i];
                int time = edge.first;
                int neighborNode = edge.second;
                
                // fastest signal time for neighborNode so far
                if (signalReceiveTime[neighborNode] > currNodeTime + time) {
                    signalReceiveTime[neighborNode] = currNodeTime + time;
                    pq.push({signalReceiveTime[neighborNode], neighborNode});
                }
            }
        }
        
        int result = INT_MIN;
        for (int i = 1; i <= n; i++) {
            result = max(result, signalReceiveTime[i]);
        }
        
        if (result == INT_MAX) {
            return -1;
        }
        return result;
    }
};

```
### Java
```java
// Bellman Ford ALgorithm
// Time Complexty (n * t) | Space Complexity O(n) where t is the length of times
class Solution {

    public int networkDelayTime(int[][] times, int n, int k) {
        // initialize an array with max value of size n
        int[] paths = new int[n];
        Arrays.fill(paths, Integer.MAX_VALUE);

        paths[k - 1] = 0;

        for (int i = 0; i < n; i++) {
            // make a copy of paths
            int[] temp = new int[n];
            temp = Arrays.copyOf(paths, paths.length);

            // loop through times
            for (int j = 0; j < times.length; j++) {
                int src = times[j][0]; // source
                int tgt = times[j][1]; // target
                int time = times[j][2]; // time

                if (
                    temp[src - 1] != Integer.MAX_VALUE &&
                    temp[src - 1] + time < temp[tgt - 1]
                ) {
                    temp[tgt - 1] = temp[src - 1] + time;
                }
            }

            // set paths to temp
            paths = temp;
        }

        int result = Integer.MIN_VALUE;

        // calculate max value
        for (int i = 0; i < n; i++) {
            if (paths[i] == Integer.MAX_VALUE) {
                return -1;
            }
            result = Math.max(result, paths[i]);
        }

        // return result
        return result;
    }
}

```


