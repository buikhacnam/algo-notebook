---
title: Path with Maximum Probability
category: Advanced Graphs
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/path-with-maximum-probability)

</Callout>

## Description
You are given an undirected weighted graph of <code>n</code> nodes (0-indexed), represented by an edge list where <code>edges[i] = [a, b]</code> is an undirected edge connecting the nodes <code>a</code> and <code>b</code> with a probability of success of traversing that edge <code>succProb[i]</code>.

Given two nodes <code>start</code> and <code>end</code>, find the path with the maximum probability of success to go from <code>start</code> to <code>end</code> and return its success probability.

If there is no path from <code>start</code> to <code>end</code>, return 0. Your answer will be accepted if it differs from the correct answer by at most 1e-5.

 
Example 1:

<Image alt="" src="https://assets.leetcode.com/uploads/2019/09/20/1558_ex1.png" width={187} height={186} />

<br /><pre className="overflow-x-auto">
Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2
Output: 0.25000
Explanation: There are two paths from start to end, one having a probability of success = 0.2 and the other has 0.5 * 0.5 = 0.25.
</pre>

Example 2:

<Image alt="" src="https://assets.leetcode.com/uploads/2019/09/20/1558_ex2.png" width={189} height={186} />

<br /><pre className="overflow-x-auto">
Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2
Output: 0.30000
</pre>

Example 3:

<Image alt="" src="https://assets.leetcode.com/uploads/2019/09/20/1558_ex3.png" width={215} height={191} />

<br /><pre className="overflow-x-auto">
Input: n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2
Output: 0.00000
Explanation: There is no path between 0 and 2.
</pre>

 
Constraints:


	- <code>2 &lt;= n &lt;= 10^4</code>
	- <code>0 &lt;= start, end &lt; n</code>
	- <code>start != end</code>
	- <code>0 &lt;= a, b &lt; n</code>
	- <code>a != b</code>
	- <code>0 &lt;= succProb.length == edges.length &lt;= 2*10^4</code>
	- <code>0 &lt;= succProb[i] &lt;= 1</code>
	- There is at most one edge between every two nodes.



## Solution

### Javascript
```javascript
/**
 * @param {number} n
 * @param {number[][]} edges
 * @param {number[]} succProb
 * @param {number} start
 * @param {number} end
 * @return {number}
 */
var maxProbability = function(n, edges, succProb, start, end) {
    const genAdjList = () => {
        /***
        {
            0: [[1, 0.5], [2, 0.2]],
            1: [[0, 0.5], [2, 0.5]],
            2: [[1, 0.5], [0, 0.2]],
        }
        ***/
        let list = {};
        for(let i = 0; i < n; i++) {
            list[i] = [];
        }
        for(let i = 0;  i < edges.length; i++) {
            const [v1, v2] = edges[i];
            const p = succProb[i];
            list[v1].push([v2, p]);
            list[v2].push([v1, p]);
        }
            
        return list;
    }
    const graph = genAdjList();
    const queue = new MaxPriorityQueue();
    const visited = new Set();
    
    queue.enqueue([start, 1], 1);
    
    while(!queue.isEmpty()) {
        const [n1, p1] = queue.dequeue().element;
        if(visited.has(n1)) continue;
        visited.add(n1);
        if(n1 === end) return p1;
        
        for(const [n2, p2] of graph[n1]) {
            if(visited.has(n2)) continue;
            const val = p1 * p2;
            queue.enqueue([n2, val], val);
        }
    }
    if(visited.size !== n) return 0;
};

```
### Python
```python
class Solution:
    def maxProbability(self, n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:
        adj = collections.defaultdict(list)
        for i in range(len(edges)):
            src, dst = edges[i]
            adj[src].append([dst, succProb[i]])
            adj[dst].append([src, succProb[i]])

        pq = [(-1, start)]
        visit = set()

        while pq:
            prob, cur = heapq.heappop(pq)
            visit.add(cur)

            if cur == end:
                return prob * -1
            for nei, edgeProb in adj[cur]:
                if nei not in visit:
                    heapq.heappush(pq, (prob * edgeProb, nei))
        return 0

```
### C++
```cpp
class Solution {
public:
    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start_node, int end_node) {
        // adj list mapping {node -> [(probability, neighborNode), ...]}
        unordered_map<int, vector<pair<double, int>>> adj;
        for (int i=0; i<edges.size(); ++i) {
            vector<int> edge = edges[i];
            adj[edge[0]].push_back({succProb[i], edge[1]});
            adj[edge[1]].push_back({succProb[i], edge[0]});
        }

        // maxHeap storing pairs of (probability, node)
        priority_queue<pair<double, int>> pq; 
        pq.push({1.0, start_node});

        unordered_set<int> visited;

        // applying Dijkstra's algorithm
        while (!pq.empty()) {
            double currProb = pq.top().first;
            int currNode = pq.top().second;
            pq.pop();

            if (currNode == end_node)
                return currProb;

            visited.insert(currNode);

            for (auto& [nextProb, nextNode] : adj[currNode]) {
                if (visited.find(nextNode) == visited.end()) {
                    pq.push({currProb*nextProb, nextNode});
                }
            }
        }   

        return 0.0;
    }
};
```
### Java
```java
class Solution {
    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {
        // create the graph
        List<double[]>[] graph = new LinkedList[n];
        for (int i = 0; i < n; i++) {
            graph[i] = new LinkedList<>();
        }
        
        for (int i = 0; i < edges.length; i++) {
            double from =  edges[i][0];
            double to =  edges[i][1];
            double weight = succProb[i];
            double[] m = new double[2];
            m[0] = to;
            m[1] = weight;
            graph[edges[i][0]].add(m);
            double[] k = new double[2];
            k[0] = from;
            k[1] = weight;
            graph[edges[i][1]].add(k);
        }
        
        // call dijkstra and return 
        return dijkstra(start, end, graph);
    }
    
    class State{
        int id;
        double proToStart;
        
        public State(int id, double proToStart){
            this.id = id;
            this.proToStart = proToStart;
        }
    }
    
    private double dijkstra(int start, int end, List<double[]>[] graph){
        double[] proTo = new double[graph.length];
        // 初始化为一个去不到的值
        Arrays.fill(proTo, -1);
        proTo[start] = 1;
        
        PriorityQueue<State> pq = new PriorityQueue<State>((a, b) -> {
        return Double.compare(b.proToStart, a.proToStart);
    });
        pq.offer(new State(start, 1));
        
        while (!pq.isEmpty()){
            State cur = pq.poll();
            int curid = cur.id;
            double curproToStart = cur.proToStart;
            
            if (curid == end) {
                return curproToStart;
            }
            
            if (proTo[curid] > curproToStart) {
                continue;
            }
            
            List<double[]> nexts = graph[curid];
            for (double[] next: nexts) {
                double proToNext = proTo[curid] * next[1];
                int idx = (int) next[0];
                if (proToNext > proTo[idx]) {
                    proTo[idx] = proToNext;
                    pq.offer(new State(idx, proToNext));
                }
            }
        }
        
        return 0;
    }
}

```


