---
title: Swim in Rising Water
category: Advanced Graphs
difficulty: Hard
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/swim-in-rising-water)

</Callout>

## Description

You are given an <code>n x n</code> integer matrix <code>grid</code> where each value <code>grid[i][j]</code> represents the elevation at that point <code>(i, j)</code>.

The rain starts to fall. At time <code>t</code>, the depth of the water everywhere is <code>t</code>. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most <code>t</code>. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.

Return _the least time until you can reach the bottom right square _<code>(n - 1, n - 1)</code>_ if you start at the top left square _<code>(0, 0)</code>.

Example 1:

<Image
	alt=""
	src="https://assets.leetcode.com/uploads/2021/06/29/swim1-grid.jpg"
	width={164}
	height={165}
/>
<br />

<pre className="overflow-x-auto">
	Input: grid = [[0,2],[1,3]] Output: 3 Explanation: At time 0, you are in grid
	location (0, 0). You cannot go anywhere else because 4-directionally adjacent
	neighbors have a higher elevation than t = 0. You cannot reach point (1, 1)
	until time 3. When the depth of water is 3, we can swim anywhere inside the
	grid.
</pre>

Example 2:

<Image
	alt=""
	src="https://assets.leetcode.com/uploads/2021/06/29/swim2-grid-1.jpg"
	width={404}
	height={405}
/>
<br />

<pre className="overflow-x-auto">
	Input: grid =
	[[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]
	Output: 16 Explanation: The final route is shown. We need to wait until time
	16 so that (0, 0) and (4, 4) are connected.
</pre>

Constraints:

    - <code>n == grid.length</code>
    - <code>n == grid[i].length</code>
    - <code>1 &lt;= n &lt;= 50</code>
    - <code>0 &lt;= grid[i][j] &lt; n<sup>2</sup></code>
    - Each value <code>grid[i][j]</code> is unique.

## Solution

### Javascript

```javascript
/**
 * https://leetcode.com/problems/swim-in-rising-water/
 * @param {number[][]} grid
 * @return {number}
 */
var swimInWater = (grid) => {
	const seen = new Set()
	const minHeap = getHeap(grid)

	return getTime(grid, seen, minHeap)
}

const getHeap = (grid, minHeap = new MinPriorityQueue()) => {
	minHeap.enqueue([0, 0], grid[0][0])

	return minHeap
}

var getTime = (grid, seen, minHeap, maxTime = 0) => {
	const [rows, cols] = [grid.length - 1, grid[0].length - 1]

	while (!minHeap.isEmpty()) {
		const { element, priority: cost } = minHeap.dequeue()
		const [row, col] = element

		seen.add(grid[row][col])
		maxTime = Math.max(maxTime, cost)

		const isEnd = row === rows && col === cols
		if (isEnd) return maxTime

		checkNeighbors(grid, row, rows, col, cols, seen, minHeap)
	}
}

var checkNeighbors = (grid, row, rows, col, cols, seen, minHeap) => {
	for (const [_row, _col] of getNeighbors(row, rows, col, cols)) {
		if (seen.has(grid[_row][_col])) continue

		minHeap.enqueue([_row, _col], grid[_row][_col])
	}
}

const getNeighbors = (row, rows, col, cols) =>
	[
		[1, 0],
		[-1, 0],
		[0, 1],
		[0, -1],
	]
		.map(([_row, _col]) => [row + _row, col + _col])
		.filter(
			([_row, _col]) => 0 <= _row && _row <= rows && 0 <= _col && _col <= cols,
		)
```

### Python

```python
class Solution:
    def swimInWater(self, grid: List[List[int]]) -> int:
        N = len(grid)
        visit = set()
        minH = [[grid[0][0], 0, 0]]  # (time/max-height, r, c)
        directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]

        visit.add((0, 0))
        while minH:
            t, r, c = heapq.heappop(minH)
            if r == N - 1 and c == N - 1:
                return t
            for dr, dc in directions:
                neiR, neiC = r + dr, c + dc
                if (
                    neiR < 0
                    or neiC < 0
                    or neiR == N
                    or neiC == N
                    or (neiR, neiC) in visit
                ):
                    continue
                visit.add((neiR, neiC))
                heapq.heappush(minH, [max(t, grid[neiR][neiC]), neiR, neiC])

```

### C++

```cpp
/*
    Given an integer elevation matrix, rain falls, at time t, depth everywhere is t
    Can swim iff elevation at most t, return least time get from top left to bottom right

    Shortest path w/ min heap: at every step, find lowest water level to move forward

    Time: O(n^2 log n)
    Space: O(n^2)
*/

class Solution {
public:
    int swimInWater(vector<vector<int>>& grid) {
        int n = grid.size();
        if (n == 1) {
            return 0;
        }

        vector<vector<bool>> visited(n, vector<bool>(n));
        visited[0][0] = true;

        int result = max(grid[0][0], grid[n - 1][n - 1]);

        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;
        pq.push({result, 0, 0});

        while (!pq.empty()) {
            vector<int> curr = pq.top();
            pq.pop();

            result = max(result, curr[0]);

            for (int i = 0; i < 4; i++) {
                int x = curr[1] + dirs[i][0];
                int y = curr[2] + dirs[i][1];

                if (x < 0 || x >= n || y < 0 || y >= n || visited[x][y]) {
                    continue;
                }

                if (x == n - 1 && y == n - 1) {
                    return result;
                }

                pq.push({grid[x][y], x, y});
                visited[x][y] = true;
            }
        }

        return -1;
    }
private:
    vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
};

```

### Java

```java
// Solution: Greedy Approach with Min Heap
// Time Complexity: O((n^2)*log(n))
class Solution {

    private int[][] dirs = { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } };

    public int swimInWater(int[][] grid) {
        int len = grid.length;

        if (len == 1) {
            return 0;
        }

        var seen = new boolean[len][len];
        seen[0][0] = true;

        var minHeap = new PriorityQueue<Integer[]>((a, b) -> a[0] - b[0]);
        minHeap.add(new Integer[] { grid[0][0], 0, 0 });

        int result = 0;

        while (!minHeap.isEmpty()) {
            var curr = minHeap.poll();

            result = Math.max(result, curr[0]);

            if (curr[1] == len - 1 && curr[2] == len - 1) {
                break;
            }

            for (int i = 0; i < 4; i++) {
                int x = curr[1] + dirs[i][0];
                int y = curr[2] + dirs[i][1];

                if (x < 0 || x >= len || y < 0 || y >= len || seen[x][y]) {
                    continue;
                }

                minHeap.add(new Integer[] { grid[x][y], x, y });
                seen[x][y] = true;
            }
        }

        return result;
    }
}

```
