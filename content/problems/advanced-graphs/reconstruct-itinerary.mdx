---
title: Reconstruct Itinerary
category: Advanced Graphs
difficulty: Hard
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/reconstruct-itinerary)

</Callout>

## Description

You are given a list of airline <code>tickets</code> where <code>tickets[i] = [from<sub>i</sub>, to<sub>i</sub>]</code> represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.

All of the tickets belong to a man who departs from <code>&quot;JFK&quot;</code>, thus, the itinerary must begin with <code>&quot;JFK&quot;</code>. If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.

    - For example, the itinerary <code>[&quot;JFK&quot;, &quot;LGA&quot;]</code> has a smaller lexical order than <code>[&quot;JFK&quot;, &quot;LGB&quot;]</code>.

You may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.

Example 1:

<Image
	alt=""
	src="https://assets.leetcode.com/uploads/2021/03/14/itinerary1-graph.jpg"
	width={382}
	height={222}
/>
<br />

<pre className="overflow-x-auto">
	Input: tickets =
	[[&quot;MUC&quot;,&quot;LHR&quot;],[&quot;JFK&quot;,&quot;MUC&quot;],[&quot;SFO&quot;,&quot;SJC&quot;],[&quot;LHR&quot;,&quot;SFO&quot;]]
	Output:
	[&quot;JFK&quot;,&quot;MUC&quot;,&quot;LHR&quot;,&quot;SFO&quot;,&quot;SJC&quot;]
</pre>

Example 2:

<Image
	alt=""
	src="https://assets.leetcode.com/uploads/2021/03/14/itinerary2-graph.jpg"
	width={222}
	height={230}
/>
<br />

<pre className="overflow-x-auto">
	Input: tickets =
	[[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]
	Output:
	[&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]
	Explanation: Another possible reconstruction is
	[&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;]
	but it is larger in lexical order.
</pre>

Constraints:

    - <code>1 &lt;= tickets.length &lt;= 300</code>
    - <code>tickets[i].length == 2</code>
    - <code>from<sub>i</sub>.length == 3</code>
    - <code>to<sub>i</sub>.length == 3</code>
    - <code>from<sub>i</sub></code> and <code>to<sub>i</sub></code> consist of uppercase English letters.
    - <code>from<sub>i</sub> != to<sub>i</sub></code>

## Solution

### Javascript

```javascript
/**
 * https://leetcode.com/problems/reconstruct-itinerary/
 * @param {string[][]} tickets
 * @return {string[]}
 */
var findItinerary = (tickets) => {
	tickets.sort()

	const graph = buildGraph(tickets)

	return dfs(tickets, graph)
}

const dfs = (tickets, graph, city = 'JFK', path = ['JFK']) => {
	const isBaseCase = path.length === tickets.length + 1
	if (isBaseCase) return true

	const queue = graph.get(city) || []

	const isEmpty = queue.length === 0
	if (isEmpty) return false

	for (const nextCity of queue.slice()) {
		path.push(nextCity)
		queue.shift()

		if (dfs(tickets, graph, nextCity, path)) return path

		path.pop()
		queue.push(nextCity)
	}

	return false
}

const buildGraph = (tickets, graph = new Map()) => {
	for (const [src, dst] of tickets) {
		const edges = graph.get(src) || []

		edges.push(dst)
		graph.set(src, edges)
	}

	return graph
}
```

### Python

```python
class Solution:
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        adj = {u: collections.deque() for u, v in tickets}
        res = ["JFK"]

        tickets.sort()
        for u, v in tickets:
            adj[u].append(v)

        def dfs(cur):
            if len(res) == len(tickets) + 1:
                return True
            if cur not in adj:
                return False

            temp = list(adj[cur])
            for v in temp:
                adj[cur].popleft()
                res.append(v)
                if dfs(v):
                    return res
                res.pop()
                adj[cur].append(v)
            return False

        dfs("JFK")
        return res

```

### C++

```cpp
/*
    Given airline tickets, find valid itinerary (use all tickets once)
    Ex. tickets = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]
        output = ["JFK","MUC","LHR","SFO","SJC"]

    Greedy DFS, build route backwards when retreating, merge cycles into main path

    Time: O(E log (E / V)) -> E = # of flights, V = # of airports, sorting
    Space: O(V + E) -> store # of airports & # of flights in hash map
*/

class Solution {
public:
    vector<string> findItinerary(vector<vector<string>>& tickets) {
        unordered_map<string, multiset<string>> m;
        for (int i = 0; i < tickets.size(); i++) {
            m[tickets[i][0]].insert(tickets[i][1]);
        }

        vector<string> result;
        dfs(m, "JFK", result);
        reverse(result.begin(), result.end());
        return result;
    }
private:
    void dfs(unordered_map<string, multiset<string>>& m,
        string airport, vector<string>& result) {

        while (!m[airport].empty()) {
            string next = *m[airport].begin();
            m[airport].erase(m[airport].begin());
            dfs(m, next, result);
        }

        result.push_back(airport);
    }
};

```

### Java

```java
class Solution {

    public List<String> findItinerary(List<List<String>> tickets) {
        LinkedList<String> itinerary = new LinkedList<>();
        Map<String, PriorityQueue<String>> graph = new HashMap<>();
        Stack<String> stack = new Stack<>();

        for (List<String> ticket : tickets) {
            graph
                .computeIfAbsent(ticket.get(0), k -> new PriorityQueue<>())
                .add(ticket.get(1));
        }

        stack.push("JFK");
        while (!stack.isEmpty()) {
            String nextDestination = stack.peek();

            if (
                !graph
                    .getOrDefault(nextDestination, new PriorityQueue<>())
                    .isEmpty()
            ) {
                stack.push(graph.get(nextDestination).poll());
            } else {
                itinerary.addFirst(stack.pop());
            }
        }
        return itinerary;
    }
}

```
