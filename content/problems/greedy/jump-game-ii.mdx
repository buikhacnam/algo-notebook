---
title: Jump Game II
category: Greedy
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/jump-game-ii)

</Callout>

## Description

You are given a 0-indexed array of integers <code>nums</code> of length <code>n</code>. You are initially positioned at <code>nums[0]</code>.

Each element <code>nums[i]</code> represents the maximum length of a forward jump from index <code>i</code>. In other words, if you are at <code>nums[i]</code>, you can jump to any <code>nums[i + j]</code> where:

    - <code>0 &lt;= j &lt;= nums[i]</code> and
    - <code>i + j &lt; n</code>

Return _the minimum number of jumps to reach _<code>nums[n - 1]</code>. The test cases are generated such that you can reach <code>nums[n - 1]</code>.

Example 1:

<br />

<pre className="overflow-x-auto">
	Input: nums = [2,3,1,1,4] Output: 2 Explanation: The minimum number of jumps
	to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to
	the last index.
</pre>

Example 2:

<br />

<pre className="overflow-x-auto">Input: nums = [2,3,0,1,4] Output: 2</pre>

Constraints:

    - <code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code>
    - <code>0 &lt;= nums[i] &lt;= 1000</code>
    - It&#39;s guaranteed that you can reach <code>nums[n - 1]</code>.

## Solution

### Javascript

```javascript
/**
 * https://leetcode.com/problems/jump-game-ii/
 * Time O(N) | Space O(1)
 * @param {number[]} nums
 * @return {number}
 */
var jump = function (nums) {
	let [left, right, jumps] = [0, 0, 0]

	while (right < nums.length - 1) {
		const maxReach = getMaxReach(nums, left, right)

		left = right + 1
		right = maxReach
		jumps += 1
	}

	return jumps
}

const getMaxReach = (nums, left, right, maxReach = 0) => {
	for (let i = left; i < right + 1; i++) {
		const reach = nums[i] + i
		maxReach = Math.max(maxReach, reach)
	}

	return maxReach
}

/**
 * https://leetcode.com/problems/jump-game-ii/
 * Time O(N) | Space O(1)
 * @param {number[]} nums
 * @return {number}
 */
var jump = function (nums) {
	let [jumps, currentJumpEnd, farthest] = [0, 0, 0]

	for (let i = 0; i < nums.length - 1; i++) {
		farthest = Math.max(farthest, i + nums[i])

		const canJump = i === currentJumpEnd
		if (canJump) {
			jumps++
			currentJumpEnd = farthest
		}
	}

	return jumps
}
```

### Python

```python
class Solution:
    def jump(self, nums: List[int]) -> int:
        l, r = 0, 0
        res = 0
        while r < (len(nums) - 1):
            maxJump = 0
            for i in range(l, r + 1):
                maxJump = max(maxJump, i + nums[i])
            l = r + 1
            r = maxJump
            res += 1
        return res

```

### C++

```cpp
/*
    Given int array, determine min jumps to reach last index
    Ex. nums = [2,3,1,1,4] -> 2, index 0 to 1 to last

    Greedy: At each point, determine furthest reachable, jump to it

    Time: O(n)
    Space: O(1)
*/

class Solution {
public:
    int jump(vector<int>& nums) {
        int n = nums.size();
        int result = 0;

        int i = 0;
        while (i < n - 1) {
            if (i + nums[i] >= n - 1) {
                result++;
                break;
            }
            int maxIndex = i + 1;
            int maxValue = 0;
            for (int j = i + 1; j < i + 1 + nums[i]; j++) {
                if (j + nums[j] > maxValue) {
                    maxIndex = j;
                    maxValue = j + nums[j];
                }
            }
            i = maxIndex;
            result++;
        }

        return result;
    }
};

```

### Java

```java
class Solution {

    public int jump(int[] nums) {
        int res = 0, r = 0, l = 0, fur = 0;

        while (r < nums.length - 1) {
            fur = 0;
            for (int i = l; i <= r; i++) fur = Math.max(fur, i + nums[i]);
            l = r + 1;
            r = fur;
            res++;
        }
        return res;
    }
}

```
