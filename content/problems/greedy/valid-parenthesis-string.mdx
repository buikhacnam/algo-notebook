---
title: Valid Parenthesis String
category: Greedy
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/valid-parenthesis-string)

</Callout>

## Description

Given a string <code>s</code> containing only three types of characters: <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code> and <code>&#39;*&#39;</code>, return <code>true</code> *if* <code>s</code> *is valid\*.

The following rules define a valid string:

    - Any left parenthesis <code>&#39;(&#39;</code> must have a corresponding right parenthesis <code>&#39;)&#39;</code>.
    - Any right parenthesis <code>&#39;)&#39;</code> must have a corresponding left parenthesis <code>&#39;(&#39;</code>.
    - Left parenthesis <code>&#39;(&#39;</code> must go before the corresponding right parenthesis <code>&#39;)&#39;</code>.
    - <code>&#39;*&#39;</code> could be treated as a single right parenthesis <code>&#39;)&#39;</code> or a single left parenthesis <code>&#39;(&#39;</code> or an empty string <code>&quot;&quot;</code>.

Example 1:

<br />
<pre className="overflow-x-auto">Input: s = "()" Output: true</pre>

Example 2:

<br />
<pre className="overflow-x-auto">Input: s = "(*)" Output: true</pre>

Example 3:

<br />
<pre className="overflow-x-auto">Input: s = "(*))" Output: true</pre>
Constraints:

    - <code>1 &lt;= s.length &lt;= 100</code>
    - <code>s[i]</code> is <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code> or <code>&#39;*&#39;</code>.

## Solution

### Javascript

```javascript
/**
 * @param {string} s
 * @return {boolean}
 */
var checkValidString = function (s) {
	var leftMin = 0
	var leftMax = 0

	for (var c of s) {
		if (c === '(') {
			leftMin++
			leftMax++
		} else if (c === ')') {
			leftMin--
			leftMax--
		} else {
			leftMin--
			leftMax++
		}

		if (leftMax < 0) {
			return false
		}

		if (leftMin < 0) {
			leftMin = 0
		}
	}

	return leftMin === 0
}

/**
 * https://leetcode.com/problems/valid-parenthesis-string/
 * Time O(N^3) | Space O(N^2)
 * @param {string} s
 * @return {boolean}
 */
var checkValidString = function (s) {
	const isBaseCase = s.length === 0
	if (isBaseCase) return true

	const dp = new Array(s.length)
		.fill()
		.map(() => new Array(s.length).fill(false))

	for (let i = 0; i < s.length; i++) {
		/* Time O(N) */
		if (isStar(s[i])) dp[i][i] = true

		const isInBound = i < s.length - 1
		const isOpenedOrStar = isOpened(s[i]) || isStar(s[i])
		const isClosedOrStar = isClosed(s[i + 1]) || isStar(s[i + 1])

		const isValid = isInBound && isOpenedOrStar && isClosedOrStar
		if (isValid) dp[i][i + 1] = true /* Space O(N^2) */
	}

	for (let size = 2; size < s.length; size++) {
		/* Time O() */
		for (let i = 0; i + size < s.length; i++) {
			/* Time O(N) */
			const isStarOrDP = isStar(s[i]) && isDP(dp, i + 1, i + size)
			if (isStarOrDP) {
				dp[i][i + size] = true
				continue
			}

			const isOpenedOrStar = isOpened(s[i]) || isStar(s[i])
			if (isOpenedOrStar) check(dp, size, i) /* Time O(N) */
		}
	}

	return dp[0][s.length - 1]
}

const check = (dp, size, i) => {
	for (let k = i + 1; k <= i + size; k++) {
		/* Time O(N) */
		const isClosedOrStar = isClosed(s[k]) || isStar(s[k])
		const isKOrDP = isKEqual(k, i, 1) || isDP(dp, i + 1, k - 1)
		const isKOrDPSize = isKEqual(k, i, size) || isDP(dp, k + 1, i + size)

		const isValid = isClosedOrStar && isKOrDP && isKOrDPSize
		if (isValid) dp[i][i + size] = true /* Space O(N^2) */
	}
}

var isStar = (char) => char === '*'
var isOpened = (char) => char === '('
var isClosed = (char) => char === ')'
const isKEqual = (k, i, size) => k === i + size
const isDP = (dp, i, k) => dp[i][k]

/**
 * Time O(N) | Space O(1)
 * @param {string} s
 * @return {boolean}
 */
var checkValidString = function (s) {
	let [left, right] = [0, 0]

	for (const char of s) {
		/* Time O(N) */
		left += isOpened(char) ? 1 : -1
		right += !isClosed(char) ? 1 : -1

		const isNegative = right < 0
		if (isNegative) break

		left = Math.max(left, 0)
	}

	return left === 0
}

var isOpened = (char) => char === '('
var isClosed = (char) => char === ')'
```

### Python

```python
# Dynamic Programming: O(n^2)
class Solution:
    def checkValidString(self, s: str) -> bool:
        dp = {(len(s), 0): True}  # key=(i, leftCount) -> isValid

        def dfs(i, left):
            if i == len(s) or left < 0:
                return left == 0
            if (i, left) in dp:
                return dp[(i, left)]

            if s[i] == "(":
                dp[(i, left)] = dfs(i + 1, left + 1)
            elif s[i] == ")":
                dp[(i, left)] = dfs(i + 1, left - 1)
            else:
                dp[(i, left)] = (
                    dfs(i + 1, left + 1) or dfs(i + 1, left - 1) or dfs(i + 1, left)
                )
            return dp[(i, left)]

        return dfs(0, 0)


# Greedy: O(n)
class Solution:
    def checkValidString(self, s: str) -> bool:
        leftMin, leftMax = 0, 0

        for c in s:
            if c == "(":
                leftMin, leftMax = leftMin + 1, leftMax + 1
            elif c == ")":
                leftMin, leftMax = leftMin - 1, leftMax - 1
            else:
                leftMin, leftMax = leftMin - 1, leftMax + 1
            if leftMax < 0:
                return False
            if leftMin < 0:  # required because -> s = ( * ) (
                leftMin = 0
        return leftMin == 0

```

### C++

```cpp
class Solution {
public:
    bool checkValidString(string s) {
        int n = s.size();

        int balanced = 0;
        for(int i=0; i<n; i++) {
            if(s[i] == '(' || s[i] == '*')
                balanced++;
            else
                balanced--;

            if(balanced < 0)
                return false;
        }

        if(balanced == 0)
            return true;

        balanced = 0;
        for(int i=n-1; i>=0; i--) {
            if(s[i] == ')' || s[i] == '*')
                balanced++;
            else
                balanced--;

            if(balanced < 0)
                return false;
        }

        return true;
    }
};
```

### Java

```java
class Solution {

    public boolean checkValidString(String s) {
        int count = 0;
        Stack<Integer> op = new Stack<>();
        Stack<Integer> st = new Stack<>();

        for (int i = 0; i < s.length(); ++i) {
            if (s.charAt(i) == '(') op.push(i); // index of opening
            else if (s.charAt(i) == ')') {
                if (op.size() > 0) op.pop(); // if we have brackets
                else if (st.size() > 0) st.pop(); // if not brackets do we have stars
                else return false; // a closing bracket without opening and star
            } else st.push(i); // index of star
        }
        // if we left with some opening bracket that over stars con cover up
        while (op.size() > 0 && st.size() > 0) {
            if (op.peek() > st.peek()) return false;
            op.pop();
            st.pop();
        }

        return op.size() == 0;
    }
}

// Time complexity: O(n)
// Space complexity: O(1)
class Solution2 {

    public boolean checkValidString(String s) {
        int low = 0, high = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') {
                low++;
                high++;
            } else if (s.charAt(i) == ')') {
                if (low > 0) {
                    low--;
                }
                high--;
            } else {
                if (low > 0) {
                    low--;
                }
                high++;
            }
            if (high < 0) {
                return false;
            }
        }
        return low == 0;
    }
}

```
