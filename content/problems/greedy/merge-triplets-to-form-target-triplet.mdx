---
title: Merge Triplets to Form Target Triplet
category: Greedy
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/merge-triplets-to-form-target-triplet)

</Callout>

## Description

A triplet is an array of three integers. You are given a 2D integer array <code>triplets</code>, where <code>triplets[i] = [a<sub>i</sub>, b<sub>i</sub>, c<sub>i</sub>]</code> describes the <code>i<sup>th</sup></code> triplet. You are also given an integer array <code>target = [x, y, z]</code> that describes the triplet you want to obtain.

To obtain <code>target</code>, you may apply the following operation on <code>triplets</code> any number of times (possibly zero):

    - Choose two indices (0-indexed) <code>i</code> and <code>j</code> (<code>i != j</code>) and update <code>triplets[j]</code> to become <code>[max(a<sub>i</sub>, a<sub>j</sub>), max(b<sub>i</sub>, b<sub>j</sub>), max(c<sub>i</sub>, c<sub>j</sub>)]</code>.


    	- For example, if <code>triplets[i] = [2, 5, 3]</code> and <code>triplets[j] = [1, 7, 5]</code>, <code>triplets[j]</code> will be updated to <code>[max(2, 1), max(5, 7), max(3, 5)] = [2, 7, 5]</code>.

Return <code>true</code> _if it is possible to obtain the _<code>target</code>_ triplet _<code>[x, y, z]</code>_ as an element of _<code>triplets</code>_, or _<code>false</code>_ otherwise_.

Example 1:

<br />

<pre className="overflow-x-auto">
	Input: triplets = [[2,5,3],[1,8,4],[1,7,5]], target = [2,7,5] Output: true
	Explanation: Perform the following operations: - Choose the first and last
	triplets [<u>[2,5,3]</u>,[1,8,4],<u>[1,7,5]</u>]. Update the last triplet to
	be [max(2,1), max(5,7), max(3,5)] = [2,7,5]. triplets = [[2,5,3],[1,8,4],
	<u>[2,7,5]</u>] The target triplet [2,7,5] is now an element of triplets.
</pre>

Example 2:

<br />

<pre className="overflow-x-auto">
	Input: triplets = [[3,4,5],[4,5,6]], target = [3,2,5] Output: false
	Explanation: It is impossible to have [3,2,5] as an element because there is
	no 2 in any of the triplets.
</pre>

Example 3:

<br />

<pre className="overflow-x-auto">
	Input: triplets = [[2,5,3],[2,3,4],[1,2,5],[5,2,3]], target = [5,5,5] Output:
	true Explanation: Perform the following operations: - Choose the first and
	third triplets [<u>[2,5,3]</u>,[2,3,4],<u>[1,2,5]</u>,[5,2,3]]. Update the
	third triplet to be [max(2,1), max(5,2), max(3,5)] = [2,5,5]. triplets =
	[[2,5,3],[2,3,4],<u>[2,5,5]</u>,[5,2,3]]. - Choose the third and fourth
	triplets [[2,5,3],[2,3,4],<u>[2,5,5]</u>,<u>[5,2,3]</u>]. Update the fourth
	triplet to be [max(2,5), max(5,2), max(5,3)] = [5,5,5]. triplets =
	[[2,5,3],[2,3,4],[2,5,5],<u>[5,5,5]</u>]. The target triplet [5,5,5] is now an
	element of triplets.
</pre>

Constraints:

    - <code>1 &lt;= triplets.length &lt;= 10<sup>5</sup></code>
    - <code>triplets[i].length == target.length == 3</code>
    - <code>1 &lt;= a<sub>i</sub>, b<sub>i</sub>, c<sub>i</sub>, x, y, z &lt;= 1000</code>

## Solution

### Javascript

```javascript
/**
 * @param {number[][]} triplets
 * @param {number[]} target
 * @return {boolean}
 */
var mergeTriplets = function (triplets, target) {
	var good = new Set()

	for (var t in triplets) {
		var triplet = triplets[t]
		if (
			triplet[0] > target[0] ||
			triplet[1] > target[1] ||
			triplet[2] > target[2]
		) {
			continue
		}

		for (var i = 0; i < triplet.length; i++) {
			if (triplet[i] === target[i]) {
				good.add(i)
			}
		}
	}

	return good.size === 3
}

/**
 * https://leetcode.com/problems/merge-triplets-to-form-target-triplet/
 * Time O(N) | Space O(1)
 * @param {number[][]} triplets
 * @param {number[]} target
 * @return {boolean}
 */
var mergeTriplets = function (triplets, target, res = new Array(3).fill(0)) {
	for (const [a, b, c] of triplets) {
		/* Time O(N) */
		const [_a, _b, _c] = target

		const isTargetGreater = a <= _a && b <= _b && c <= _c
		if (!isTargetGreater) continue

		const [__a, __b, __c] = res
		res = [Math.max(__a, a), Math.max(__b, b), Math.max(__c, c)]
	}

	return res.every((val, i) => val === target[i]) /* Time O(N) */
}

/**
 * https://leetcode.com/problems/merge-triplets-to-form-target-triplet/
 * Time O(N) | Space O(1)
 * @param {number[][]} triplets
 * @param {number[]} target
 * @return {boolean}
 */
var mergeTriplets = function (
	triplets,
	target,
	res = new Array(3).fill(false),
) {
	for (const [a, b, c] of triplets) {
		/* Time O(N) */
		const [_a, _b, _c] = target

		const isTargetGreater = a <= _a && b <= _b && c <= _c
		if (!isTargetGreater) continue

		res[0] |= a === _a
		res[1] |= b === _b
		res[2] |= c === _c
	}

	return res[0] && res[1] && res[2]
}
```

### Python

```python
class Solution:
    def mergeTriplets(self, triplets: List[List[int]], target: List[int]) -> bool:
        good = set()

        for t in triplets:
            if t[0] > target[0] or t[1] > target[1] or t[2] > target[2]:
                continue
            for i, v in enumerate(t):
                if v == target[i]:
                    good.add(i)
        return len(good) == 3

```

### C++

```cpp
/*
    Update: [max(ai,aj), max(bi,bj), max(ci,cj)], return if possible to obtain target
    Ex. triplets = [[2,5,3],[1,8,4],[1,7,5]] target = [2,7,5] -> true, update 1st/3rd

    Skip all "bad" triplets (can never become target), if match add to "good" set

    Time: O(n)
    Space: O(1)
*/

class Solution {
public:
    bool mergeTriplets(vector<vector<int>>& triplets, vector<int>& target) {
        unordered_set<int> s;

        for (int i = 0; i < triplets.size(); i++) {
            if (triplets[i][0] > target[0] || triplets[i][1] > target[1] || triplets[i][2] > target[2]) {
                continue;
            }

            for (int j = 0; j < 3; j++) {
                if (triplets[i][j] == target[j]) {
                    s.insert(j);
                }
            }
        }

        return s.size() == 3;
    }
};

```

### Java

```java
class Solution {

    public boolean mergeTriplets(int[][] triplets, int[] target) {
        boolean[] greedy = new boolean[3];
        loop:for (int[] triplet : triplets) {
            for (int i = 0; i < 3; i++) if (
                triplet[i] > target[i]
            ) continue loop;

            for (int i = 0; i < 3; i++) if (triplet[i] == target[i]) greedy[i] =
                true;
        }

        return greedy[0] && greedy[1] && greedy[2];
    }
}

```
