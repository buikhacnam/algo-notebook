---
title: Last Stone Weight II
category: 2d Dynamic Programming
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/last-stone-weight-ii)

</Callout>

## Description
You are given an array of integers <code>stones</code> where <code>stones[i]</code> is the weight of the <code>i<sup>th</sup></code> stone.

We are playing a game with the stones. On each turn, we choose any two stones and smash them together. Suppose the stones have weights <code>x</code> and <code>y</code> with <code>x &lt;= y</code>. The result of this smash is:


	- If <code>x == y</code>, both stones are destroyed, and
	- If <code>x != y</code>, the stone of weight <code>x</code> is destroyed, and the stone of weight <code>y</code> has new weight <code>y - x</code>.


At the end of the game, there is at most one stone left.

Return *the smallest possible weight of the left stone*. If there are no stones left, return <code>0</code>.

 
Example 1:

<br /><pre className="overflow-x-auto">
Input: stones = [2,7,4,1,8,1]
Output: 1
Explanation:
We can combine 2 and 4 to get 2, so the array converts to [2,7,1,8,1] then,
we can combine 7 and 8 to get 1, so the array converts to [2,1,1,1] then,
we can combine 2 and 1 to get 1, so the array converts to [1,1,1] then,
we can combine 1 and 1 to get 0, so the array converts to [1], then that&#39;s the optimal value.
</pre>

Example 2:

<br /><pre className="overflow-x-auto">
Input: stones = [31,26,33,21,40]
Output: 5
</pre>

 
Constraints:


	- <code>1 &lt;= stones.length &lt;= 30</code>
	- <code>1 &lt;= stones[i] &lt;= 100</code>



## Solution

### Javascript
```javascript
404: Not Found
```
### Python
```python
class Solution:
    def lastStoneWeightII(self, stones: List[int]) -> int:
        # Memoization
        stoneSum = sum(stones)
        target = ceil(stoneSum / 2)

        def dfs(i, total):
            if total >= target or i == len(stones):
                return abs(total - (stoneSum - total))
            if (i, total) in dp:
                return dp[(i, total)]

            dp[(i, total)] = min(dfs(i + 1, total),
                                 dfs(i + 1, total + stones[i]))
            return dp[(i, total)]

        dp = {}
        return dfs(0, 0)

```
### C++
```cpp
404: Not Found
```
### Java
```java
404: Not Found
```


