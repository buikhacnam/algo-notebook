---
title: Number of Music Playlists
category: 2d Dynamic Programming
difficulty: Hard
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/number-of-music-playlists)

</Callout>

## Description
Your music player contains <code>n</code> different songs. You want to listen to <code>goal</code> songs (not necessarily different) during your trip. To avoid boredom, you will create a playlist so that:


	- Every song is played at least once.
	- A song can only be played again only if <code>k</code> other songs have been played.


Given <code>n</code>, <code>goal</code>, and <code>k</code>, return *the number of possible playlists that you can create*. Since the answer can be very large, return it modulo <code>10<sup>9</sup> + 7</code>.
 
Example 1:

<br /><pre className="overflow-x-auto">
Input: n = 3, goal = 3, k = 1
Output: 6
Explanation: There are 6 possible playlists: [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].
</pre>

Example 2:

<br /><pre className="overflow-x-auto">
Input: n = 2, goal = 3, k = 0
Output: 6
Explanation: There are 6 possible playlists: [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2, 1], [2, 1, 2], and [1, 2, 2].
</pre>

Example 3:

<br /><pre className="overflow-x-auto">
Input: n = 2, goal = 3, k = 1
Output: 2
Explanation: There are 2 possible playlists: [1, 2, 1] and [2, 1, 2].
</pre>

 
Constraints:


	- <code>0 &lt;= k &lt; n &lt;= goal &lt;= 100</code>



## Solution

### Javascript
```javascript
404: Not Found
```
### Python
```python
404: Not Found
```
### C++
```cpp
404: Not Found
```
### Java
```java
class Solution {
    public int numMusicPlaylists(int n, int goal, int k) {
        map = new HashMap<>();
        return (int)findPlaylists(0, goal, n, k);
    }

    HashMap<Pair, Integer> map;
    int mod = 1000000007;

    public long findPlaylists(int old_songs, int goal, int n, int k) {
        if(goal == 0 && old_songs == n) {
            return 1;
        }

        if(goal == 0 || old_songs > n) {
            return 0;
        }

        if(map.containsKey(new Pair(old_songs, goal))) {
            return map.get(new Pair(old_songs, goal));
        }

        // chossing an new_song
        long res = ((n - old_songs) * (findPlaylists(old_songs + 1, goal - 1, n, k) % mod)) % mod;

        // choose an old_songs
        if(old_songs > k) {
            res = (res + ((old_songs - k) * (findPlaylists(old_songs, goal - 1, n, k)) % mod) % mod) % mod;
        }

        map.put(new Pair(old_songs, goal), (int)res);

        return res;
    }

    class Pair {
        int a;
        int b;

        public Pair(int a, int b) {
            this.a = a;
            this.b = b;
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj) return true;
            if (obj == null || getClass() != obj.getClass()) return false;
            Pair pair = (Pair) obj;
            return a == pair.a && b == pair.b;
        }

        @Override
        public int hashCode() {
            return 31 * a + b;
        }
    }
}

```


