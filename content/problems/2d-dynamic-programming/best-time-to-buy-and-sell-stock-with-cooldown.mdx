---
title: Best Time to Buy and Sell Stock with Cooldown
category: 2d Dynamic Programming
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown)

</Callout>

## Description
You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day.

Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:


	- After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).


Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).

 
Example 1:

<br /><pre className="overflow-x-auto">
Input: prices = [1,2,3,0,2]
Output: 3
Explanation: transactions = [buy, sell, cooldown, buy, sell]
</pre>

Example 2:

<br /><pre className="overflow-x-auto">
Input: prices = [1]
Output: 0
</pre>

 
Constraints:


	- <code>1 &lt;= prices.length &lt;= 5000</code>
	- <code>0 &lt;= prices[i] &lt;= 1000</code>



## Solution

### Javascript
```javascript
/**
 * Greedy - State Machine
 * Time O(N) | Space O(1)
 * https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/
 * @param {number[]} prices
 * @return {number}
 */
 var maxProfit = (prices) => {
    let [ sold, held, reset ] = [ (-Infinity), (-Infinity), 0 ];

    [ sold, reset ] = search(prices, sold, held, reset);/* Time O(N) */

    return Math.max(sold, reset);
}

var search = (prices, sold, held, reset) => {
    for (const price of prices) {/* Time O(N) */
        const preSold = sold;

        sold = (held + price);
        held = Math.max(held, (reset - price));
        reset = Math.max(reset, preSold);
    }

    return [ sold, reset ];
}

/**
 * DP - Bottom Up
 * Array - Tabulation
 * Time O(N^2) | Space O(N)
 * https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = (prices) => {
    const tabu = initTabu(prices);/* Space O(N) */

    search(prices, tabu);/* Time O(N * N) */

    return tabu[0];
}

var initTabu = (prices) => new Array(prices.length + 2).fill(0);

var search = (prices, tabu) => {
    for (let i = (prices.length - 1); (0 <= i); i--) {/* Time O(N) */
        const prev = buyAndSell(prices, i, tabu);         /* Time O(N) */
        const next = tabu[i + 1];

        tabu[i] = Math.max(prev, next);                       /* Space O(N) */
    }
}

const buyAndSell = (prices, i, tabu, max = 0) => {
    for (let sell = (i + 1); (sell < prices.length); sell++) {/* Time O(N) */
        const profit = ((prices[sell] - prices[i]) + tabu[(sell + 2)]);

        max = Math.max(max, profit);
    }

    return max;
}
```
### Python
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # State: Buying or Selling?
        # If Buy -> i + 1
        # If Sell -> i + 2

        dp = {}  # key=(i, buying) val=max_profit

        def dfs(i, buying):
            if i >= len(prices):
                return 0
            if (i, buying) in dp:
                return dp[(i, buying)]

            cooldown = dfs(i + 1, buying)
            if buying:
                buy = dfs(i + 1, not buying) - prices[i]
                dp[(i, buying)] = max(buy, cooldown)
            else:
                sell = dfs(i + 2, not buying) + prices[i]
                dp[(i, buying)] = max(sell, cooldown)
            return dp[(i, buying)]

        return dfs(0, True)

```
### C++
```cpp
/*
    Array of stock prices, find max profit
    After a sell cooldown of 1 day, can't engage in multiple transactions
    Ex. prices = [1,2,3,0,2] -> 3, transactions = [buy,sell,cd,buy,sell]

    DP + state machine: held ---> sold ---> reset ---> held
                             sell      rest       buy

    Time: O(n)
    Space: O(1) -> optimized from O(n) since only need i - 1 prev state
*/

// class Solution {
// public:
//     int maxProfit(vector<int>& prices) {
//         int n = prices.size();
//         vector<int> s0(n, 0);
//         vector<int> s1(n, 0);
//         vector<int> s2(n, 0);
//         s0[0] = 0;
//         s1[0] = -prices[0];
//         s2[0] = INT_MIN;
//         for (int i = 1; i < n; i++) {
//             s0[i] = max(s0[i - 1], s2[i - 1]);
//             s1[i] = max(s1[i - 1], s0[i - 1] - prices[i]);
//             s2[i] = s1[i - 1] + prices[i];
//         }
//         return max(s0[n - 1], s2[n - 1]);
//     }
// };

class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int sold = 0;
        int hold = INT_MIN;
        int rest = 0;
        
        for (int i = 0; i < prices.size(); i++) {
            int prevSold = sold;
            sold = hold + prices[i];
            hold = max(hold, rest - prices[i]);
            rest = max(rest, prevSold);
        }
        
        return max(sold, rest);
    }
};

```
### Java
```java
class Solution {

    public int maxProfit(int[] prices) {
        Map<String, Integer> cache = new HashMap<>();
        return dfs(prices, cache, 0, true);
    }

    public int dfs(
        int[] prices,
        Map<String, Integer> cache,
        int index,
        boolean buying
    ) {
        if (index >= prices.length) {
            return 0;
        }
        String key = index + "-" + buying;

        if (cache.containsKey(key)) {
            return cache.get(key);
        }

        int cooldown = dfs(prices, cache, index + 1, buying);
        int buyOsell = Integer.MIN_VALUE;

        if (buying) {
            buyOsell = dfs(prices, cache, index + 1, !buying) - prices[index];
        } else {
            buyOsell = dfs(prices, cache, index + 2, !buying) + prices[index];
        }

        cache.put(key, Math.max(buyOsell, cooldown));
        return cache.get(key);
    }
}

```


