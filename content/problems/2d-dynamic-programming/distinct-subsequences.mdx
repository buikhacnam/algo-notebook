---
title: Distinct Subsequences
category: 2d Dynamic Programming
difficulty: Hard
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/distinct-subsequences)

</Callout>

## Description

Given two strings <code>s</code> and <code>t</code>, return _the number of distinct_ <span data-keyword="subsequence-string">_subsequences_</span>_ of _<code>s</code>_ which equals _<code>t</code>.

The test cases are generated so that the answer fits on a 32-bit signed integer.

Example 1:

<br />
<pre className="overflow-x-auto">
	Input: s = &quot;rabbbit&quot;, t = &quot;rabbit&quot; Output: 3 Explanation:
	As shown below, there are 3 ways you can generate &quot;rabbit&quot; from s.
	<code>
		<u>rabb</u>b<u>it</u>
	</code>
	<code>
		<u>ra</u>b<u>bbit</u>
	</code>
	<code>
		<u>rab</u>b<u>bit</u>
	</code>
</pre>

Example 2:

<br />
<pre className="overflow-x-auto">
	Input: s = &quot;babgbag&quot;, t = &quot;bag&quot; Output: 5 Explanation: As
	shown below, there are 5 ways you can generate &quot;bag&quot; from s.
	<code>
		<u>ba</u>b<u>g</u>bag
	</code>
	<code>
		<u>ba</u>bgba<u>g</u>
	</code>
	<code>
		<u>b</u>abgb<u>ag</u>
	</code>
	<code>
		ba<u>b</u>gb<u>ag</u>
	</code>
	<code>
		babg<u>bag</u>
	</code>
</pre>

Constraints:

    - <code>1 &lt;= s.length, t.length &lt;= 1000</code>
    - <code>s</code> and <code>t</code> consist of English letters.

## Solution

### Javascript

```javascript
/**
 * DP - Top Down
 * Matrix - Memoization
 * Time O(N * M) | Space (N * M)
 * https://leetcode.com/problems/distinct-subsequences/
 * @param {string} s
 * @param {string} t
 * @return {number}
 */
var numDistinct = (s, t, i = 0, j = 0, memo = initMemo(s, t)) => {
	const isBaseCase1 = s.length < t.length
	if (isBaseCase1) return 0

	const isBaseCase2 = j === t.length
	if (isBaseCase2) return 1

	const isBaseCase3 = i === s.length
	if (isBaseCase3) return 0

	const hasSeen = memo[i][j] !== null
	if (hasSeen) return memo[i][j]

	return dfs(s, t, i, j, memo) /* Time O(N * M) | Space O((N * M) + HEIGHT) */
}

var initMemo = (s, t) =>
	new Array(s.length).fill().map(() => new Array(t.length).fill(null))

var dfs = (s, t, i, j, memo) => {
	const left = numDistinct(
		s,
		t,
		i + 1,
		j,
		memo,
	) /* Time O(N * M) | Space O(HEIGHT) */

	const isEqual = s[i] === t[j]

	const right = isEqual
		? numDistinct(
				s,
				t,
				i + 1,
				j + 1,
				memo,
		  ) /* Time O(N * M) | Space O(HEIGHT) */
		: 0

	memo[i][j] = left + right /*               | Space O(N * M) */
	return memo[i][j]
}

/**
 * DP - Bottom Up
 * Matrix - Tabulation
 * Time O(N * M) | Space (N * M)
 * https://leetcode.com/problems/distinct-subsequences/
 * @param {string} s
 * @param {string} t
 * @return {number}
 */
var numDistinct = (s, t) => {
	const tabu = initTabu(s, t) /* Time O(N * M) | Space O(N * M) */

	search(s, t, tabu) /* Time O(N * M) | Space O(N * M) */

	return tabu[0][0]
}

var initTabu = (s, t) => {
	const tabu = new Array(s.length + 1)
		.fill() /* Time O(N) | Space O(N) */
		.map(() => new Array(t.length + 1)) /* Time O(M) | Space O(M) */

	tabu[s.length].fill(0) /*           | Space O(N * M) */

	for (let r = 0; r <= s.length; ++r) {
		/* Time O(N) */
		tabu[r][t.length] = 1 /*       | Space O(N * M) */
	}

	return tabu
}

var search = (s, t, tabu) => {
	for (let r = s.length - 1; 0 <= r; r--) {
		/* Time O(N) */
		for (let c = t.length - 1; 0 <= c; c--) {
			/* Time O(M) */
			const left = tabu[r + 1][c]

			const isEqual = s[r] === t[c]

			const right = isEqual ? tabu[r + 1][c + 1] : 0

			tabu[r][c] = left + right /* Space O(N * M) */
		}
	}
}

/**
 * DP - Bottom Up
 * Matrix - Tabulation
 * Time O(N * M) | Space O(M)
 * https://leetcode.com/problems/distinct-subsequences/
 * @param {string} s
 * @param {string} t
 * @return {number}
 */
var numDistinct = (s, t) => {
	const tabu = initTabu(t) /* Time O(M) | Space O(M) */

	search(s, t, tabu) /* Time O(N * M) | Space O(M) */

	return tabu[0]
}

var initTabu = (t) => new Array(t.length).fill(0) /* Time O(M) | Space O(M) */

var search = (s, t, tabu) => {
	for (let row = s.length - 1; 0 <= row; row--) {
		/* Time O(N) */
		let prev = 1

		for (let col = t.length - 1; 0 <= col; col--) {
			/* Time O(M) */
			const curr = tabu[col]

			const isEqual = s[row] === t[col]
			if (isEqual) tabu[col] += prev /* Space O(M) */

			prev = curr
		}
	}
}
```

### Python

```python
class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        cache = {}

        for i in range(len(s) + 1):
            cache[(i, len(t))] = 1
        for j in range(len(t)):
            cache[(len(s), j)] = 0

        for i in range(len(s) - 1, -1, -1):
            for j in range(len(t) - 1, -1, -1):
                if s[i] == t[j]:
                    cache[(i, j)] = cache[(i + 1, j + 1)] + cache[(i + 1, j)]
                else:
                    cache[(i, j)] = cache[(i + 1, j)]
        return cache[(0, 0)]

```

### C++

```cpp
/*
    Given 2 strings s & t:
    Return # of distinct subsequences of s which equals t
    Ex. s = "rabbbit", t = "rabbit" -> 3, RABBbIT, RAbBBIT, RABbBIT

    DFS + memo, cache on i & j indices to the # of distinct subseq
    2 choices: if chars equal, look at remainder of both s & t
               if chars not equal, only look at remainder of s

    Time: O(m x n)
    Space: O(m x n)
*/

class Solution {
public:
    int numDistinct(string s, string t) {
        return dfs(s, t, 0, 0);
    }
private:
    // {(i, j) -> # of distinct subsequences}
    map<pair<int, int>, int> dp;

    int dfs(string& s, string& t, int i, int j) {
        if (j == t.size()) {
            return 1;
        }
        if (i == s.size()) {
            return 0;
        }
        if (dp.find({i, j}) != dp.end()) {
            return dp[{i, j}];
        }

        if (s[i] == t[j]) {
            dp[{i, j}] = dfs(s, t, i + 1, j + 1) + dfs(s, t, i + 1, j);
        } else {
            dp[{i, j}] = dfs(s, t, i + 1, j);
        }
        return dp[{i, j}];
    }
};

```

### Java

```java
// Dynammic Programming - Memoization
// Time Complexity O(s * t) | Space Complexity O(s * t)
class Solution {

    public int numDistinct(String s, String t) {
        int n = s.length() + 1;
        int m = t.length() + 1;
        int[][] memo = new int[n][m];

        for (int[] row : memo) {
            Arrays.fill(row, -1);
        }

        return recursion(s, t, 0, 0, memo);
    }

    public int recursion(String s, String t, int sIdx, int tIdx, int[][] memo) {
        if (memo[sIdx][tIdx] != -1) {
            return memo[sIdx][tIdx];
        }

        if (tIdx >= t.length()) {
            return 1;
        }

        if (sIdx >= s.length()) {
            return 0;
        }

        if (t.charAt(tIdx) == s.charAt(sIdx)) {
            memo[sIdx][tIdx] =
                recursion(s, t, sIdx + 1, tIdx + 1, memo) +
                recursion(s, t, sIdx + 1, tIdx, memo);
            return memo[sIdx][tIdx];
        }

        memo[sIdx][tIdx] = recursion(s, t, sIdx + 1, tIdx, memo);
        return memo[sIdx][tIdx];
    }
}

```
