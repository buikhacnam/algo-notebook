---
title: Edit Distance
category: 2d Dynamic Programming
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/edit-distance)

</Callout>

## Description

Given two strings <code>word1</code> and <code>word2</code>, return _the minimum number of operations required to convert <code>word1</code> to <code>word2</code>_.

You have the following three operations permitted on a word:

    - Insert a character
    - Delete a character
    - Replace a character

Example 1:

<br />

<pre className="overflow-x-auto">
	Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot; Output: 3
	Explanation: horse -&gt; rorse (replace &#39;h&#39; with &#39;r&#39;) rorse
	-&gt; rose (remove &#39;r&#39;) rose -&gt; ros (remove &#39;e&#39;)
</pre>

Example 2:

<br />

<pre className="overflow-x-auto">
	Input: word1 = &quot;intention&quot;, word2 = &quot;execution&quot; Output: 5
	Explanation: intention -&gt; inention (remove &#39;t&#39;) inention -&gt;
	enention (replace &#39;i&#39; with &#39;e&#39;) enention -&gt; exention
	(replace &#39;n&#39; with &#39;x&#39;) exention -&gt; exection (replace
	&#39;n&#39; with &#39;c&#39;) exection -&gt; execution (insert &#39;u&#39;)
</pre>

Constraints:

    - <code>0 &lt;= word1.length, word2.length &lt;= 500</code>
    - <code>word1</code> and <code>word2</code> consist of lowercase English letters.

## Solution

### Javascript

```javascript
/**
 * Brute Force - DFS
 * Time O(2^(N + M)) | Space O(N * M)
 * https://leetcode.com/problems/edit-distance/
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
var minDistance = (word1, word2, i = 0, j = 0) => {
	const isBaseCase1 = word1.length * word2.length === 0
	if (isBaseCase1) return word1.length + word2.length

	const isBaseCase2 = word1.length === i
	if (isBaseCase2) return word2.length - j

	const isBaseCase3 = word2.length === j
	if (isBaseCase3) return word1.length - i

	return dfs(
		word1,
		word2,
		i,
		j,
	) /* Time O(2^(N + M)) | Space O((N * M) + HEIGHT) */
}

var dfs = (word1, word2, i, j) => {
	const isEqual = word1[i] === word2[j]
	if (isEqual)
		return minDistance(
			word1,
			word2,
			i + 1,
			j + 1,
		) /* Time O(2^(N + M)) | Space O((N * M) + HEIGHT) */

	const insert = minDistance(
		word1,
		word2,
		i,
		j + 1,
	) /* Time O(2^(N + M)) | Space O((N * M) + HEIGHT) */
	const _delete = minDistance(
		word1,
		word2,
		i + 1,
		j,
	) /* Time O(2^(N + M)) | Space O((N * M) + HEIGHT) */
	const replace = minDistance(
		word1,
		word2,
		i + 1,
		j + 1,
	) /* Time O(2^(N + M)) | Space O((N * M) + HEIGHT) */

	return Math.min(insert, _delete, replace) + 1
}

/**
 * DP - Top Down
 * Matrix - Memoization
 * Time O(N * M) | Space O(N * M)
 * https://leetcode.com/problems/edit-distance/
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
var minDistance = (
	word1,
	word2,
	i = 0,
	j = 0,
	memo = initMemo(word1, word2),
) => {
	const isBaseCase1 = word1.length * word2.length === 0
	if (isBaseCase1) return word1.length + word2.length

	const isBaseCase2 = word1.length === i
	if (isBaseCase2) return word2.length - j

	const isBaseCase3 = word2.length === j
	if (isBaseCase3) return word1.length - i

	const hasSeen = memo[i][j] !== -1
	if (hasSeen) return memo[i][j]

	return dfs(
		word1,
		word2,
		i,
		j,
		memo,
	) /* Time O(N * M) | Space O((N * M) + HEIGHT) */
}

var initMemo = (word1, word2) =>
	new Array(word1.length)
		.fill() /* Time O(N) | Space O(N) */
		.map(() => new Array(word2.length).fill(-1)) /* Time O(N) | Space O(N) */

var dfs = (word1, word2, i, j, memo) => {
	const isEqual = word1[i] === word2[j]
	if (isEqual) {
		memo[i][j] = minDistance(
			word1,
			word2,
			i + 1,
			j + 1,
			memo,
		) /* Time O(N * M) | Space O(HEIGHT) */
		return memo[i][j]
	}

	const insert = minDistance(
		word1,
		word2,
		i,
		j + 1,
		memo,
	) /* Time O(N * M) | Space O(HEIGHT) */
	const _delete = minDistance(
		word1,
		word2,
		i + 1,
		j,
		memo,
	) /* Time O(N * M) | Space O(HEIGHT) */
	const replace = minDistance(
		word1,
		word2,
		i + 1,
		j + 1,
		memo,
	) /* Time O(N * M) | Space O(HEIGHT) */

	memo[i][j] =
		Math.min(insert, _delete, replace) + 1 /*               | Space O(N * M) */
	return memo[i][j]
}

/**
 * DP - Bottom Up
 * Matrix - Tabulation
 * Time O(N * M) | Space O(N * M)
 * https://leetcode.com/problems/edit-distance/
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
var minDistance = (word1, word2) => {
	const isEmpty = word1.length * word2.length === 0
	if (isEmpty) return word1.length + word2.length

	const tabu = initTabu(word1, word2) /* Time O(N * M) | Space O(N * M) */

	search(word1, word2, tabu) /* Time O(N * M) | Space O(N * M) */

	return tabu[word1.length][word2.length]
}

var initTabu = (word1, word2) => {
	const tabu = new Array(word1.length + 1)
		.fill() /* Time O(N) | Space O(N) */
		.map(() => new Array(word2.length + 1).fill(0)) /* Time O(M) | Space O(M) */

	for (let i = 0; i < word1.length + 1; i++) {
		/* Time O(N) */
		tabu[i][0] = i /*        | Space O(N * M) */
	}

	for (let j = 0; j < word2.length + 1; j++) {
		/* Time O(M) */
		tabu[0][j] = j /*        | Space O(N * M) */
	}

	return tabu
}

var search = (word1, word2, tabu) => {
	for (let i = 1; i < word1.length + 1; i++) {
		/* Time O(N) */
		for (let j = 1; j < word2.length + 1; j++) {
			/* Time O(M) */
			const left = tabu[i - 1][j] + 1
			const down = tabu[i][j - 1] + 1

			const isEqual = word1[i - 1] === word2[j - 1]
			const leftDown = tabu[i - 1][j - 1] + Number(!isEqual)

			tabu[i][j] = Math.min(left, down, leftDown) /* Space O(N * M) */
		}
	}
}

/**
 * DP - Bottom Up
 * Matrix - Tabulation
 * Time O(N * M) | Space O(M)
 * https://leetcode.com/problems/edit-distance/
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
var minDistance = (word1, word2) => {
	const tabu = initTabu(word2) /* Time O(M) | Space O(M) */

	search(word1, word2, tabu) /* Time O(N * M) | Space O(M) */

	return tabu[word2.length]
}

var initTabu = (word2) => {
	const tabu = new Array(word2.length + 1).fill(0) /* Time O(M) | Space O(M) */

	for (let j = 1; j <= word2.length; j++) {
		/* Time O(M) */
		tabu[j] = j /*           | Space O(M) */
	}

	return tabu
}

var search = (word1, word2, tabu) => {
	for (let i = 1; i <= word1.length; i++) {
		/* Time O(N) */
		tabu[word2.length] = update(
			word1,
			word2,
			i,
			tabu,
		) /* Time O(M) | Space (M) */
	}
}

const update = (word1, word2, i, tabu) => {
	let temp = i

	for (let j = 1; j <= word2.length; ++j) {
		/* Time O(M  */
		const isEqual = word1[i - 1] === word2[j - 1]
		const cur = isEqual ? tabu[j - 1] : Math.min(tabu[j - 1], tabu[j], temp) + 1

		tabu[j - 1] = temp /* Space (M) */
		temp = cur
	}

	return temp
}
```

### Python

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        dp = [[float("inf")] * (len(word2) + 1) for i in range(len(word1) + 1)]

        for j in range(len(word2) + 1):
            dp[len(word1)][j] = len(word2) - j
        for i in range(len(word1) + 1):
            dp[i][len(word2)] = len(word1) - i

        for i in range(len(word1) - 1, -1, -1):
            for j in range(len(word2) - 1, -1, -1):
                if word1[i] == word2[j]:
                    dp[i][j] = dp[i + 1][j + 1]
                else:
                    dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j + 1], dp[i + 1][j + 1])
        return dp[0][0]

```

### C++

```cpp
/*
    Given 2 strings, return minimum number of operations to convert word1 to word2

    Naive: check all possible edit sequences & choose shortest one
    Optimal: DP, if chars at i & j same, no operations needed, else 3 cases:
    (1) replace (i - 1, j - 1), (2) delete (i - 1, j), (3) insert (i, j - 1)

    Time: O(m x n)
    Space: O(m x n)
*/

class Solution {
public:
    int minDistance(string word1, string word2) {
        if (word1.empty() && word2.empty()) {
            return 0;
        }
        if (word1.empty() || word2.empty()) {
            return 1;
        }

        int m = word1.size();
        int n = word2.size();

        vector<vector<int>> dp(m + 1, vector<int>(n + 1));

        // base cases (convert to empty string w/ deletions), dist is just length
        for (int i = 1; i <= m; i++) {
            dp[i][0] = i;
        }
        for (int j = 1; j <= n; j++) {
            dp[0][j] = j;
        }

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (word1[i - 1] == word2[j - 1]) {
                    // no operation needed, same char
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    // min(replace, delete, insert) + 1 <-- since an op was needed
                    dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1;
                }
            }
        }

        return dp[m][n];
    }
};

// Since we only need at most dp[i - 1][j - 1], can space optimize to O(n)
// class Solution {
// public:
//     int minDistance(string word1, string word2) {
//         int m = word1.size();
//         int n = word2.size();
//         int prev = 0;
//         vector<int> curr(n + 1);
//         for (int j = 1; j <= n; j++) {
//             curr[j] = j;
//         }
//         for (int i = 1; i <= m; i++) {
//             prev = curr[0];
//             curr[0] = i;
//             for (int j = 1; j <= n; j++) {
//                 int temp = curr[j];
//                 if (word1[i - 1] == word2[j - 1]) {
//                     curr[j] = prev;
//                 } else {
//                     curr[j] = min(prev, min(curr[j - 1], curr[j])) + 1;
//                 }
//                 prev = temp;
//             }
//         }
//         return curr[n];
//     }
// };

```

### Java

```java
//Refer to neetcode's video

//Memoized code

class Solution {

    public int minDistance(String word1, String word2) {
        int m = word1.length() - 1;
        int n = word2.length() - 1;
        int[][] dp = new int[m + 2][n + 2];
        for (int[] d : dp) {
            Arrays.fill(d, -1);
        }
        return helper(word1, word2, m, n, dp);
    }

    public int helper(String word1, String word2, int m, int n, int[][] dp) {
        //the strings are null
        if (m + 1 == 0 && n + 1 == 0) {
            return 0;
        }
        //one of the strings are null
        if (m + 1 == 0 || n + 1 == 0) {
            return Math.max(m + 1, n + 1);
        }
        //both values at the index are equal
        if (dp[m][n] != -1) return dp[m][n];
        if (word1.charAt(m) == word2.charAt(n)) {
            dp[m][n] = helper(word1, word2, m - 1, n - 1, dp);
            return dp[m][n];
        } else {
            //try deletion
            int delete = 1 + helper(word1, word2, m - 1, n, dp);
            //try insertion
            int insert = 1 + helper(word1, word2, m, n - 1, dp);
            //try replacing
            int replace = 1 + helper(word1, word2, m - 1, n - 1, dp);
            //now we'll choose the minimum out of these 3 and add 1 for the operation cost
            dp[m][n] = Math.min(Math.min(delete, insert), replace);
            return dp[m][n];
        }
    }
}

```
