---
title: Ones and Zeroes
category: 2d Dynamic Programming
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/ones-and-zeroes)

</Callout>

## Description

You are given an array of binary strings <code>strs</code> and two integers <code>m</code> and <code>n</code>.

Return _the size of the largest subset of <code>strs</code> such that there are at most _<code>m</code>\* _<code>0</code> and _<code>n</code>\_ \_<code>1</code> in the subset\*.

A set <code>x</code> is a subset of a set <code>y</code> if all elements of <code>x</code> are also elements of <code>y</code>.

Example 1:

<br />
<pre className="overflow-x-auto">

</pre>

Example 2:

<br />
<pre className="overflow-x-auto">

Input: strs = [&quot; 10 &quot; , &quot; 0 &quot;, &quot; 1 &quot;], m = 1, n = 1
Output: 2

<b>Explanation:</b> The largest subset is {&quot;0&quot;, &quot;1&quot;}, so the answer is 2.

</pre>

Constraints:

    - <code>1 &lt;= strs.length &lt;= 600</code>
    - <code>1 &lt;= strs[i].length &lt;= 100</code>
    - <code>strs[i]</code> consists only of digits <code>&#39;0&#39;</code> and <code>&#39;1&#39;</code>.
    - <code>1 &lt;= m, n &lt;= 100</code>

## Solution

### Javascript

```javascript
Solution will be updated soon
```

### Python

```python
class Solution:
    def findMaxForm(self, strs: List[str], M: int, N: int) -> int:
        # Dynamic Programming
        dp = defaultdict(int)

        for s in strs:
            mCnt, nCnt = s.count("0"), s.count("1")
            for m in range(M, mCnt - 1, -1):
                for n in range(N, nCnt - 1, -1):
                    dp[(m, n)] = max(
                        1 + dp[(m - mCnt, n - nCnt)],
                        dp[(m, n)])
        return dp[(M, N)]

        # Memoization
        dp = {}

        def dfs(i, m, n):
            if i == len(strs):
                return 0
            if (i, m, n) in dp:
                return dp[(i, m, n)]

            mCnt, nCnt = strs[i].count("0"), strs[i].count("1")
            dp[(i, m, n)] = dfs(i + 1, m, n)
            if mCnt <= m and nCnt <= n:
                dp[(i, m, n)] = max(
                    dp[(i, m, n)],
                    1 + dfs(i + 1, m - mCnt, n - nCnt))
            return dp[(i, m, n)]

        return dfs(0, m, n)

```

### C++

```cpp
class Solution {
public:
    int rec(vector<pair<int, int>>& oz, int i, int m, int n, vector<vector<vector<int>>>& dp)
    {
        if (i >= oz.size())
            return 0;

        if (oz[i].first > m || oz[i].second > n)
            return rec(oz, i + 1, m, n, dp);

        if (dp[i][m][n] != -1)
            return dp[i][m][n];

        int take = 1 + rec(oz, i + 1, m - oz[i].first, n - oz[i].second, dp);
        int notTake = rec(oz, i + 1, m, n, dp);

        return dp[i][m][n] = max(take, notTake);
    }
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<pair<int, int>> oz(strs.size());
        vector<vector<vector<int>>> dp (strs.size() + 1, vector<vector<int>>(m + 1, vector<int> (n + 1, -1)));

        for (int i = 0; i < strs.size(); i++)
        {
            int one = 0, zero = 0;
            for (int j = 0; j < strs[i].size(); j++)
            {
                if (strs[i][j] == '1')
                    one++;
                else
                    zero++;
            }
            oz[i] = {zero, one};
        }

        return rec(oz, 0, m, n, dp);
    }
};

```

### Java

```java
Solution will be updated soon
```
