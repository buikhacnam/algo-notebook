---
title: Ones and Zeroes
category: 2d Dynamic Programming
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/ones-and-zeroes)

</Callout>

## Description
You are given an array of binary strings <code>strs</code> and two integers <code>m</code> and <code>n</code>.

Return *the size of the largest subset of <code>strs</code> such that there are at most *<code>m</code>* *<code>0</code>*&#39;s and *<code>n</code>* *<code>1</code>*&#39;s in the subset*.

A set <code>x</code> is a subset of a set <code>y</code> if all elements of <code>x</code> are also elements of <code>y</code>.

 
Example 1:

<br /><pre className="overflow-x-auto">
Input: strs = [&quot;10&quot;,&quot;0001&quot;,&quot;111001&quot;,&quot;1&quot;,&quot;0&quot;], m = 5, n = 3
Output: 4
Explanation: The largest subset with at most 5 0&#39;s and 3 1&#39;s is {&quot;10&quot;, &quot;0001&quot;, &quot;1&quot;, &quot;0&quot;}, so the answer is 4.
Other valid but smaller subsets include {&quot;0001&quot;, &quot;1&quot;} and {&quot;10&quot;, &quot;1&quot;, &quot;0&quot;}.
{&quot;111001&quot;} is an invalid subset because it contains 4 1&#39;s, greater than the maximum of 3.
</pre>

Example 2:

<br /><pre className="overflow-x-auto">
Input: strs = [&quot;10&quot;,&quot;0&quot;,&quot;1&quot;], m = 1, n = 1
Output: 2
<b>Explanation:</b> The largest subset is {&quot;0&quot;, &quot;1&quot;}, so the answer is 2.
</pre>

 
Constraints:


	- <code>1 &lt;= strs.length &lt;= 600</code>
	- <code>1 &lt;= strs[i].length &lt;= 100</code>
	- <code>strs[i]</code> consists only of digits <code>&#39;0&#39;</code> and <code>&#39;1&#39;</code>.
	- <code>1 &lt;= m, n &lt;= 100</code>



## Solution

### Javascript
```javascript
404: Not Found
```
### Python
```python
class Solution:
    def findMaxForm(self, strs: List[str], M: int, N: int) -> int:
        # Dynamic Programming
        dp = defaultdict(int)

        for s in strs:
            mCnt, nCnt = s.count("0"), s.count("1")
            for m in range(M, mCnt - 1, -1):
                for n in range(N, nCnt - 1, -1):
                    dp[(m, n)] = max(
                        1 + dp[(m - mCnt, n - nCnt)],
                        dp[(m, n)])
        return dp[(M, N)]
        
        # Memoization
        dp = {}

        def dfs(i, m, n):
            if i == len(strs):
                return 0
            if (i, m, n) in dp:
                return dp[(i, m, n)]
            
            mCnt, nCnt = strs[i].count("0"), strs[i].count("1")
            dp[(i, m, n)] = dfs(i + 1, m, n)
            if mCnt <= m and nCnt <= n:
                dp[(i, m, n)] = max(
                    dp[(i, m, n)], 
                    1 + dfs(i + 1, m - mCnt, n - nCnt))
            return dp[(i, m, n)]

        return dfs(0, m, n)

```
### C++
```cpp
class Solution {
public:
    int rec(vector<pair<int, int>>& oz, int i, int m, int n, vector<vector<vector<int>>>& dp)
    {
        if (i >= oz.size())
            return 0;

        if (oz[i].first > m || oz[i].second > n)
            return rec(oz, i + 1, m, n, dp);
        
        if (dp[i][m][n] != -1)
            return dp[i][m][n];
        
        int take = 1 + rec(oz, i + 1, m - oz[i].first, n - oz[i].second, dp);
        int notTake = rec(oz, i + 1, m, n, dp);

        return dp[i][m][n] = max(take, notTake);
    }
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<pair<int, int>> oz(strs.size());
        vector<vector<vector<int>>> dp (strs.size() + 1, vector<vector<int>>(m + 1, vector<int> (n + 1, -1)));

        for (int i = 0; i < strs.size(); i++)
        {
            int one = 0, zero = 0;
            for (int j = 0; j < strs[i].size(); j++)
            {
                if (strs[i][j] == '1')
                    one++;
                else
                    zero++;
            }
            oz[i] = {zero, one};
        }
        
        return rec(oz, 0, m, n, dp);
    }
};

```
### Java
```java
404: Not Found
```


