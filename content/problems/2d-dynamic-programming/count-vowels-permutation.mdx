---
title: Count Vowels Permutation
category: 2d Dynamic Programming
difficulty: Hard
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/count-vowels-permutation)

</Callout>

## Description

Given an integer <code>n</code>, your task is to count how many strings of length <code>n</code> can be formed under the following rules:

    - Each character is a lower case vowel (<code>&#39;a&#39;</code>, <code>&#39;e&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;o&#39;</code>, <code>&#39;u&#39;</code>)
    - Each vowel <code>&#39;a&#39;</code> may only be followed by an <code>&#39;e&#39;</code>.
    - Each vowel <code>&#39;e&#39;</code> may only be followed by an <code>&#39;a&#39;</code> or an <code>&#39;i&#39;</code>.
    - Each vowel <code>&#39;i&#39;</code> may not be followed by another <code>&#39;i&#39;</code>.
    - Each vowel <code>&#39;o&#39;</code> may only be followed by an <code>&#39;i&#39;</code> or a <code>&#39;u&#39;</code>.
    - Each vowel <code>&#39;u&#39;</code> may only be followed by an <code>&#39;a&#39;.</code>

Since the answer may be too large, return it modulo <code>10^9 + 7.</code>

Example 1:

<br />
<pre className="overflow-x-auto">
	Input: n = 1 Output: 5 Explanation: All possible strings are: &quot;a&quot;,
	&quot;e&quot;, &quot;i&quot; , &quot;o&quot; and &quot;u&quot;.
</pre>

Example 2:

<br />
<pre className="overflow-x-auto">
	Input: n = 2 Output: 10 Explanation: All possible strings are: &quot;ae&quot;,
	&quot;ea&quot;, &quot;ei&quot;, &quot;ia&quot;, &quot;ie&quot;,
	&quot;io&quot;, &quot;iu&quot;, &quot;oi&quot;, &quot;ou&quot; and
	&quot;ua&quot;.
</pre>

Example 3:

<br />
<pre className="overflow-x-auto">Input: n = 5 Output: 68</pre>

Constraints:

    - <code>1 &lt;= n &lt;= 2 * 10^4</code>

## Solution

### Javascript

```javascript
Solution will be updated soon
```

### Python

```python
class Solution:
    Memo = {}
    def countVowelPermutation(self, n, c = '') -> int:
        if (c, n) in self.Memo:
            return self.Memo[(c, n)]
        if n == 1:
            if c == 'a':
                return 1
            if c == 'e':
                return 2
            if c == 'i':
                return 4
            if c == 'o':
                return 2
            if c == 'u':
                return 1
            if c == '':
                return 5
        else:
            if c == 'a':
                self.Memo[('a', n)] = self.countVowelPermutation(n - 1, 'e')
                return self.Memo[('a', n)]
            if c == 'e':
                self.Memo[('e', n)] = self.countVowelPermutation(n - 1, 'a') + self.countVowelPermutation(n - 1, 'i')
                return self.Memo[('e', n)]
            if c == 'i':
                self.Memo[('i', n)] = self.countVowelPermutation(n - 1, 'a') + self.countVowelPermutation(n - 1, 'e') + self.countVowelPermutation(n - 1, 'o') + self.countVowelPermutation(n - 1, 'u')
                return self.Memo[('i', n)]
            if c == 'o':
                self.Memo[('o', n)] = self.countVowelPermutation(n - 1, 'i') + self.countVowelPermutation(n - 1, 'u')
                return self.Memo[('o', n)]
            if c == 'u':
                self.Memo[('u', n)] = self.countVowelPermutation(n - 1, 'a')
                return self.Memo[('u', n)]
            if c == '':
                Tot = 0
                for i in ['a', 'e', 'i', 'o', 'u']:
                    Tot = Tot + self.countVowelPermutation(n - 1, i);
                return Tot % 1000000007

```

### C++

```cpp
/*
Given an integer n, our task is to count how many strings of length n can be formed under the following rules:

Each character is a lower case vowel ('a', 'e', 'i', 'o', 'u')
Each vowel 'a' may only be followed by an 'e'.
Each vowel 'e' may only be followed by an 'a' or an 'i'.
Each vowel 'i' may not be followed by another 'i'.
Each vowel 'o' may only be followed by an 'i' or a 'u'.
Each vowel 'u' may only be followed by an 'a'.
Since the answer may be too large, we have to return it modulo 10^9 + 7.

Example. For n = 2, Output = 10

	Explanation: All possible strings of length 2 that can be formed as per the given rules are: "ae", "ea", "ei", "ia", "ie", "io", "iu",
	"oi", "ou" and "ua".
	So we return 10 as our answer.


Time: O(n)
Space: O(1)

*/


class Solution {
const unsigned int mod = 1e9+7;
public:
    int countVowelPermutation(int n) {
        vector<int> prev(5,1), curr(5, 0);
        for(int i=1; i<n; i++) {
            curr[0] = prev[1] % mod;
            curr[1] = (prev[0] + prev[2]) % mod;
            curr[2] = ((prev[0] % mod) + (prev[1] % mod) + (prev[3] % mod) + (prev[4] % mod)) % mod;
            curr[3] = (prev[4] + prev[2]) % mod;
            curr[4] = prev[0] % mod;
            prev = curr;
        }
        int ans = 0;
        for(auto &a:prev) ans = (ans + a) % mod;
        return ans;
    }
};
```

### Java

```java
class Solution {
    // 0: 'a', 1: 'e', 2: 'i', 3: 'o', 4: 'u'

    private static int MOD = 1_000_000_000 + 7;

    private int getSum(long[] arr) {
        long sum = 0;
        for(long x: arr) {
            sum = sum + x;
            sum = sum % MOD;
        }
        return (int) sum;
    }

    private long[] getBaseCounts() {
        return new long[]{1, 1, 1, 1, 1};
    }

    private Map<Integer, List<Integer>> getNextCountMapping() {
        Map<Integer, List<Integer>> map = new HashMap<>();

        /*  0   1   2   3   4
            a   e   i   o   u

            Reverse mapping i.e. "depends on"
            {a: [e, i, u]}, {e: [a, i]}, {i: [e, o]},
            {o: [i]}, {u: [i, o]}
        */

        map.put(0, new ArrayList<>(List.of(1, 2, 4)));
        map.put(1, new ArrayList<>(List.of(0, 2)));
        map.put(2, new ArrayList<>(List.of(1, 3)));
        map.put(3, new ArrayList<>(List.of(2)));
        map.put(4, new ArrayList<>(List.of(2, 3)));

        return map;
    }

    private long[] getNextCounts(
        long[] currentCounts,
        Map<Integer, List<Integer>> mapNextCounting
    ) {
        long[] nextCounts = new long[5];
        Arrays.fill(nextCounts, 0);

        // Mapping conversion
        for(int key: mapNextCounting.keySet()) {
            for(int val: mapNextCounting.get(key)) {
                nextCounts[val] += (long) currentCounts[key];
                nextCounts[val] %= MOD;
            }
        }

        return nextCounts;
    }

    public int countVowelPermutation(int n) {
        long[] counts = getBaseCounts();
        if(n == 1) {
            return getSum(counts);
        }

        Map<Integer, List<Integer>> mapNextCounting;
        mapNextCounting = getNextCountMapping();

        for(int i=1; i<n; i++) {
            counts = getNextCounts(counts, mapNextCounting);
        }

        return getSum(counts);
    }
}

```
