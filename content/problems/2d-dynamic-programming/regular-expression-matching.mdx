---
title: Regular Expression Matching
category: 2d Dynamic Programming
difficulty: Hard
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/regular-expression-matching)

</Callout>

## Description

Given an input string <code>s</code> and a pattern <code>p</code>, implement regular expression matching with support for <code>&#39;.&#39;</code> and <code>&#39;\*&#39;</code> where:

    - <code>&#39;.&#39;</code> Matches any single character.​​​​
    - <code>&#39;*&#39;</code> Matches zero or more of the preceding element.

The matching should cover the entire input string (not partial).

Example 1:

<br />

<pre className="overflow-x-auto">
	Input: s = &quot;aa&quot;, p = &quot;a&quot; Output: false Explanation:
	&quot;a&quot; does not match the entire string &quot;aa&quot;.
</pre>

Example 2:

<br />

<pre className="overflow-x-auto">
	Input: s = &quot;aa&quot;, p = &quot;a*&quot; Output: true Explanation:
	&#39;*&#39; means zero or more of the preceding element, &#39;a&#39;.
	Therefore, by repeating &#39;a&#39; once, it becomes &quot;aa&quot;.
</pre>

Example 3:

<br />

<pre className="overflow-x-auto">
	Input: s = &quot;ab&quot;, p = &quot;.*&quot; Output: true Explanation:
	&quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.
</pre>

Constraints:

    - <code>1 &lt;= s.length &lt;= 20</code>
    - <code>1 &lt;= p.length &lt;= 20</code>
    - <code>s</code> contains only lowercase English letters.
    - <code>p</code> contains only lowercase English letters, <code>&#39;.&#39;</code>, and <code>&#39;*&#39;</code>.
    - It is guaranteed for each appearance of the character <code>&#39;*&#39;</code>, there will be a previous valid character to match.

## Solution

### Javascript

```javascript
/**
 * Brute Force - DFS
 * Time O((N + M) * 2^(N + (M / 2))) | Space O(N^2 + M^2)
 * https://leetcode.com/problems/regular-expression-matching/
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = (text, pattern) => {
	const isBaseCase = pattern.length === 0
	if (isBaseCase) return text.length === 0

	const isTextAndPatternEqual = pattern[0] === text[0],
		isPatternPeriod = pattern[0] === '.',
		isFirstMatch = text && (isTextAndPatternEqual || isPatternPeriod),
		isNextPatternWildCard = pattern.length >= 2 && pattern[1] === '*'

	return isNextPatternWildCard /* Time O((N + M) * 2^(N + (M / 2))) | Space O(N^2 + M^2) */
		? isMatch(text, pattern.slice(2)) ||
				(isFirstMatch && isMatch(text.slice(1), pattern))
		: isFirstMatch && isMatch(text.slice(1), pattern.slice(1))
}

/**
 * DP - Top Down
 * Matrix - Memoization
 * Time O(N * M) | Space O(N * M)
 * https://leetcode.com/problems/regular-expression-matching/
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = (
	text,
	pattern,
	row = 0,
	col = 0,
	memo = initMemo(text, pattern),
) => {
	const hasSeen = memo[row][col]
	if (hasSeen) return memo[row][col]

	const isEqual = col === pattern.length
	const ans = isEqual
		? row === text.length
		: check(text, pattern, row, col, memo) /* Time O(N * M) | Space O(N * M) */

	memo[row][col] = ans
	return ans
}

var initMemo = (text, pattern) =>
	new Array(text.length + 1)
		.fill() /* Time O(N) | Space O(N) */
		.map(() =>
			new Array(pattern.length + 1).fill(false),
		) /* Time O(M) | Space O(M) */

var check = (text, pattern, row, col, memo) => {
	const isTextDefined = row < text.length,
		isTextAndPatternEqual = pattern[col] === text[row],
		isPatternPeriod = pattern[col] === '.',
		isFirstMatch = isTextDefined && (isTextAndPatternEqual || isPatternPeriod),
		isNextPatternWildCard = col + 1 < pattern.length && pattern[col + 1] === '*'

	return isNextPatternWildCard /* Time O(N * M) | Space O(N * M) */
		? isMatch(text, pattern, row, col + 2, memo) ||
				(isFirstMatch && isMatch(text, pattern, row + 1, col, memo))
		: isFirstMatch && isMatch(text, pattern, row + 1, col + 1, memo)
}

/**
 * Time O(N * M) | Space O(N * M)
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = (text, pattern) => {
	const tabu = initTabu(text, pattern) /* Time O(N * M) | Space O(N * M) */

	search(text, pattern, tabu) /* Time O(N * M) | Space O(N * M) */

	return tabu[0][0]
}

var initTabu = (text, pattern) => {
	const tabu = new Array(text.length + 1)
		.fill() /* Time O(N) | Space O(N) */
		.map(() =>
			new Array(pattern.length + 1).fill(false),
		) /* Time O(M) | Space O(M) */

	tabu[text.length][pattern.length] = true /*           | Space O(N * M) */

	return tabu
}

var search = (text, pattern, tabu) => {
	for (let row = text.length; 0 <= row; row--) {
		/* Time O(N) */
		for (let col = pattern.length - 1; 0 <= col; col--) {
			/* Time O(M) */
			const isTextDefined = row < text.length,
				isTextAndPatternEqual = pattern[col] === text[row],
				isPatternPeriod = pattern[col] === '.',
				isFirstMatch =
					isTextDefined && (isTextAndPatternEqual || isPatternPeriod),
				isNextPatternWildCard =
					col + 1 < pattern.length && pattern[col + 1] === '*'

			tabu[row][col] = isNextPatternWildCard /* Space O(N * M) */
				? tabu[row][col + 2] || (isFirstMatch && tabu[row + 1][col])
				: isFirstMatch && tabu[row + 1][col + 1]
		}
	}
}
```

### Python

```python
# BOTTOM-UP Dynamic Programming
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        cache = [[False] * (len(p) + 1) for i in range(len(s) + 1)]
        cache[len(s)][len(p)] = True

        for i in range(len(s), -1, -1):
            for j in range(len(p) - 1, -1, -1):
                match = i < len(s) and (s[i] == p[j] or p[j] == ".")

                if (j + 1) < len(p) and p[j + 1] == "*":
                    cache[i][j] = cache[i][j + 2]
                    if match:
                        cache[i][j] = cache[i + 1][j] or cache[i][j]
                elif match:
                    cache[i][j] = cache[i + 1][j + 1]

        return cache[0][0]


# TOP DOWN MEMOIZATION
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        cache = {}

        def dfs(i, j):
            if (i, j) in cache:
                return cache[(i, j)]
            if i >= len(s) and j >= len(p):
                return True
            if j >= len(p):
                return False

            match = i < len(s) and (s[i] == p[j] or p[j] == ".")
            if (j + 1) < len(p) and p[j + 1] == "*":
                cache[(i, j)] = dfs(i, j + 2) or (  # dont use *
                    match and dfs(i + 1, j)
                )  # use *
                return cache[(i, j)]
            if match:
                cache[(i, j)] = dfs(i + 1, j + 1)
                return cache[(i, j)]
            cache[(i, j)] = False
            return False

        return dfs(0, 0)

```

### C++

```cpp
/*
    Given string & pattern, implement RegEx matching
    '.' -> matches any single character
    '*' -> matches zero or more of the preceding element
    Matching should cover the entire input string (not partial)
    Ex. s = "aa", p = "a" -> false, "a" doesn't match entire string "aa"

    DFS + memo, 2 choices at a *: either use it, or don't use it

    Time: O(m x n)
    Space: O(m x n)
*/

class Solution {
public:
    bool isMatch(string s, string p) {
        return dfs(s, p, 0, 0);
    }
private:
    map<pair<int, int>, bool> dp;

    bool dfs(string& s, string& p, int i, int j) {
        if (dp.find({i, j}) != dp.end()) {
            return dp[{i, j}];
        }

        if (i >= s.size() && j >= p.size()) {
            return true;
        }
        if (j >= p.size()) {
            return false;
        }

        bool match = i < s.size() && (s[i] == p[j] || p[j] == '.');
        if (j + 1 < p.size() && p[j + 1] == '*') {
            // choices: either (1) don't use *, or (2) use *
            dp[{i, j}] = dfs(s, p, i, j + 2) || (match && dfs(s, p, i + 1, j));
            return dp[{i, j}];
        }

        if (match) {
            dp[{i, j}] = dfs(s, p, i + 1, j + 1);
            return dp[{i, j}];
        }

        dp[{i, j}] = false;
        return dp[{i, j}];
    }
};

```

### Java

```java
class Solution {

    public boolean isMatch(String s, String p) {
        boolean[][] cache = new boolean[s.length() + 1][p.length() + 1];

        return dfs(cache, s, p, 0, 0);
    }

    private boolean dfs(boolean[][] cache, String s, String p, int i, int j) {
        if (cache[i][j] != false) return cache[i][j];

        if (i >= s.length() && j >= p.length()) return true;

        if (j >= p.length()) return false;

        boolean match =
            i < s.length() &&
            (s.charAt(i) == p.charAt(j) || p.charAt(j) == '.');

        if (j + 1 < p.length() && p.charAt(j + 1) == '*') {
            cache[i][j] =
                dfs(cache, s, p, i, j + 2) ||
                (match && dfs(cache, s, p, i + 1, j));
        } else {
            cache[i][j] = match && dfs(cache, s, p, i + 1, j + 1);
        }

        return cache[i][j];
    }
}

```
