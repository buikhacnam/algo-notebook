---
title: Interleaving String
category: 2d Dynamic Programming
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/interleaving-string)

</Callout>

## Description
Given strings <code>s1</code>, <code>s2</code>, and <code>s3</code>, find whether <code>s3</code> is formed by an interleaving of <code>s1</code> and <code>s2</code>.

An interleaving of two strings <code>s</code> and <code>t</code> is a configuration where <code>s</code> and <code>t</code> are divided into <code>n</code> and <code>m</code> <span data-keyword="substring-nonempty">substrings</span> respectively, such that:


	- <code>s = s<sub>1</sub> + s<sub>2</sub> + ... + s<sub>n</sub></code>
	- <code>t = t<sub>1</sub> + t<sub>2</sub> + ... + t<sub>m</sub></code>
	- <code>|n - m| &lt;= 1</code>
	- The interleaving is <code>s<sub>1</sub> + t<sub>1</sub> + s<sub>2</sub> + t<sub>2</sub> + s<sub>3</sub> + t<sub>3</sub> + ...</code> or <code>t<sub>1</sub> + s<sub>1</sub> + t<sub>2</sub> + s<sub>2</sub> + t<sub>3</sub> + s<sub>3</sub> + ...</code>


Note: <code>a + b</code> is the concatenation of strings <code>a</code> and <code>b</code>.

 
Example 1:
<Image alt="" src="https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg" width={561} height={203} />
<br /><pre className="overflow-x-auto">
Input: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;
Output: true
Explanation: One way to obtain s3 is:
Split s1 into s1 = &quot;aa&quot; + &quot;bc&quot; + &quot;c&quot;, and s2 into s2 = &quot;dbbc&quot; + &quot;a&quot;.
Interleaving the two splits, we get &quot;aa&quot; + &quot;dbbc&quot; + &quot;bc&quot; + &quot;a&quot; + &quot;c&quot; = &quot;aadbbcbcac&quot;.
Since s3 can be obtained by interleaving s1 and s2, we return true.
</pre>

Example 2:

<br /><pre className="overflow-x-auto">
Input: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;
Output: false
Explanation: Notice how it is impossible to interleave s2 with any other string to obtain s3.
</pre>

Example 3:

<br /><pre className="overflow-x-auto">
Input: s1 = &quot;&quot;, s2 = &quot;&quot;, s3 = &quot;&quot;
Output: true
</pre>

 
Constraints:


	- <code>0 &lt;= s1.length, s2.length &lt;= 100</code>
	- <code>0 &lt;= s3.length &lt;= 200</code>
	- <code>s1</code>, <code>s2</code>, and <code>s3</code> consist of lowercase English letters.


 
Follow up: Could you solve it using only <code>O(s2.length)</code> additional memory space?


## Solution

### Javascript
```javascript
/**
 * Brute Force - DFS
 * Time O(2^(N + M)) | Space O(N + M)
 * https://leetcode.com/problems/interleaving-string/
 * @param {string} s1
 * @param {string} s2
 * @param {string} s3
 * @return {boolean}
 */
 var isInterleave = (s1, s2, s3, i = 0, j = 0, res = '') => {
    const isBaseCase1 = (s3.length !== (s1.length + s2.length));
    if (isBaseCase1) return false;

    const isBaseCase2 = ((res === s3) && (i == s1.length) && (j == s2.length));
    if (isBaseCase2) return true;

    return dfs(s1, s2, s3, i, j, res);/* Time O(2^(N + M)) | Space O(N + M) */
}

var dfs = (s1, s2, s3, i, j, res, ans = false) => {
    const hasLeft = (i < s1.length);
    if (hasLeft) ans |= isInterleave(s1, s2, s3, (i + 1), j, `${res}${s1[i]}`); /* Time O(2^(N + M)) | Space O(N) */

    const hasRight = (j < s2.length);
    if (hasRight) ans |= isInterleave(s1, s2, s3, i, (j + 1), `${res}${s2[j]}`);/* Time O(2^(N + M)) | Space O(M) */

    return ans;
}

/**
 * DP - Top Down
 * Matrix - Memoization
 * Time O(N * M) | Space O(N * M)
 * https://leetcode.com/problems/interleaving-string/
 * @param {string} s1
 * @param {string} s2
 * @param {string} s3
 * @return {boolean}
 */
var isInterleave = (s1, s2, s3, i = 0, j = 0, k = 0, memo = initMemo(s1, s2)) => {
    const isBaseCase1 = (s3.length !== (s1.length + s2.length));
    if (isBaseCase1) return false;

    const isBaseCase2 = (i === s1.length);
    if (isBaseCase2) return (s2.slice(j) === s3.slice(k));/* Time O(M + K) | Space O(M + K) */

    const isBaseCase3 = (j === s2.length);
    if (isBaseCase3) return (s1.slice(i) === s3.slice(k));/* Time O(N + K) | Space O(N + K) */

    const hasSeen = (memo[i][j] !== null);
    if (hasSeen) return memo[i][j];

    return dfs(s1, s2, s3, i, j, k, memo);/* Time O(N * M) | Space O((N * M) + HEIGHT) */
}

var initMemo = (s1, s2) => new Array(s1.length).fill()/* Time O(N) | Space O(N) */
    .map(() => new Array(s2.length).fill(null));          /* Time O(M) | Space O(M) */

var dfs = (s1, s2, s3, i, j, k, memo) => {
    const left = ((s3[k] === s1[i]) && isInterleave(s1, s2, s3, (i + 1), j, (k + 1), memo)); /* Time O(N) | Space O(HEIGHT) */
    const right = ((s3[k] === s2[j]) && isInterleave(s1, s2, s3, i, (j + 1), (k + 1), memo));/* Time O(M) | Space O(HEIGHT) */

    memo[i][j] = left || right;                                                              /*           | Space O(N * M) */
    return memo[i][j];
}

/**
 * DP - Bottom Up
 * Matrix - Tabulation
 * Time O(N * M) | Space O(N * M)
 * https://leetcode.com/problems/interleaving-string/
 * @param {string} s1
 * @param {string} s2
 * @param {string} s3
 * @return {boolean}
 */
var isInterleave = (s1, s2, s3) => {
    const isBaseCase = (s3.length !== s1.length + s2.length);
    if (isBaseCase) return false;

    const tabu = initTabu(s1, s2);/* Time O(N * M) | Space O(N * M) */

    search(s1, s2, s3, tabu);     /* Time O(N * M) | Space O(N * M) */

    return tabu[s1.length][s2.length];
}

var initTabu = (s1, s2) => new Array((s1.length + 1)).fill()/* Time O(N) | Space O(N) */
    .map(() => new Array((s2.length + 1)).fill(null))           /* Time O(M) | Space O(M) */

var search = (s1, s2, s3, tabu) => {
    const [ rows, cols ] = [ s1.length, s2.length ];

    for (let row = 0; (row <= rows); row++) {/* Time O(N) */
        for (let col = 0; (col <= cols); col++) {/* Time O(M) */
            tabu[row][col] =                         /* Space O(N * M) */
                hasMatch(s1, s2, s3, row, col, tabu);
        }
    }
}

var hasMatch = (s1, s2, s3, i, j, tabu) => {
    const isBaseCase1 = ((i === 0) && (j === 0));
    if (isBaseCase1) return true;

    const isBaseCase2 = (i === 0);
    if (isBaseCase2) return getRight(i, j, s2, s3, tabu);

    const isBaseCase3 = (j === 0);
    if (isBaseCase3) return getLeft(i, j, s1, s3, tabu);

    const left = getLeft(i, j, s1, s3, tabu);
    const right = getRight(i, j, s2, s3, tabu)

    return (left || right);
}

var getLeft = (i, j, s1, s3, tabu) => ((tabu[(i - 1)][j] && s1[(i - 1)]) === s3[((i + j) - 1)]);

var getRight = (i, j, s2, s3, tabu) => ((tabu[i][(j - 1)] && s2[(j - 1)]) === s3[((i + j) - 1)]);

/**
 * DP - Bottom Up
 * Array - Tabulation
 * Time O(N * M) | Space O(M)
 * https://leetcode.com/problems/interleaving-string/
 * @param {string} s1
 * @param {string} s2
 * @param {string} s3
 * @return {boolean}
 */
var isInterleave = (s1, s2, s3) => {
    const isBaseCase = (s3.length !== (s1.length + s2.length));
    if (isBaseCase) return false;

    const tabu = initTabu(s2);/* Time O(M)     | Space O(M) */

    search(s1, s2, s3, tabu); /* Time O(N * M) | Space O(M) */

    return tabu[s2.length];
};

var initTabu = (s2) => new Array((s2.length + 1)).fill(false);/* Time O(M) | Space O(M) */

var search = (s1, s2, s3, tabu) => {
    const [ rows, cols ] = [ s1.length, s2.length ];

    for (let row = 0; (row <= rows); row++) {/* Time O(N)*/
        for (let col = 0; (col <= cols); col++) {/* Time O(M)*/
            tabu[col] =                              /* Space O(M)*/
                hasMatch(s1, s2, s3, row, col, tabu);
        }
    }
}

var hasMatch = (s1, s2, s3, i, j, tabu) => {
    const isBaseCase1 = ((i === 0) && (j === 0));
    if (isBaseCase1) return true;

    const isBaseCase2 = (i === 0);
    if (isBaseCase2) return getRight(i, j, s2, s3, tabu)

    const isBaseCase3 = (j === 0);
    if (isBaseCase3) return getLeft(i, j, s1, s3, tabu);;

    return getLeft(i, j, s1, s3, tabu) || getRight(i, j, s2, s3, tabu);
}

var getLeft = (i, j, s1, s3, tabu) => (tabu[j] && (s1[(i - 1)] === s3[((i + j) - 1)]));

var getRight = (i, j, s2, s3, tabu) => (tabu[(j - 1)] && (s2[(j - 1)] === s3[((i + j) - 1)]));


```
### Python
```python
class Solution:
    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:
        if len(s1) + len(s2) != len(s3):
            return False

        dp = [[False] * (len(s2) + 1) for i in range(len(s1) + 1)]
        dp[len(s1)][len(s2)] = True

        for i in range(len(s1), -1, -1):
            for j in range(len(s2), -1, -1):
                if i < len(s1) and s1[i] == s3[i + j] and dp[i + 1][j]:
                    dp[i][j] = True
                if j < len(s2) and s2[j] == s3[i + j] and dp[i][j + 1]:
                    dp[i][j] = True
        return dp[0][0]

```
### C++
```cpp
/*
    Given 3 strings, find if s3 is formed by interleaving of s1 & s2
    Ex. s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac" -> true

    DFS + memo, cache on s1 & s2 indices i & j
    2 choices: either take s1 & iterate i, or take s2 & iterate j

    Time: O(m x n)
    Space: O(m x n)
*/

class Solution {
public:
    bool isInterleave(string s1, string s2, string s3) {
        if (s3.size() != s1.size() + s2.size()) {
            return false;
        }
        return dfs(s1, s2, s3, 0, 0);
    }
private:
    map<pair<int, int>, bool> dp;
    
    bool dfs(string s1, string s2, string s3, int i, int j) {
        if (i == s1.size() && j == s2.size()) {
            return true;
        }
        if (dp.find({i, j}) != dp.end()) {
            return dp[{i, j}];
        }
        
        if (i < s1.size() && s1[i] == s3[i + j] && dfs(s1, s2, s3, i + 1, j)) {
            return true;
        }
        if (j < s2.size() && s2[j] == s3[i + j] && dfs(s1, s2, s3, i, j + 1)) {
            return true;
        }
        
        dp[{i, j}] = false;
        return dp[{i, j}];
    }
};

```
### Java
```java
class Solution {

    public boolean isInterleave(String s1, String s2, String s3) {
        if (s1.length() + s2.length() != s3.length()) {
            return false;
        }

        boolean[][] dp = new boolean[s1.length() + 1][s2.length() + 1];
        dp[s1.length()][s2.length()] = true;

        for (int i = dp.length - 1; i >= 0; i--) for (
            int j = dp[0].length - 1;
            j >= 0;
            j--
        ) {
            if (
                i < s1.length() &&
                s1.charAt(i) == s3.charAt(i + j) &&
                dp[i + 1][j]
            ) {
                dp[i][j] = true;
            }
            if (
                j < s2.length() &&
                s2.charAt(j) == s3.charAt(i + j) &&
                dp[i][j + 1]
            ) {
                dp[i][j] = true;
            }
        }

        return dp[0][0];
    }
}

```


