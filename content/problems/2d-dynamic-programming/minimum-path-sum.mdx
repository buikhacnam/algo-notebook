---
title: Minimum Path Sum
category: 2d Dynamic Programming
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/minimum-path-sum)

</Callout>

## Description
Given a <code>m x n</code> <code>grid</code> filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.

Note: You can only move either down or right at any point in time.

 
Example 1:
<Image alt="" src="https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg" width={242} height={242} />
<br /><pre className="overflow-x-auto">
Input: grid = [[1,3,1],[1,5,1],[4,2,1]]
Output: 7
Explanation: Because the path 1 &rarr; 3 &rarr; 1 &rarr; 1 &rarr; 1 minimizes the sum.
</pre>

Example 2:

<br /><pre className="overflow-x-auto">
Input: grid = [[1,2,3],[4,5,6]]
Output: 12
</pre>

 
Constraints:


	- <code>m == grid.length</code>
	- <code>n == grid[i].length</code>
	- <code>1 &lt;= m, n &lt;= 200</code>
	- <code>0 &lt;= grid[i][j] &lt;= 200</code>



## Solution

### Javascript
```javascript
404: Not Found
```
### Python
```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        prev = [float("inf")] * n
        prev[-1] = 0

        for row in range(m - 1, -1, -1):
            dp = [float("inf")] * n
            for col in range(n - 1, -1, -1):
                if col < n - 1:
                    dp[col] = min(dp[col], dp[col + 1])
                dp[col] = min(dp[col], prev[col]) + grid[row][col]
            prev = dp

        return prev[0]

```
### C++
```cpp
class Solution{
    public:    
        void Helper(vector<vector<int>> & grid, vector<vector<int>> & dp, int i, int k){            
            int X = grid.size();            
            int Y = grid[0].size();            
            for(int i = 0; i < X; i++){                
                for(k = 0; k < Y; k++){                    
                    if((i - 1 >= 0) && (k - 1 >= 0)){
                        dp[i][k] = grid[i][k] + min(dp[i - 1][k], dp[i][k - 1]);             
                    }
                    else{
                        if(i - 1 >= 0){
                            dp[i][k] = grid[i][k] + dp[i - 1][k];
                        }                        
                        if(k - 1 >= 0){
                            dp[i][k] = grid[i][k] + dp[i][k - 1];
                        }
                    }
                }
            }   
            
        }    
        int minPathSum(vector<vector<int>>& grid){            
            vector<vector<int>> dp(grid.size(), vector<int>(grid[0].size()));            
            dp[0][0] = grid[0][0];            
            Helper(grid, dp, grid.size() - 1, grid[0].size() - 1);            
            return dp[grid.size() - 1][grid[0].size() - 1];        
        }
};

```
### Java
```java
class Solution {

    public int minPathSum(int[][] grid) {
        int m = grid.length - 1;
        int n = grid[0].length - 1;
        int[][] dp = new int[m + 1][n + 1];
        for (int[] arr : dp) {
            Arrays.fill(arr, -1);
        }
        return helper(grid, m, n, dp);
    }

    public int helper(int[][] grid, int m, int n, int[][] dp) {
        if (m == 0 && n == 0) return grid[0][0];
        if (m == 0) {
            dp[m][n] = grid[m][n] + helper(grid, m, n - 1, dp);
            return dp[m][n];
        }
        if (n == 0) {
            dp[m][n] = grid[m][n] + helper(grid, m - 1, n, dp);
            return dp[m][n];
        }
        if (dp[m][n] != -1) return dp[m][n];
        dp[m][n] =
            grid[m][n] +
            Math.min(helper(grid, m, n - 1, dp), helper(grid, m - 1, n, dp));
        return dp[m][n];
    }
}

```


