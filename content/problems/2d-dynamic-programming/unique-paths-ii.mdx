---
title: Unique Paths II
category: 2d Dynamic Programming
difficulty: Medium
---

<Callout>

[Leetcode Link](https://leetcode.com/problems/unique-paths-ii)

</Callout>

## Description

You are given an <code>m x n</code> integer array <code>grid</code>. There is a robot initially located at the <b>top-left corner</b> (i.e., <code>grid[0][0]</code>). The robot tries to move to the bottom-right corner (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.

An obstacle and space are marked as <code>1</code> or <code>0</code> respectively in <code>grid</code>. A path that the robot takes cannot include any square that is an obstacle.

Return _the number of possible unique paths that the robot can take to reach the bottom-right corner_.

The testcases are generated so that the answer will be less than or equal to <code>2 \* 10<sup>9</sup></code>.

Example 1:

<Image
	alt=""
	src="https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg"
	width={242}
	height={242}
/>
<br />
<pre className="overflow-x-auto">
	Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]] Output: 2 Explanation: There
	is one obstacle in the middle of the 3x3 grid above. There are two ways to
	reach the bottom-right corner: 1. Right -&gt; Right -&gt; Down -&gt; Down 2.
	Down -&gt; Down -&gt; Right -&gt; Right
</pre>

Example 2:

<Image
	alt=""
	src="https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg"
	width={162}
	height={162}
/>
<br />
<pre className="overflow-x-auto">
	Input: obstacleGrid = [[0,1],[0,0]] Output: 1
</pre>

Constraints:

    - <code>m == obstacleGrid.length</code>
    - <code>n == obstacleGrid[i].length</code>
    - <code>1 &lt;= m, n &lt;= 100</code>
    - <code>obstacleGrid[i][j]</code> is <code>0</code> or <code>1</code>.

## Solution

### Javascript

```javascript
Solution will be updated soon
```

### Python

```python
class Solution:
    def uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:
        M, N = len(grid), len(grid[0])
        dp = [0] * N
        dp[N-1] = 1

        # Time: O(N*M), Space: O(N)
        for r in reversed(range(M)):
            for c in reversed(range(N)):
                if grid[r][c]:
                    dp[c] = 0
                elif c + 1 < N:
                    dp[c] = dp[c] + dp[c + 1]
        return dp[0]


        # Time: O(N*M), Space: O(N*M)
        M, N = len(grid), len(grid[0])
        dp = {(M - 1, N - 1): 1}

        def dfs(r, c):
            if r == M or c == N or grid[r][c]:
                return 0
            if (r, c) in dp:
                return dp[(r, c)]
            dp[(r, c)] = dfs(r + 1, c) + dfs(r, c + 1)
            return dp[(r, c)]
        return dfs(0, 0)

```

### C++

```cpp
/*

Given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]).
The robot can only move either down or right at any point in time. An obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.

Return the number of possible unique paths that the robot can take to reach the bottom-right corner.

Example. obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
	 There is one obstacle in the middle of the 3x3 grid above.
	 There are two ways to reach the bottom-right corner:
         1. Right -> Right -> Down -> Down
         2. Down -> Down -> Right -> Right
	 So, the number of unique paths the robot can take is 2. Hence we return 2 as our answer.


Time: O(m * n)
Space: O(n)

*/


class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& grid) {

        int m = grid.size(), n = grid[0].size();
        if(grid[m-1][n-1] == 1 || grid[0][0] == 1) return 0;
        vector<long long> dp(n);
        dp[n-1] = 1;
        for(int i=m-1; i>=0; i--) {
            for(int j=n-1; j>=0; j--) {
                if(grid[i][j] == 1) dp[j] = 0;
                else if(j == n-1) continue;
                else dp[j] = dp[j] + dp[j+1];
            }
        }
        return dp[0];

    }
};

```

### Java

```java
//Same as unique paths 1 just one extra condition to return 0 if grid[i][j] == 1

class Solution {

    public int uniquePathsWithObstacles(int[][] grid) {
        return dfs(
            grid,
            0,
            0,
            grid.length,
            grid[0].length,
            new int[grid.length][grid[0].length]
        );
    }

    public int dfs(int[][] grid, int i, int j, int m, int n, int[][] dp) {
        if (i < 0 || j < 0 || i >= m || j >= n || grid[i][j] == 1) {
            return 0;
        }
        if (i == m - 1 && j == n - 1) {
            dp[i][j] = 1;
            return dp[i][j];
        }
        if (dp[i][j] != 0) return dp[i][j];
        int right = dfs(grid, i, j + 1, m, n, dp);
        int left = dfs(grid, i + 1, j, m, n, dp);
        dp[i][j] = right + left;
        return dp[i][j];
    }
}

```
